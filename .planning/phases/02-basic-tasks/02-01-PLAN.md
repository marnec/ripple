---
phase: 02-basic-tasks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - shared/enums/taskPriority.ts
  - convex/taskStatuses.ts
  - convex/tasks.ts
autonomous: true

must_haves:
  truths:
    - "Tasks table exists with projectId, title, description, statusId, assigneeId, priority, completed, creatorId, workspaceId fields"
    - "TaskStatuses table exists with workspace-scoped customizable statuses"
    - "Default statuses (To Do, In Progress, Done) are seeded when first task is created in a workspace"
    - "Task CRUD operations enforce project membership permissions"
    - "Tasks can be queried by project (with completed filter) and by assignee (cross-project)"
  artifacts:
    - path: "convex/schema.ts"
      provides: "tasks and taskStatuses table definitions with indexes"
      contains: "tasks: defineTable"
    - path: "shared/enums/taskPriority.ts"
      provides: "TaskPriority enum with urgent/high/medium/low values"
      contains: "TaskPriority"
    - path: "convex/taskStatuses.ts"
      provides: "Status CRUD and default seeding mutation"
      exports: ["seedDefaultStatuses", "listByWorkspace"]
    - path: "convex/tasks.ts"
      provides: "Task CRUD operations with permission checks"
      exports: ["create", "get", "update", "remove", "listByProject", "listByAssignee"]
  key_links:
    - from: "convex/tasks.ts"
      to: "convex/schema.ts"
      via: "tasks table definition"
      pattern: 'ctx\.db\.query\("tasks"\)'
    - from: "convex/tasks.ts"
      to: "convex/taskStatuses.ts"
      via: "default status lookup on task creation"
      pattern: 'seedDefaultStatuses|taskStatuses'
    - from: "convex/tasks.ts"
      to: "convex/projectMembers"
      via: "permission validation before mutations"
      pattern: 'projectMembers.*by_project_user'
---

<objective>
Create the complete backend foundation for task management: database schema (tasks + taskStatuses tables), task priority enum, task status seeding, and full task CRUD with permission-checked mutations and indexed queries.

Purpose: All frontend task UI depends on these backend operations. This plan establishes the data model, indexes for efficient queries, and mutation handlers with proper authorization.
Output: Working Convex backend that supports task creation, reading, updating, deleting, status management, and cross-project queries.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-basic-tasks/02-RESEARCH.md
@.planning/phases/01-projects-foundation/01-01-SUMMARY.md

@convex/schema.ts
@convex/projects.ts
@shared/enums/roles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tasks and taskStatuses tables to schema + priority enum</name>
  <files>convex/schema.ts, shared/enums/taskPriority.ts</files>
  <action>
    1. Create `shared/enums/taskPriority.ts` with:
    ```typescript
    export const TaskPriority = {
      URGENT: "urgent",
      HIGH: "high",
      MEDIUM: "medium",
      LOW: "low",
    } as const;
    ```
    Follow the exact pattern used in `shared/enums/roles.ts`.

    2. In `convex/schema.ts`, add two new tables after the `projectMembers` table definition:

    **taskStatuses table:**
    - `workspaceId: v.id("workspaces")` — workspace scope
    - `name: v.string()` — display name ("To Do", "In Progress", "Done")
    - `color: v.string()` — Tailwind class like "bg-gray-500"
    - `order: v.number()` — display order (0, 1, 2...)
    - `isDefault: v.boolean()` — marks the default status for new tasks (only one per workspace)
    - `isCompleted: v.boolean()` — when true, tasks with this status are considered completed
    - Indexes: `by_workspace` (workspaceId), `by_workspace_order` (workspaceId, order)

    **tasks table:**
    - `projectId: v.id("projects")`
    - `workspaceId: v.id("workspaces")` — denormalized for cross-project queries
    - `title: v.string()`
    - `description: v.optional(v.string())` — BlockNote JSON content stored as string
    - `statusId: v.id("taskStatuses")` — reference to customizable status
    - `assigneeId: v.optional(v.id("users"))` — single assignee
    - `priority: v.union(v.literal("urgent"), v.literal("high"), v.literal("medium"), v.literal("low"))`
    - `labels: v.optional(v.array(v.string()))` — freeform string labels (matches documents.tags pattern)
    - `completed: v.boolean()` — denormalized from status.isCompleted for efficient filtering
    - `creatorId: v.id("users")` — who created the task
    - Indexes:
      - `by_project` (projectId) — all tasks for a project
      - `by_project_completed` (projectId, completed) — filter completed/incomplete within project
      - `by_assignee` (assigneeId) — all tasks assigned to a user
      - `by_assignee_completed` (assigneeId, completed) — My Tasks with hide completed
      - `by_project_status` (projectId, statusId) — filter by status within project
      - `by_workspace` (workspaceId) — cross-project queries

    3. Import TaskPriority in schema.ts if needed for the priority union, or define the union inline using v.literal values directly (inline is fine since the enum is simple).

    4. Also export the shared enums barrel: check if `shared/enums/index.ts` exists and add `taskPriority` export if so.
  </action>
  <verify>Run `npx convex dev --once` (or `npx convex deploy` if dev server running) to validate schema. Check that no type errors exist with `npx tsc --noEmit`.</verify>
  <done>Schema has tasks and taskStatuses tables with all fields and indexes. TaskPriority enum exists in shared/enums/. Convex schema deploys without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create taskStatuses.ts and tasks.ts with full CRUD operations</name>
  <files>convex/taskStatuses.ts, convex/tasks.ts</files>
  <action>
    1. Create `convex/taskStatuses.ts` with these functions:

    **seedDefaultStatuses** (mutation):
    - Args: `{ workspaceId: v.id("workspaces") }`
    - Returns: `v.null()`
    - Check if statuses already exist for workspace (query by_workspace, .first()). If exist, return early.
    - Insert 3 default statuses:
      - { name: "To Do", color: "bg-gray-500", order: 0, isDefault: true, isCompleted: false }
      - { name: "In Progress", color: "bg-blue-500", order: 1, isDefault: false, isCompleted: false }
      - { name: "Done", color: "bg-green-500", order: 2, isDefault: false, isCompleted: true }

    **listByWorkspace** (query):
    - Args: `{ workspaceId: v.id("workspaces") }`
    - Returns: array of taskStatus documents
    - Query with `by_workspace_order` index, collect, sorted by order
    - Validate user is workspace member first

    **create** (mutation):
    - Args: workspaceId, name, color, isCompleted
    - Calculate next order number (max existing order + 1)
    - isDefault always false for user-created statuses
    - Permission: must be workspace member

    **update** (mutation):
    - Args: statusId, name (optional), color (optional), order (optional)
    - Permission: must be workspace member

    **remove** (mutation):
    - Args: statusId
    - Cannot remove if it's the default status
    - Cannot remove if tasks are currently using this status
    - Permission: must be workspace member

    2. Create `convex/tasks.ts` with these functions:

    **create** (mutation):
    - Args: projectId, title, description (optional), statusId (optional), assigneeId (optional), priority (optional, default "medium"), labels (optional)
    - Auth: getAuthUserId, validate project membership via projectMembers.by_project_user
    - Get project to access workspaceId
    - If no statusId: call seedDefaultStatuses internally (import from taskStatuses or inline), then get default status via by_workspace index + filter isDefault
    - Set completed based on status.isCompleted
    - Insert task with all fields
    - Returns: task ID

    **get** (query):
    - Args: taskId (v.id("tasks"))
    - Get task, validate membership on its project
    - Return task enriched with status (ctx.db.get(statusId)) and assignee (ctx.db.get(assigneeId)) data
    - Returns: enriched task object or null

    **listByProject** (query):
    - Args: projectId, hideCompleted (optional boolean, default true)
    - Validate project membership
    - If hideCompleted: query by_project_completed with completed=false
    - Else: query by_project (all tasks)
    - Order by _creationTime desc (newest first)
    - Enrich each task with status and assignee data (Promise.all map)
    - Return enriched array

    **listByAssignee** (query):
    - Args: workspaceId (v.id("workspaces")), hideCompleted (optional boolean, default true)
    - Get current userId
    - If hideCompleted: query by_assignee_completed with assigneeId=userId, completed=false
    - Else: query by_assignee with assigneeId=userId
    - Filter to only tasks in the specified workspace
    - Enrich with status, assignee, and project data (need project name for My Tasks grouping)
    - Return enriched array

    **update** (mutation):
    - Args: taskId, title (optional), description (optional), statusId (optional), assigneeId (optional), priority (optional), labels (optional)
    - Auth: validate membership on task's project
    - If statusId changed: look up new status, update completed field accordingly
    - Patch the task with provided fields only
    - Returns: v.null()

    **remove** (mutation):
    - Args: taskId
    - Auth: validate membership on task's project
    - Delete the task document
    - Returns: v.null()

    Follow patterns from `convex/projects.ts`: use getAuthUserId, ConvexError for auth errors, return validators on all functions. Use `withIndex()` for ALL queries (never .filter() for indexed fields).

    For the return type validators: define inline object validators or use v.any() for enriched types (enriched tasks have nested status/assignee objects that are hard to type precisely). Prefer v.any() for complex return types to avoid validator complexity.
  </action>
  <verify>
    Run `npx convex dev --once` to deploy functions. Run `npx tsc --noEmit` for type checking. Verify all exported functions appear in the Convex dashboard or via `npx convex functions` output.
  </verify>
  <done>
    taskStatuses.ts has seedDefaultStatuses, listByWorkspace, create, update, remove functions. tasks.ts has create, get, listByProject, listByAssignee, update, remove functions. All mutations validate project/workspace membership. Task creation auto-seeds default statuses if none exist. All functions deploy without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` deploys successfully with new schema
2. `npx tsc --noEmit` passes with no type errors
3. `npm run lint` passes
4. Schema has tasks table with 6 indexes and taskStatuses table with 2 indexes
5. tasks.ts exports: create, get, listByProject, listByAssignee, update, remove
6. taskStatuses.ts exports: seedDefaultStatuses, listByWorkspace, create, update, remove
7. All mutations check authentication and project membership
</verification>

<success_criteria>
- Tasks and taskStatuses tables exist in Convex schema with proper indexes
- TaskPriority enum exists at shared/enums/taskPriority.ts
- Full task CRUD works with permission checks
- Default statuses auto-seed on first task creation
- Cross-project query (listByAssignee) returns tasks grouped by project
- No lint or type errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-tasks/02-01-SUMMARY.md`
</output>
