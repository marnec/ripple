---
phase: 16-auth-resilience
plan: 04
type: execute
wave: 2
depends_on: ["16-03"]
files_modified:
  - convex/schema.ts
  - convex/diagrams.ts
  - src/pages/App/Diagram/DiagramPage.tsx
  - src/pages/App/Document/CustomBlocks/DiagramBlock.tsx
  - src/pages/App/Project/CustomInlineContent/DiagramEmbed.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Diagram embeds in documents show an SVG preview of the diagram content"
    - "Diagram embeds in tasks show an SVG preview of the diagram content"
    - "SVG preview updates when the diagram is saved (periodic or on disconnect)"
  artifacts:
    - path: "convex/schema.ts"
      provides: "svgPreview optional string field on diagrams table"
      contains: "svgPreview"
    - path: "convex/diagrams.ts"
      provides: "updateSvgPreview mutation for storing SVG strings"
      contains: "updateSvgPreview"
    - path: "src/pages/App/Diagram/DiagramPage.tsx"
      provides: "SVG generation and Convex save on diagram changes"
      contains: "exportToSvg"
    - path: "src/pages/App/Document/CustomBlocks/DiagramBlock.tsx"
      provides: "Renders SVG preview from diagram.svgPreview field"
      contains: "dangerouslySetInnerHTML"
    - path: "src/pages/App/Project/CustomInlineContent/DiagramEmbed.tsx"
      provides: "Renders SVG preview from diagram.svgPreview field"
      contains: "dangerouslySetInnerHTML"
  key_links:
    - from: "src/pages/App/Diagram/DiagramPage.tsx"
      to: "convex/diagrams.ts updateSvgPreview"
      via: "useMutation call after exportToSvg"
      pattern: "updateSvgPreview"
    - from: "src/pages/App/Document/CustomBlocks/DiagramBlock.tsx"
      to: "convex/diagrams.ts get"
      via: "useQuery for diagram.svgPreview"
      pattern: "diagram\\.svgPreview"
    - from: "src/pages/App/Project/CustomInlineContent/DiagramEmbed.tsx"
      to: "convex/diagrams.ts get"
      via: "useQuery for diagram.svgPreview"
      pattern: "diagram\\.svgPreview"
---

<objective>
Store SVG preview strings in Convex when diagrams are saved, and render those SVG strings inline in DiagramBlock (documents) and DiagramEmbed (tasks) to restore diagram preview functionality lost when Phase 15 removed the content field.

Purpose: Per user decision -- actual SVG strings stored in a field on the diagrams table, NOT thumbnails/images, NOT Yjs snapshot decoding.
Output: Diagram embeds show live SVG previews that update as diagrams are edited.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-auth-resilience/16-03-PLAN.md
@convex/schema.ts
@convex/diagrams.ts
@src/pages/App/Diagram/DiagramPage.tsx
@src/pages/App/Diagram/ExcalidrawEditor.tsx
@src/pages/App/Document/CustomBlocks/DiagramBlock.tsx
@src/pages/App/Project/CustomInlineContent/DiagramEmbed.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add svgPreview field to schema and updateSvgPreview mutation</name>
  <files>convex/schema.ts, convex/diagrams.ts</files>
  <action>
**Schema change (convex/schema.ts):**
Add `svgPreview: v.optional(v.string())` to the `diagrams` table definition, after the `yjsSnapshotId` field. This stores the serialized SVG string generated by Excalidraw's exportToSvg.

**Mutation (convex/diagrams.ts):**
1. Add the `svgPreview` field to the `diagramValidator` at the top of the file:
   ```
   svgPreview: v.optional(v.string()),
   ```

2. Create a new public mutation `updateSvgPreview`:
   ```typescript
   export const updateSvgPreview = mutation({
     args: {
       id: v.id("diagrams"),
       svgPreview: v.string(),
     },
     returns: v.null(),
     handler: async (ctx, { id, svgPreview }) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new ConvexError("Not authenticated");

       const diagram = await ctx.db.get(id);
       if (!diagram) throw new ConvexError("Diagram not found");

       // Check workspace membership
       const workspaceMembership = await ctx.db
         .query("workspaceMembers")
         .withIndex("by_workspace_user", (q) =>
           q.eq("workspaceId", diagram.workspaceId).eq("userId", userId),
         )
         .first();

       if (!workspaceMembership)
         throw new ConvexError(
           `User="${userId}" is not a member of workspace="${diagram.workspaceId}"`,
         );

       await ctx.db.patch(id, { svgPreview });
       return null;
     },
   });
   ```

This is a public mutation (not internal) because it's called from the frontend after exportToSvg. Permission check follows the same pattern as `rename` and `remove` mutations -- workspace membership verification using `by_workspace_user` index.
  </action>
  <verify>
Run `npm run lint` -- must pass with 0 warnings.
Run `npx convex dev --once` or equivalent to validate schema compiles.
Verify schema.ts has svgPreview field on diagrams table.
Verify diagrams.ts has updateSvgPreview mutation with workspace membership check.
  </verify>
  <done>
diagrams table has optional svgPreview string field.
updateSvgPreview mutation exists with proper auth and workspace membership validation.
diagramValidator includes svgPreview field so get/list queries return it.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate SVG on diagram save and render in embeds</name>
  <files>src/pages/App/Diagram/DiagramPage.tsx, src/pages/App/Document/CustomBlocks/DiagramBlock.tsx, src/pages/App/Project/CustomInlineContent/DiagramEmbed.tsx</files>
  <action>
**SVG generation in DiagramPage.tsx:**

1. Import `exportToSvg` from `@excalidraw/excalidraw` and `useMutation` from `convex/react`
2. Import `api` from convex generated API
3. Add `const updateSvgPreview = useMutation(api.diagrams.updateSvgPreview);` in DiagramPageContent
4. Add a debounced SVG generation effect that runs when Yjs elements change. Implementation:

   ```typescript
   // Generate and save SVG preview when elements change (debounced)
   useEffect(() => {
     if (!excalidrawAPI || !isConnected) return;

     const timer = setTimeout(async () => {
       try {
         const elements = excalidrawAPI.getSceneElements();
         const appState = excalidrawAPI.getAppState();

         // Skip if no elements
         if (elements.length === 0) return;

         const svg = await exportToSvg({
           elements,
           appState: {
             ...appState,
             exportWithDarkMode: false,
             exportBackground: false,
           },
           files: excalidrawAPI.getFiles(),
         });

         const svgString = svg.outerHTML;

         // Only save if content is non-trivial (not just an empty SVG wrapper)
         if (svgString.length > 100) {
           await updateSvgPreview({ id: diagramId, svgPreview: svgString });
         }
       } catch (error) {
         console.error("Failed to generate SVG preview:", error);
       }
     }, 3000); // 3 second debounce -- no need to be instant, this is for embeds

     return () => clearTimeout(timer);
   }, [excalidrawAPI, isConnected, diagramId, updateSvgPreview]);
   ```

   IMPORTANT: The dependency array intentionally uses `isConnected` to retrigger when connection state changes (generates preview on first connect). The debounce at 3 seconds prevents excessive Convex mutations during rapid editing.

   NOTE: The exportToSvg function signature -- check the actual Excalidraw API. It may take `{ elements, appState, files }` as a single options object. If the API differs, adjust accordingly. The key parameters are: elements from getSceneElements(), appState with exportWithDarkMode:false and exportBackground:false for clean SVGs, and files for embedded images.

   ALSO: To trigger updates as the user draws, add an `onChange` callback to the Excalidraw component. The simplest approach is to add a piece of state that increments on every meaningful onChange, and include it in the effect dependency array. However, this could be heavy. An alternative is to trigger SVG generation only when the excalidrawAPI scene changes by using a ref to track the last element count or version, and including the excalidrawAPI in deps. Use a ref counter approach:

   ```typescript
   const changeCountRef = useRef(0);
   const [changeCount, setChangeCount] = useState(0);
   ```

   In the Excalidraw onChange handler (add `onChange` prop to the Excalidraw component in ExcalidrawEditor, or handle it in DiagramPage): increment changeCount. But since ExcalidrawEditor is a separate component, the simplest approach is to use a periodic check instead of onChange:

   SIMPLEST APPROACH: Use `setInterval` inside a useEffect to periodically generate SVG (e.g., every 10 seconds while connected). This avoids needing to thread onChange through the component boundary:

   ```typescript
   useEffect(() => {
     if (!excalidrawAPI || !isConnected) return;

     const generateSvg = async () => {
       try {
         const elements = excalidrawAPI.getSceneElements();
         if (elements.length === 0) return;

         const svg = await exportToSvg({
           elements,
           appState: {
             ...excalidrawAPI.getAppState(),
             exportWithDarkMode: false,
             exportBackground: false,
           },
           files: excalidrawAPI.getFiles(),
         });

         const svgString = svg.outerHTML;
         if (svgString.length > 100) {
           await updateSvgPreview({ id: diagramId, svgPreview: svgString });
         }
       } catch (error) {
         console.error("Failed to generate SVG preview:", error);
       }
     };

     // Generate immediately on first connect
     void generateSvg();

     // Then periodically while connected
     const interval = setInterval(generateSvg, 10_000); // Every 10 seconds

     return () => clearInterval(interval);
   }, [excalidrawAPI, isConnected, diagramId, updateSvgPreview]);
   ```

   Use this interval approach. 10 seconds is frequent enough for previews to feel current, infrequent enough to not overload Convex.

**Render SVG in DiagramBlock.tsx (document embeds):**

The DiagramView component already queries `api.diagrams.get` which returns the diagram object. After Plan 03, the placeholder is clickable. Now update DiagramView to render the SVG preview when available:

1. Replace the `parsedElements` logic. Instead of `const parsedElements = null`, check `diagram.svgPreview`:
   ```typescript
   const hasSvgPreview = diagram !== undefined && diagram !== null && !!diagram.svgPreview;
   ```

2. If `hasSvgPreview`, render the SVG inline:
   ```tsx
   if (hasSvgPreview) {
     return (
       <div
         className="w-full cursor-pointer hover:opacity-90 transition-opacity"
         onClick={handleClick}
         dangerouslySetInnerHTML={{ __html: diagram.svgPreview }}
         style={{ lineHeight: 0 }}
       />
     );
   }
   ```

   Add `style={{ lineHeight: 0 }}` to prevent extra space below inline SVG.

   The SVG element inside will have its own width/height attributes from Excalidraw. Add CSS to make the SVG responsive:
   ```tsx
   // Add a wrapper style that makes the SVG fill the container width
   <div
     className="w-full cursor-pointer hover:opacity-90 transition-opacity [&>svg]:w-full [&>svg]:h-auto"
     onClick={handleClick}
     dangerouslySetInnerHTML={{ __html: diagram.svgPreview }}
   />
   ```

3. Keep the existing placeholder as fallback when `!hasSvgPreview` (diagram exists but no SVG yet).

4. The `handleClick` function was added in Plan 03. Make sure the SVG preview div also uses it.

5. Update the `onAspectRatioChange` callback: when SVG preview is rendered, parse the SVG viewBox to compute aspect ratio. Use a useEffect or ref callback:
   - After rendering SVG, find the SVG element in the DOM and read its viewBox or width/height attributes
   - Call `onAspectRatioChange(height / width)` if available
   - This keeps the resize handles working proportionally

   OR simpler: don't worry about aspect ratio from SVG for now. The SVG is responsive (`w-full h-auto`) so it will scale naturally. Remove the aspectRatio-dependent height calculation from the wrapper when SVG is present by letting height be `auto`.

**Render SVG in DiagramEmbed.tsx (task inline embeds):**

DiagramEmbedView already queries `api.diagrams.get`. Update similarly:

1. Replace `const parsedElements = null` with:
   ```typescript
   const hasSvgPreview = diagram !== undefined && diagram !== null && !!diagram.svgPreview;
   ```

2. If `hasSvgPreview`, render SVG preview with click handler:
   ```tsx
   if (hasSvgPreview) {
     return (
       <div
         className="my-2 border rounded-lg overflow-hidden cursor-pointer hover:opacity-90 transition-opacity [&>svg]:w-full [&>svg]:h-auto [&>svg]:max-h-40"
         contentEditable={false}
         onClick={handleClick}
         dangerouslySetInnerHTML={{ __html: diagram.svgPreview }}
       />
     );
   }
   ```

3. Keep existing placeholder as fallback for diagrams without SVG preview.

**Security note on dangerouslySetInnerHTML:** The SVG strings come from `exportToSvg` which is Excalidraw's own export function -- it generates clean SVG markup from the element data. The strings are stored and retrieved from Convex (our own backend). This is safe. If paranoia is needed, a future iteration could sanitize with DOMPurify, but it's not needed for v1.
  </action>
  <verify>
Run `npm run lint` -- must pass with 0 warnings.
Run `npm run build` -- must succeed.
Verify DiagramPage.tsx contains exportToSvg import and interval-based SVG generation effect.
Verify DiagramBlock.tsx renders SVG from diagram.svgPreview with dangerouslySetInnerHTML.
Verify DiagramEmbed.tsx renders SVG from diagram.svgPreview with dangerouslySetInnerHTML.
  </verify>
  <done>
SVG preview strings are generated every 10 seconds while a user edits a diagram and stored in Convex.
DiagramBlock in documents shows SVG preview when available, falls back to clickable placeholder.
DiagramEmbed in tasks shows SVG preview when available, falls back to clickable placeholder.
Both embeds are clickable and navigate to the diagram page.
SVG previews are responsive (scale to container width).
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. Schema has svgPreview field on diagrams table
4. diagrams.ts has updateSvgPreview mutation
5. DiagramPage generates SVG and saves to Convex periodically
6. DiagramBlock renders SVG preview or falls back to clickable placeholder
7. DiagramEmbed renders SVG preview or falls back to clickable placeholder
</verification>

<success_criteria>
- Opening a diagram, drawing something, and waiting 10 seconds stores an SVG preview string
- Embedding that diagram in a document shows the SVG preview inline
- Embedding that diagram in a task description shows the SVG preview inline
- Both embeds are clickable and navigate to the diagram page
- Diagrams without SVG preview (legacy) show the existing clickable placeholder
</success_criteria>

<output>
After completion, create `.planning/phases/16-auth-resilience/16-04-SUMMARY.md`
</output>
