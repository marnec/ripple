---
phase: 16-auth-resilience
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-yjs-provider.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Connection status indicator recovers to connected state when network comes back online after going offline"
    - "Stale provider is destroyed and fresh provider created on network recovery"
    - "Going offline still immediately shows disconnected state (no regression)"
  artifacts:
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "reconnectTrigger state that forces connection effect re-run on online event"
      contains: "reconnectTrigger"
  key_links:
    - from: "handleOnline (window online event)"
      to: "connection useEffect"
      via: "reconnectTrigger state increment in dependency array"
      pattern: "setReconnectTrigger"
    - from: "handleOnline"
      to: "providerRef.current.destroy()"
      via: "stale provider cleanup before triggering reconnect"
      pattern: "providerRef\\.current\\.destroy"
---

<objective>
Fix the connection status indicator so it recovers to "connected" after the browser goes offline and comes back online.

Purpose: UAT test 1 found that toggling Chrome DevTools offline mode correctly shows disconnected, but removing throttling never restores the connection. Root cause: Chrome DevTools offline mode does NOT close WebSocket connections, so y-partykit never fires a close event and never triggers its reconnection logic. The handleOnline function only sets isOffline=false but does not destroy the stale provider or trigger a fresh connection.
Output: Modified use-yjs-provider.ts with reconnection logic on browser online event.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-auth-resilience/16-03-SUMMARY.md
@src/hooks/use-yjs-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnectTrigger state and destroy stale provider on online event</name>
  <files>src/hooks/use-yjs-provider.ts</files>
  <action>
The problem is in the second useEffect (the offline/online listener at ~line 169). When the browser fires the "online" event, handleOnline only sets `isOffline=false`. But the old YPartyKitProvider still holds a stale WebSocket that Chrome kept open (DevTools offline mode does NOT close WebSockets). y-partykit checks `ws === null` before calling setupWS, so it never reconnects because the stale ws object still exists. No close event was fired, so exponential backoff never started either.

**Fix: Add a `reconnectTrigger` state and use it to force the connection useEffect to re-run.**

1. Add a new state variable after the existing state declarations (after line 25):
   ```typescript
   const [reconnectTrigger, setReconnectTrigger] = useState(0);
   ```

2. Add `reconnectTrigger` to the connection useEffect's dependency array (line 165). Change:
   ```typescript
   }, [resourceType, resourceId, enabled, yDoc, getToken]);
   ```
   to:
   ```typescript
   }, [resourceType, resourceId, enabled, yDoc, getToken, reconnectTrigger]);
   ```
   This means incrementing reconnectTrigger will cause the entire connection useEffect to re-run (its cleanup function destroys the old provider, then connect() creates a fresh one).

3. Update `handleOnline` in the second useEffect (lines 181-186) to destroy the stale provider and trigger reconnection:
   ```typescript
   const handleOnline = () => {
     console.info("Browser online event detected - triggering reconnection");
     // Destroy the stale provider (its WebSocket is dead but Chrome didn't close it)
     if (providerRef.current) {
       providerRef.current.destroy();
       providerRef.current = null;
     }
     setProvider(null);
     setIsOffline(false);
     setIsLoading(true);
     // Increment reconnectTrigger to force the connection useEffect to re-run
     setReconnectTrigger((prev) => prev + 1);
   };
   ```

   Key aspects of this fix:
   - `providerRef.current.destroy()` tears down the stale WebSocket and all event listeners
   - Nulling providerRef and calling setProvider(null) ensures clean state
   - `setIsLoading(true)` shows loading state while reconnecting
   - `setReconnectTrigger((prev) => prev + 1)` triggers the connection useEffect to re-run
   - The connection useEffect's cleanup runs first (handles the cancelled flag + any remaining refs), then connect() creates a fresh provider with a new WebSocket

   IMPORTANT: Do NOT set `isConnected=true` in handleOnline. Let the WebSocket sync/status events handle that after the fresh provider actually connects. This preserves the existing correctness where isConnected reflects actual WebSocket state.

   IMPORTANT: The order matters. Destroy the provider BEFORE incrementing the trigger. React batches state updates, so all the setX calls happen in the same render. But providerRef is a ref (not state), so it's mutated synchronously. The cleanup function in the connection useEffect checks providerRef.current, so we need it to already be null to avoid double-destroy.

   Actually, correction: The connection useEffect cleanup checks `providerRef.current` and destroys it. Since we already destroyed and nulled it in handleOnline, the cleanup will see null and skip the destroy. Then the effect body runs connect() which creates a fresh provider. This is safe -- no double-destroy.
  </action>
  <verify>
1. Run `npm run lint` -- must pass with 0 warnings.
2. Run `npm run build` -- must succeed.
3. Verify the file contains `reconnectTrigger` state variable.
4. Verify the connection useEffect dependency array includes `reconnectTrigger`.
5. Verify handleOnline calls `providerRef.current.destroy()` and `setReconnectTrigger`.
6. Verify handleOffline still sets isOffline=true and isConnected=false (no regression).
  </verify>
  <done>
- handleOnline destroys the stale provider and increments reconnectTrigger
- Connection useEffect re-runs on reconnectTrigger change, creating a fresh provider
- Going offline still immediately shows disconnected state (existing handleOffline unchanged)
- Fresh provider reconnects and fires sync/status events, restoring isConnected=true
- No double-destroy of provider (ref nulled before effect cleanup runs)
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. `src/hooks/use-yjs-provider.ts` contains reconnectTrigger state and uses it in connection useEffect deps
4. handleOnline destroys stale provider, nulls refs, sets loading, increments reconnectTrigger
5. handleOffline unchanged (no regression to offline detection)
</verification>

<success_criteria>
- Setting Chrome DevTools to "Offline" shows disconnected indicator immediately (existing behavior preserved)
- Removing "Offline" throttling triggers provider destruction and fresh reconnection
- Connection indicator returns to connected state after network recovery
- No provider leak (stale provider destroyed before new one created)
</success_criteria>

<output>
After completion, create `.planning/phases/16-auth-resilience/16-05-SUMMARY.md`
</output>
