---
phase: 16-auth-resilience
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - convex/collaboration.ts
  - convex/http.ts
  - partykit/server.ts
  - src/hooks/use-yjs-provider.ts
autonomous: true

must_haves:
  truths:
    - "When a user's membership is revoked in Convex, their PartyKit connection terminates within 60 seconds"
    - "Revoked user receives a permission_revoked message before disconnection"
    - "Frontend handles permission_revoked gracefully without crashing"
    - "Permission checks do not disrupt active legitimate editing sessions"
  artifacts:
    - path: "convex/collaboration.ts"
      provides: "checkAccess internal query for PartyKit permission re-validation"
      contains: "checkAccess"
    - path: "convex/http.ts"
      provides: "GET /collaboration/check-access endpoint for server-to-server permission validation"
      contains: "check-access"
    - path: "partykit/server.ts"
      provides: "Periodic permission re-validation alarm that disconnects revoked users"
      contains: "PERMISSION_CHECK_INTERVAL|checkPermissions"
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "permission_revoked message handler that triggers onPermissionRevoked callback"
      contains: "permission_revoked"
  key_links:
    - from: "partykit/server.ts"
      to: "convex/http.ts"
      via: "GET /collaboration/check-access called periodically for each connected user"
      pattern: "check-access"
    - from: "convex/http.ts"
      to: "convex/collaboration.ts"
      via: "Runs checkAccess internal query to validate membership"
      pattern: "checkAccess"
    - from: "partykit/server.ts"
      to: "src/hooks/use-yjs-provider.ts"
      via: "Sends permission_revoked WebSocket message before closing connection"
      pattern: "permission_revoked"
---

<objective>
Implement periodic permission re-validation so that users whose access is revoked are disconnected from PartyKit collaboration rooms within 60 seconds.

Purpose: Currently, once a user connects to a PartyKit room, no further permission checks occur. If a workspace admin removes a user from a project/document/diagram, the user can continue editing until they close the tab. This plan adds a periodic server-side check that validates each connected user's access against Convex and disconnects unauthorized users with a clear `permission_revoked` message.

Output: New Convex `checkAccess` query + HTTP endpoint, PartyKit permission check alarm, frontend `permission_revoked` handler.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-auth-resilience/16-01-SUMMARY.md

Key files to read before implementing:
@convex/collaboration.ts
@convex/http.ts
@partykit/server.ts
@src/hooks/use-yjs-provider.ts
@shared/protocol/messages.ts
@shared/protocol/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convex checkAccess query and HTTP endpoint for permission re-validation</name>
  <files>convex/collaboration.ts, convex/http.ts</files>
  <action>
**In `convex/collaboration.ts`**, add a new internal query `checkAccess` that validates whether a userId still has access to a resource:

```typescript
export const checkAccess = internalQuery({
  args: {
    userId: v.id("users"),
    resourceType: v.union(v.literal("doc"), v.literal("diagram"), v.literal("task")),
    resourceId: v.string(),
  },
  returns: v.boolean(),
  handler: async (ctx, { userId, resourceType, resourceId }) => {
    if (resourceType === "doc") {
      // Reuse existing checkDocumentAccess logic inline
      const member = await ctx.db
        .query("documentMembers")
        .withIndex("by_document_user", (q) =>
          q.eq("documentId", resourceId as any).eq("userId", userId)
        )
        .first();
      return member !== null;
    } else if (resourceType === "diagram") {
      const member = await ctx.db
        .query("diagramMembers")
        .withIndex("by_diagram_user", (q) =>
          q.eq("diagramId", resourceId as any).eq("userId", userId)
        )
        .first();
      return member !== null;
    } else {
      // task: check project membership via task's projectId
      const task = await ctx.db.get(resourceId as any) as any;
      if (!task || !task.projectId) return false;
      const member = await ctx.db
        .query("projectMembers")
        .withIndex("by_project_user", (q) =>
          q.eq("projectId", task.projectId).eq("userId", userId)
        )
        .first();
      return member !== null;
    }
  },
});
```

This consolidates the three separate check functions into one that takes resourceType. The existing `checkDocumentAccess`, `checkDiagramAccess`, and `checkTaskAccess` remain unchanged (they're used by `getCollaborationToken`).

**In `convex/http.ts`**, add a new HTTP endpoint for PartyKit to call:

```
GET /collaboration/check-access?roomId={roomId}&userId={userId}
```

Implementation:
1. Authenticate with `Authorization: Bearer {PARTYKIT_SECRET}` (same pattern as snapshot endpoints)
2. Extract `roomId` and `userId` from query params
3. Parse roomId to get resourceType and resourceId (same inline parsing as snapshot endpoints)
4. Call `internal.collaboration.checkAccess` with the parsed values
5. Return `{ hasAccess: true }` or `{ hasAccess: false }`
6. Return 400 for missing params, 401 for bad auth, 500 for errors

Place this route AFTER the existing snapshot routes in http.ts. Follow the exact same authentication pattern (PARTYKIT_SECRET Bearer token) used by the snapshot endpoints.
  </action>
  <verify>
Run `npm run lint` — expect 0 warnings/errors.
Run `npm run build` — expect successful compilation.
Verify `convex/collaboration.ts` exports `checkAccess` internal query.
Verify `convex/http.ts` has a GET route for `/collaboration/check-access`.
Verify the endpoint validates PARTYKIT_SECRET authentication.
  </verify>
  <done>
Convex has a `checkAccess` internal query that validates membership for any resource type, and an HTTP GET endpoint that PartyKit can call with server-to-server auth to check if a specific userId still has access to a room.
  </done>
</task>

<task type="auto">
  <name>Task 2: PartyKit periodic permission check and frontend permission_revoked handler</name>
  <files>partykit/server.ts, src/hooks/use-yjs-provider.ts</files>
  <action>
**In `partykit/server.ts`**, add periodic permission re-validation:

1. **Add constants:**
```typescript
const PERMISSION_CHECK_INTERVAL = 30_000; // 30 seconds — check twice per 60s requirement
const ALARM_TYPE_PERMISSION = "permission";
```

2. **Add a `checkPermissions()` private method** that iterates all connections, checks each user's access, and disconnects unauthorized users:

```typescript
private async checkPermissions(): Promise<void> {
  const convexSiteUrl = this.room.env.CONVEX_SITE_URL as string;
  const secret = this.room.env.PARTYKIT_SECRET as string;
  if (!convexSiteUrl || !secret) return;

  // Parse roomId once for this room
  const dashIndex = this.room.id.indexOf("-");
  if (dashIndex === -1) return;
  const resourceType = this.room.id.substring(0, dashIndex);
  const resourceId = this.room.id.substring(dashIndex + 1);

  for (const conn of this.room.getConnections()) {
    const state = conn.state as ConnectionState | undefined;
    if (!state?.userId) continue;

    try {
      const url = new URL(`${convexSiteUrl}/collaboration/check-access`);
      url.searchParams.set("roomId", this.room.id);
      url.searchParams.set("userId", state.userId);

      const response = await fetch(url.toString(), {
        method: "GET",
        headers: { "Authorization": `Bearer ${secret}` },
      });

      if (response.ok) {
        const data = await response.json() as { hasAccess: boolean };
        if (!data.hasAccess) {
          console.log(`Permission revoked for user ${state.userId} in room ${this.room.id}`);
          const msg: ServerMessage = {
            type: "permission_revoked",
            reason: "Your access to this resource has been revoked",
          };
          conn.send(JSON.stringify(msg));
          conn.close(1008, "AUTH_FORBIDDEN");
        }
      }
    } catch (error) {
      // Don't disconnect on check failure — fail open to avoid disrupting legitimate users
      console.error(`Permission check failed for user ${state.userId}:`, error);
    }
  }
}
```

3. **Integrate permission checks into the alarm system.** The existing alarm system uses a single `setAlarm` per room. Since PartyKit rooms only support one alarm at a time, we need to **piggyback permission checks onto the periodic save alarm**.

Modify the `onAlarm` handler's `ALARM_TYPE_PERIODIC` branch to also call `checkPermissions()`:

```typescript
} else if (alarmType === ALARM_TYPE_PERIODIC) {
  let connectionCount = 0;
  for (const _ of this.room.getConnections()) {
    connectionCount++;
  }
  if (connectionCount > 0) {
    console.log(`Periodic save triggered for room ${this.room.id}`);
    await this.saveSnapshotToConvex();
    await this.checkPermissions(); // <-- ADD THIS
    await this.room.storage.put("alarmType", ALARM_TYPE_PERIODIC);
    await this.room.storage.setAlarm(Date.now() + PERIODIC_SAVE_INTERVAL);
  } else {
    this.periodicAlarmScheduled = false;
  }
}
```

This means permission checks happen every 30 seconds (same interval as periodic saves), which satisfies the "within 60 seconds" requirement. This avoids the complexity of managing multiple alarm types.

4. **Also check permissions when someone reconnects** (a user reconnecting during the disconnect debounce window). In the `ALARM_TYPE_DISCONNECT` branch, when `connectionCount > 0` (someone reconnected), also run permission check:

```typescript
if (connectionCount === 0) {
  // ... existing save logic
} else {
  console.log(`User reconnected to room ${this.room.id} during debounce, cancelling save`);
  this.saveAlarmScheduled = false;
  await this.checkPermissions(); // <-- ADD THIS
}
```

5. **Import ServerMessage type** — it's already imported via `import type { ErrorCode, ServerMessage } from "@shared/protocol";`. No change needed.

**In `src/hooks/use-yjs-provider.ts`**, add a message handler for `permission_revoked`:

After the provider is created and event handlers are set up, add a WebSocket message listener:

```typescript
// Listen for custom protocol messages (permission revoked, etc.)
newProvider.ws?.addEventListener("message", (event) => {
  if (typeof event.data !== "string") return; // Skip binary Yjs sync messages
  try {
    const msg = JSON.parse(event.data);
    if (msg.type === "permission_revoked") {
      console.warn("Permission revoked:", msg.reason);
      if (!cancelled) {
        setIsConnected(false);
        // Destroy provider to stop reconnection attempts
        newProvider.destroy();
        providerRef.current = null;
        setProvider(null);
      }
    }
  } catch {
    // Not JSON — ignore (binary Yjs messages handled separately by y-partykit)
  }
});
```

**Important:** The WebSocket might not be immediately available when the provider is constructed (it connects asynchronously). Instead of `newProvider.ws?.addEventListener`, use the provider's `on("status")` callback to hook into the WebSocket after connection:

```typescript
newProvider.on("status", ({ status }: { status: string }) => {
  if (!cancelled) {
    setIsConnected(status === "connected");

    // Attach message listener when connected
    if (status === "connected" && newProvider.ws) {
      newProvider.ws.addEventListener("message", handleProtocolMessage);
    }
  }
});
```

Where `handleProtocolMessage` is defined above the event handlers:

```typescript
const handleProtocolMessage = (event: MessageEvent) => {
  if (typeof event.data !== "string") return;
  try {
    const msg = JSON.parse(event.data);
    if (msg.type === "permission_revoked") {
      console.warn("Permission revoked:", msg.reason);
      if (!cancelled) {
        setIsConnected(false);
        newProvider.shouldConnect = false; // Prevent reconnection
        newProvider.destroy();
        providerRef.current = null;
        setProvider(null);
      }
    }
  } catch {
    // Not JSON — skip binary messages
  }
};
```

Set `newProvider.shouldConnect = false` before destroy to prevent the provider from attempting reconnection after the permission revocation.
  </action>
  <verify>
Run `npm run lint` — expect 0 warnings/errors.
Run `npm run build` — expect successful compilation.
Verify `partykit/server.ts` has `checkPermissions` method.
Verify `partykit/server.ts` calls `checkPermissions()` in the periodic alarm handler.
Verify `partykit/server.ts` sends `permission_revoked` message before closing connection.
Verify `src/hooks/use-yjs-provider.ts` handles `permission_revoked` messages.
Verify `convex/http.ts` has `/collaboration/check-access` route.
  </verify>
  <done>
PartyKit server periodically validates user permissions every 30 seconds and disconnects unauthorized users with a `permission_revoked` message. Frontend handles this message gracefully by stopping reconnection attempts and cleaning up the provider.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. `convex/collaboration.ts` has `checkAccess` internal query
4. `convex/http.ts` has GET `/collaboration/check-access` endpoint with PARTYKIT_SECRET auth
5. `partykit/server.ts` has `checkPermissions` method called every 30s via periodic alarm
6. `partykit/server.ts` sends `permission_revoked` message type before closing revoked connections
7. `src/hooks/use-yjs-provider.ts` listens for `permission_revoked` and stops provider reconnection
8. No regressions: existing auth, sync, and snapshot persistence unchanged
</verification>

<success_criteria>
- PartyKit server validates each connected user's permission every 30 seconds (within 60-second requirement)
- Users whose access is revoked receive `permission_revoked` message and are disconnected
- Frontend stops reconnection attempts after permission revocation (no infinite retry loop)
- Permission check failures (Convex unavailable) fail open (don't disconnect legitimate users)
- Existing collaboration features continue to work without disruption
- TypeScript compiles without errors, ESLint passes with 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/16-auth-resilience/16-02-SUMMARY.md`
</output>
