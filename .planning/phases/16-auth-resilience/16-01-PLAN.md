---
phase: 16-auth-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-yjs-provider.ts
  - partykit/server.ts
autonomous: true

must_haves:
  truths:
    - "When a WebSocket connection drops, the provider automatically reconnects with a fresh token without page reload"
    - "User stays connected during extended editing sessions beyond the initial 5-minute token TTL"
    - "The y-partykit built-in reconnection with exponential backoff works seamlessly with fresh tokens"
  artifacts:
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "Dynamic params function that fetches fresh token on each reconnect"
      contains: "params.*=>|params.*async"
    - path: "partykit/server.ts"
      provides: "Connection state tracking with userId per connection"
      contains: "conn.setState\\|conn.id"
  key_links:
    - from: "src/hooks/use-yjs-provider.ts"
      to: "convex/collaboration.ts"
      via: "getCollaborationToken action called on each reconnect via params function"
      pattern: "getToken.*resourceType.*resourceId"
    - from: "partykit/server.ts"
      to: "convex/http.ts"
      via: "POST /collaboration/verify called on each new WebSocket connection"
      pattern: "collaboration/verify"
---

<objective>
Implement automatic WebSocket reconnection with fresh token acquisition so collaboration sessions survive network drops without page reload.

Purpose: Currently tokens are consumed (deleted) on first connect. When y-partykit's built-in reconnection fires after a network drop, the stale token is rejected and the user is permanently disconnected. This plan makes the `params` option a function that fetches a fresh token on each connection attempt, and tracks userId per connection on the server side.

Output: Modified `use-yjs-provider.ts` with dynamic params function, modified `partykit/server.ts` with per-connection user state tracking.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-protocol-foundation/14-01-SUMMARY.md
@.planning/phases/15-persistence-layer/15-02-SUMMARY.md

Key files to read before implementing:
@src/hooks/use-yjs-provider.ts
@partykit/server.ts
@convex/collaboration.ts
@shared/protocol/messages.ts
@shared/protocol/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynamic token refresh in useYjsProvider via params function</name>
  <files>src/hooks/use-yjs-provider.ts</files>
  <action>
Rewrite the `useYjsProvider` hook to use YPartyKitProvider's `params` option as an **async function** instead of a static object. This leverages the built-in reconnection in y-partykit — each time the provider reconnects (after network drop, server restart, etc.), it calls the params function to get fresh params.

**Key change:** Instead of fetching a token once in useEffect and passing `{ token }` as static params, pass an async function that calls `getCollaborationToken` each time:

```typescript
const newProvider = new YPartyKitProvider(host, roomId, yDoc, {
  connect: true,
  params: async () => {
    const { token } = await getToken({ resourceType, resourceId });
    return { token };
  },
});
```

**Important implementation details:**

1. **Remove the one-time token fetch from the connect function.** The initial `getToken()` call that happens before creating the provider is no longer needed — the params function handles all token acquisition (initial + reconnections).

2. **The roomId must still be computed outside the params function** because YPartyKitProvider needs the room name at construction time. Compute it as `${resourceType}-${resourceId}` (same format as `buildRoomId` from shared/protocol, but inline it to avoid importing — matches existing pattern in convex/collaboration.ts line 57).

3. **Keep all existing event handlers** (`sync`, `status`) exactly as they are. The reconnection behavior and state tracking doesn't change — only how tokens are provided.

4. **Keep the cancelled flag pattern** for cleanup. The provider's built-in reconnection handles retries; we just need the cancelled flag to prevent state updates after unmount.

5. **Error handling in params function:** If `getToken()` fails (user logged out, no access), the params function will throw, which causes the WebSocket connection to fail. The provider will retry with exponential backoff. Add a try/catch in the params function that returns a fallback empty token `{ token: "" }` on error and logs the error — this lets the server reject the connection gracefully with `AUTH_INVALID` rather than the provider throwing during param resolution.

6. **Remove the `getToken` from the useEffect dependency array** since it's now called inside the params function closure, not in the effect body directly. The `getToken` action reference is stable (from `useAction`), so this is safe.
  </action>
  <verify>
Run `npm run lint` — expect 0 warnings/errors.
Run `npm run build` — expect successful compilation.
Verify `use-yjs-provider.ts` contains `params:` with an async function (not a static object).
Verify no direct `getToken()` call exists outside the params function.
  </verify>
  <done>
YPartyKitProvider is created with a params function that fetches a fresh collaboration token on every connection attempt (initial + reconnections). The hook compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Per-connection user state tracking in PartyKit server</name>
  <files>partykit/server.ts</files>
  <action>
Update the PartyKit server to store authenticated user identity on each connection object using PartyKit's connection state API. This is needed so that:
1. Permission re-validation (Plan 02) knows which userId to check per connection
2. Reconnections are properly authenticated (fresh token verified each time)

**Changes to `onConnect` method:**

After successful token verification (the `response.ok` block), store the authenticated user's identity on the connection using PartyKit's `conn.setState()`:

```typescript
// After getting userData from verify response
conn.setState({ userId: userData.userId, userName: userData.userName });
```

PartyKit connections have `.setState(state)` and `.state` for storing per-connection metadata. This persists for the lifetime of the connection.

**No changes to the auth flow itself.** The existing token consumption pattern (one-time use, delete after verify) stays the same. Each reconnection attempt from the client will use a fresh token from the params function (Task 1), which gets consumed normally.

**No changes to onClose, onAlarm, or snapshot methods.** Those don't need userId yet (Plan 02 will add permission checking).

**Add TypeScript type for connection state:**
Define an interface at the top of the file:

```typescript
interface ConnectionState {
  userId: string;
  userName: string;
}
```

Then type the setState call: `conn.setState<ConnectionState>({ userId: userData.userId, userName: userData.userName });`

Note: PartyKit's Connection type supports generic state via `Connection<ConnectionState>`. However, since `onConnect` receives `Party.Connection` (untyped), use a type assertion or just call `setState` with the object — PartyKit stores it as-is. The typing is for documentation; Plan 02 will read it back with `(conn as Party.Connection).state`.
  </action>
  <verify>
Run `npm run lint` — expect 0 warnings/errors.
Run `npm run build` — expect successful compilation.
Verify `partykit/server.ts` contains `conn.setState` in the onConnect method.
Verify `ConnectionState` interface is defined.
  </verify>
  <done>
PartyKit server stores authenticated userId and userName on each connection object after successful token verification. Connection state is typed with ConnectionState interface.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. `use-yjs-provider.ts` uses async params function (not static params object)
4. `partykit/server.ts` stores user identity on connection via setState
5. No regressions: existing sync, status event handlers, and snapshot persistence unchanged
</verification>

<success_criteria>
- YPartyKitProvider created with dynamic params function that fetches fresh token on each connection/reconnection
- PartyKit server tracks userId per connection for downstream permission re-validation
- All existing collaboration features (Yjs sync, awareness, snapshots) continue to work
- TypeScript compiles without errors, ESLint passes with 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/16-auth-resilience/16-01-SUMMARY.md`
</output>
