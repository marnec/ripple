---
phase: 10-inline-reply-to
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/messages.ts
  - shared/types/channel.ts
autonomous: true

must_haves:
  truths:
    - "Messages table supports optional replyToId field referencing another message"
    - "messages.send mutation accepts optional replyToId parameter"
    - "messages.list query returns replyTo object (author, plainText, deleted) for reply messages"
    - "If parent message is deleted, replyTo.deleted is true"
    - "If parent message does not exist, replyTo is null"
  artifacts:
    - path: "convex/schema.ts"
      provides: "messages table with replyToId optional field"
      contains: "replyToId"
    - path: "convex/messages.ts"
      provides: "Send mutation with replyToId, list query enriched with parent info"
      contains: "replyToId"
    - path: "shared/types/channel.ts"
      provides: "MessageWithAuthor type extended with replyToId and replyTo"
      contains: "replyTo"
  key_links:
    - from: "convex/messages.ts"
      to: "convex/schema.ts"
      via: "messages table schema includes replyToId"
      pattern: "replyToId.*v\\.optional.*v\\.id"
    - from: "convex/messages.ts"
      to: "convex-helpers/server/relationships"
      via: "getAll for batch parent message fetch"
      pattern: "getAll.*parentIds"
---

<objective>
Add reply-to support to the messages backend: schema extension, mutation update, and query enrichment.

Purpose: Enables REPLY-01 through REPLY-04 at the data layer. Messages can now reference a parent message, the send mutation accepts replyToId, and the list query returns enriched parent info for rendering quote previews. Graceful handling of deleted parents is built in.

Output: Updated schema.ts with replyToId field, updated messages.ts (send + list), updated MessageWithAuthor type.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-inline-reply-to/10-RESEARCH.md

# Key source files to read before implementing
@convex/schema.ts
@convex/messages.ts
@shared/types/channel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend messages schema and send mutation with replyToId</name>
  <files>convex/schema.ts, convex/messages.ts</files>
  <action>
Add optional replyToId field to messages table and accept it in the send mutation.

**Step 1: Update convex/schema.ts**

Add `replyToId: v.optional(v.id("messages"))` to the messages table definition, after the `deleted` field. This is a nullable foreign key referencing another message.

Do NOT add a `by_reply_to` index -- it's not needed for v0.9 (we never query "all replies to message X"). Keep the existing indexes unchanged.

**Step 2: Update messages.send mutation in convex/messages.ts**

1. Add `replyToId: v.optional(v.id("messages"))` to the `args` object.

2. Add `replyToId` to the destructured handler args.

3. In the `ctx.db.insert("messages", {...})` call, add `replyToId` to the inserted fields. When `replyToId` is undefined, Convex will simply not store the field (optional fields work this way).

4. Do NOT add any validation that the parent message exists or isn't deleted -- this is intentional. If the parent is deleted between the user clicking Reply and sending, the reply still sends (the query layer handles the deleted state gracefully).

IMPORTANT: Do NOT modify any other mutations (update, remove, search, getMessageContext). Only `send` needs the replyToId parameter.
  </action>
  <verify>Run `npm run lint` -- no TypeScript errors. Verify schema.ts has `replyToId: v.optional(v.id("messages"))` in messages table. Verify messages.send accepts and inserts replyToId.</verify>
  <done>Messages schema supports optional replyToId. The send mutation accepts replyToId and stores it with the message.</done>
</task>

<task type="auto">
  <name>Task 2: Enrich messages.list query with parent message info and update shared type</name>
  <files>convex/messages.ts, shared/types/channel.ts</files>
  <action>
Enrich the messages.list query to return parent message info for replies, and update the shared TypeScript type.

**Step 1: Update shared/types/channel.ts**

Update the `MessageWithAuthor` interface to include the new reply fields. Since this type extends `Doc<"messages">` and the schema now has `replyToId`, the optional field is inherited automatically. But we need to add the enriched `replyTo` field:

```typescript
import { Doc, Id } from "../../convex/_generated/dataModel";

export interface ChannelMember extends Doc<"channelMembers"> {
  name: string;
}

export type ReplyToInfo = {
  author: string;
  plainText: string;
  deleted: boolean;
} | null;

export interface MessageWithAuthor extends Doc<"messages"> {
  author: string;
  replyTo: ReplyToInfo;
}
```

**Step 2: Update messages.list query in convex/messages.ts**

1. Update the return validator's page array object to include:
   - `replyToId: v.optional(v.id("messages"))` -- the raw field from schema
   - `replyTo: v.union(v.null(), v.object({ author: v.string(), plainText: v.string(), deleted: v.boolean() }))` -- the enriched parent info

2. After the existing `messagesWithAuthor` mapping (where users are added), add parent message enrichment:

   ```typescript
   // Batch-fetch parent messages for replies
   const parentIds = [...new Set(
     messagesWithAuthor
       .filter(m => m.replyToId)
       .map(m => m.replyToId!)
   )];
   const parents = parentIds.length > 0 ? await getAll(ctx.db, parentIds) : [];
   const parentMap = new Map(parents.map((p, i) => [parentIds[i], p]));

   // Enrich with parent message info
   const messagesWithReplyTo = messagesWithAuthor.map((msg) => {
     if (!msg.replyToId) {
       return { ...msg, replyTo: null };
     }
     const parent = parentMap.get(msg.replyToId);
     if (!parent) {
       return { ...msg, replyTo: null };
     }
     // Note: parent user might not be in userMap if they haven't sent a message in this page
     const parentUser = userMap.get(parent.userId);
     return {
       ...msg,
       replyTo: {
         author: parentUser?.name ?? parentUser?.email ?? "Unknown",
         plainText: parent.plainText,
         deleted: parent.deleted,
       },
     };
   });
   ```

   IMPORTANT: If the parent user is NOT in the existing userMap (because they didn't send a message in the current page), we need to handle this. The simplest approach: collect parent user IDs that aren't in userMap, batch-fetch them separately:

   ```typescript
   // Collect parent user IDs not already in userMap
   const missingParentUserIds = [...new Set(
     parents.filter(p => p && !userMap.has(p.userId)).map(p => p!.userId)
   )];
   if (missingParentUserIds.length > 0) {
     const missingUsers = await getAll(ctx.db, missingParentUserIds);
     missingUsers.forEach((u, i) => {
       if (u) userMap.set(missingParentUserIds[i], u);
     });
   }
   ```

   Place this BEFORE the `messagesWithReplyTo` mapping so userMap is fully populated.

3. Return `messagesWithReplyTo` instead of `messagesWithAuthor` in the final return:
   ```typescript
   return {
     ...messagesPage,
     page: messagesWithReplyTo,
   };
   ```

4. Also update the `search` and `getMessageContext` query return validators to include the new fields in their page/messages array objects:
   - Add `replyToId: v.optional(v.id("messages"))` to the return validator objects
   - Add `replyTo: v.union(v.null(), v.object({ author: v.string(), plainText: v.string(), deleted: v.boolean() }))` to the return validator objects
   - Add the same parent enrichment logic (batch fetch parents, enrich with replyTo) to both queries

   Note: For `search` and `getMessageContext`, follow the same pattern as `list` -- batch fetch parent IDs, build parentMap, enrich messages. This ensures search results and context views also show reply previews.

IMPORTANT: The return type uses `v.any()` is NOT acceptable. Use the precise validator as shown. The `replyTo` field must be `v.union(v.null(), v.object(...))` -- null when not a reply or parent not found, object when parent exists.
  </action>
  <verify>Run `npm run lint` -- no TypeScript errors. Run `npm run build` -- build succeeds. Verify messages.list return validator includes replyToId and replyTo fields. Verify MessageWithAuthor type includes replyTo.</verify>
  <done>messages.list returns enriched parent message info for replies. Deleted parents have `deleted: true` in replyTo. Missing parents have `replyTo: null`. MessageWithAuthor type updated to match.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero warnings
2. `npm run build` succeeds
3. convex/schema.ts messages table has `replyToId: v.optional(v.id("messages"))`
4. messages.send mutation accepts `replyToId: v.optional(v.id("messages"))` in args
5. messages.list return validator includes `replyToId` and `replyTo` fields
6. messages.list handler batch-fetches parent messages using getAll
7. Parent users not in the current page's userMap are fetched separately
8. shared/types/channel.ts MessageWithAuthor includes `replyTo: ReplyToInfo`
</verification>

<success_criteria>
- Messages can be created with an optional replyToId reference
- messages.list returns replyTo info (author, plainText, deleted) for reply messages
- Deleted parent messages return replyTo with deleted: true
- Non-existent parent messages return replyTo: null
- No TypeScript errors, lint and build pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/10-inline-reply-to/10-01-SUMMARY.md`
</output>
