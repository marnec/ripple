---
phase: 10-inline-reply-to
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/pages/App/Chat/ChatContext.ts
  - src/pages/App/Chat/Chat.tsx
  - src/pages/App/Chat/Message.tsx
  - src/pages/App/Chat/MessageComposer.tsx
  - src/pages/App/Chat/MessageQuotePreview.tsx
autonomous: true

must_haves:
  truths:
    - "User can right-click any non-deleted, non-reply message and click Reply to enter reply mode"
    - "Reply mode shows compact quoted preview in composer area with cancel button"
    - "Sending a message in reply mode includes replyToId and clears reply state"
    - "Replies display in chat flow with compact quote preview above the message bubble"
    - "Deleted parent messages show [Message deleted] placeholder in quote preview"
    - "Reply mode and edit mode are mutually exclusive"
  artifacts:
    - path: "src/pages/App/Chat/ChatContext.ts"
      provides: "Reply mode state (replyingTo, setReplyingTo) alongside existing edit mode"
      contains: "replyingTo"
    - path: "src/pages/App/Chat/MessageQuotePreview.tsx"
      provides: "Reusable quote preview component for composer and message display"
      contains: "MessageQuotePreview"
    - path: "src/pages/App/Chat/Message.tsx"
      provides: "Reply context menu action and quote preview above reply messages"
      contains: "handleReply"
    - path: "src/pages/App/Chat/MessageComposer.tsx"
      provides: "Reply preview in composer and replyToId in submission"
      contains: "replyingTo"
    - path: "src/pages/App/Chat/Chat.tsx"
      provides: "Reply state management and replyToId in sendMessage call"
      contains: "replyingTo"
  key_links:
    - from: "src/pages/App/Chat/Message.tsx"
      to: "src/pages/App/Chat/ChatContext.ts"
      via: "useChatContext for setReplyingTo"
      pattern: "setReplyingTo"
    - from: "src/pages/App/Chat/MessageComposer.tsx"
      to: "src/pages/App/Chat/MessageQuotePreview.tsx"
      via: "import for reply preview in composer"
      pattern: "import.*MessageQuotePreview"
    - from: "src/pages/App/Chat/Chat.tsx"
      to: "convex/messages.ts"
      via: "sendMessage mutation with replyToId"
      pattern: "replyToId.*replyingTo"
---

<objective>
Add reply mode UI to chat: context menu Reply action, composer quote preview, and inline quote preview on sent replies.

Purpose: Enables REPLY-01 (reply action), REPLY-02 (composer preview), REPLY-03 (sent reply display), and REPLY-04 (deleted message placeholder). Completes the inline reply-to feature with full UX.

Output: Updated ChatContext with reply state, new MessageQuotePreview component, updated Message.tsx with reply action + display, updated MessageComposer with reply preview, updated Chat.tsx with reply state management.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-inline-reply-to/10-RESEARCH.md
@.planning/phases/10-inline-reply-to/10-01-SUMMARY.md

# Key source files to read before implementing
@src/pages/App/Chat/ChatContext.ts
@src/pages/App/Chat/Chat.tsx
@src/pages/App/Chat/Message.tsx
@src/pages/App/Chat/MessageComposer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ChatContext with reply mode and create MessageQuotePreview component</name>
  <files>src/pages/App/Chat/ChatContext.ts, src/pages/App/Chat/MessageQuotePreview.tsx</files>
  <action>
Add reply mode state to ChatContext and create the reusable quote preview component.

**Step 1: Update ChatContext.ts**

1. Add a new exported type for the reply state:
   ```typescript
   export type ReplyingToMessage = {
     id: Id<"messages">;
     author: string;
     plainText: string;
   } | null;
   ```

2. Extend the context type to include reply mode state:
   ```typescript
   type ChatContextType = {
     editingMessage: EditingMessage;
     setEditingMessage: (msg: EditingMessage) => void;
     replyingTo: ReplyingToMessage;
     setReplyingTo: (msg: ReplyingToMessage) => void;
   };
   ```

3. Update `ChatContext` to use the new type name `ChatContextType`.

4. Update `useChatContext` return type accordingly (it already uses `useContext(ChatContext)` so the type will flow through).

**Step 2: Create MessageQuotePreview.tsx**

Create `src/pages/App/Chat/MessageQuotePreview.tsx`:

```tsx
import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

type MessageQuotePreviewProps = {
  message: {
    author: string;
    plainText: string;
    deleted: boolean;
  } | null;
  onCancel?: () => void;
  compact?: boolean;
};

export function MessageQuotePreview({ message, onCancel, compact = false }: MessageQuotePreviewProps) {
  if (!message) {
    return (
      <div className={cn(
        "flex items-center gap-2 px-3 py-1.5 bg-muted/50 rounded-md border-l-2 border-muted-foreground/40 text-sm text-muted-foreground italic",
        compact && "py-1 text-xs"
      )}>
        [Original message not found]
      </div>
    );
  }

  if (message.deleted) {
    return (
      <div className={cn(
        "flex items-center gap-2 px-3 py-1.5 bg-muted/50 rounded-md border-l-2 border-muted-foreground/40 text-sm text-muted-foreground italic",
        compact && "py-1 text-xs"
      )}>
        [Message deleted]
      </div>
    );
  }

  const truncatedText = message.plainText.length > 100
    ? message.plainText.slice(0, 100) + "..."
    : message.plainText;

  return (
    <div className={cn(
      "flex items-start gap-2 px-3 py-1.5 bg-muted/50 rounded-md border-l-2 border-primary",
      compact && "py-1"
    )}>
      <div className="flex-1 min-w-0">
        <div className={cn("font-semibold text-muted-foreground", compact ? "text-xs" : "text-xs")}>
          {message.author}
        </div>
        <div className={cn("truncate", compact ? "text-xs" : "text-sm")}>
          {truncatedText}
        </div>
      </div>
      {onCancel && (
        <Button variant="ghost" size="icon" className="h-6 w-6 shrink-0" onClick={onCancel}>
          <X className="h-3 w-3" />
        </Button>
      )}
    </div>
  );
}
```

Key design decisions:
- `message: null` renders "[Original message not found]" (parent completely missing)
- `message.deleted: true` renders "[Message deleted]" (REPLY-04)
- `onCancel` prop only shown in composer mode (not in sent message display)
- `compact` prop for smaller variant in sent message display
- Border-l-2 with primary color for visual distinction as quote
- Text truncated to 100 chars with ellipsis
  </action>
  <verify>Run `npm run lint` -- no TypeScript errors. Verify ChatContext.ts exports ReplyingToMessage type and context includes replyingTo/setReplyingTo. Verify MessageQuotePreview.tsx exists and handles null, deleted, and normal states.</verify>
  <done>ChatContext supports reply mode alongside edit mode. MessageQuotePreview renders compact quoted previews with author, truncated text, deleted placeholders, and optional cancel button.</done>
</task>

<task type="auto">
  <name>Task 2: Wire reply mode into Chat, Message, and MessageComposer</name>
  <files>src/pages/App/Chat/Chat.tsx, src/pages/App/Chat/Message.tsx, src/pages/App/Chat/MessageComposer.tsx</files>
  <action>
Connect the reply mode state through Chat.tsx, add Reply action to Message context menu, add reply preview to MessageComposer, and show quote preview on sent replies.

**Step 1: Update Chat.tsx**

1. Import `ReplyingToMessage` from `./ChatContext`.

2. Add reply state alongside existing editing state:
   ```typescript
   const [replyingTo, setReplyingTo] = useState<ReplyingToMessage>(null);
   ```

3. Update the ChatContext.Provider value to include reply state:
   ```typescript
   <ChatContext.Provider value={{ editingMessage, setEditingMessage, replyingTo, setReplyingTo }}>
   ```

4. Update `handleSubmit` to include replyToId when in reply mode and clear reply state after sending:
   ```typescript
   const handleSubmit = async (body: string, plainText: string) => {
     if (editingMessage.id) {
       await editMessage({ id: editingMessage.id, body, plainText }).finally(() => {
         setEditingMessage({ id: null, body: null });
       });
     } else {
       const isomorphicId = crypto.randomUUID();

       await sendMessage({
         body,
         plainText,
         channelId,
         isomorphicId,
         ...(replyingTo?.id ? { replyToId: replyingTo.id } : {}),
       }).catch((error) => {
         toast({ variant: "destructive", title: "could not send message", content: error });
       });

       // Clear reply mode after sending
       if (replyingTo) {
         setReplyingTo(null);
       }
     }
   };
   ```

**Step 2: Update Message.tsx**

1. Import `MessageQuotePreview` from `./MessageQuotePreview`.

2. Destructure `setReplyingTo` from `useChatContext()` alongside existing `setEditingMessage`.

3. Add `handleReply` callback:
   ```typescript
   const handleReply = useCallback(() => {
     // Clear edit mode (mutually exclusive)
     setEditingMessage({ id: null, body: null });
     // Enter reply mode
     setReplyingTo({
       id: message._id,
       author: message.author,
       plainText: message.plainText,
     });
   }, [message, setEditingMessage, setReplyingTo]);
   ```

4. Update `handleEdit` to also clear reply mode:
   ```typescript
   const handleEdit = useCallback(() => {
     setReplyingTo(null); // Clear reply mode (mutually exclusive)
     setEditingMessage({ id: message._id, body: message.body });
   }, [message, setEditingMessage, setReplyingTo]);
   ```

5. Add "Reply" context menu item to ContextMenuContent. Place it BEFORE "Create task from message", and only show it if:
   - The message is NOT deleted (`!message.deleted`)
   - The message is NOT already a reply (`!message.replyToId`) -- prevents nested replies per requirements

   Import `CornerUpLeft` from `lucide-react` for the reply icon.

   ```tsx
   {!message.deleted && !message.replyToId && (
     <ContextMenuItem onClick={handleReply}>
       <CornerUpLeft className="mr-2 h-4 w-4" />
       Reply
     </ContextMenuItem>
   )}
   ```

6. Add quote preview rendering above the message bubble for replies. Inside the `<li>` element, BEFORE the author/time row, add:

   ```tsx
   {message.replyTo !== undefined && message.replyTo !== null && (
     <div className={cn("mb-1", userIsAuthor ? "self-end" : "self-start")}>
       <MessageQuotePreview message={message.replyTo} compact />
     </div>
   )}
   ```

   Also handle the case where `message.replyToId` exists but `message.replyTo` is null (parent not found):
   ```tsx
   {message.replyToId && message.replyTo === null && (
     <div className={cn("mb-1", userIsAuthor ? "self-end" : "self-start")}>
       <MessageQuotePreview message={null} compact />
     </div>
   )}
   ```

   These can be combined into a single conditional:
   ```tsx
   {message.replyToId && (
     <div className={cn("mb-1", userIsAuthor ? "self-end" : "self-start")}>
       <MessageQuotePreview message={message.replyTo ?? null} compact />
     </div>
   )}
   ```

**Step 3: Update MessageComposer.tsx**

1. Import `MessageQuotePreview` from `./MessageQuotePreview`.

2. Destructure `replyingTo` and `setReplyingTo` from `useChatContext()` alongside existing `editingMessage`.

3. Add reply preview above the formatting toolbar. In the return JSX, BEFORE the toolbar `<div className="flex justify-between items-start">`, add:
   ```tsx
   {replyingTo && (
     <MessageQuotePreview
       message={{
         author: replyingTo.author,
         plainText: replyingTo.plainText,
         deleted: false,
       }}
       onCancel={() => setReplyingTo(null)}
     />
   )}
   ```

   This shows the quote preview with a cancel (X) button. The `deleted: false` is safe because we only enter reply mode on non-deleted messages.

IMPORTANT considerations:
- Reply mode and edit mode are mutually exclusive. handleEdit clears reply, handleReply clears edit.
- Reply preview in composer shows cancel button (onCancel prop). Sent reply previews do NOT (no onCancel).
- The reply action is hidden on deleted messages and on messages that are already replies (no nesting).
- After sending a reply, both the replyToId and the reply state are properly cleared.
  </action>
  <verify>Run `npm run lint` -- no TypeScript errors. Run `npm run build` -- build succeeds. Verify Message.tsx has Reply context menu item with CornerUpLeft icon. Verify Message.tsx renders MessageQuotePreview for replies. Verify MessageComposer.tsx shows reply preview with cancel button. Verify Chat.tsx passes replyToId to sendMessage and clears reply state after send.</verify>
  <done>Full reply-to UX works: right-click message → Reply → composer shows quote preview → send includes replyToId → sent reply displays with compact quote above message bubble. Deleted parents show "[Message deleted]". Reply and edit modes are mutually exclusive.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero warnings
2. `npm run build` succeeds
3. ChatContext.ts exports ReplyingToMessage type and context includes replyingTo/setReplyingTo
4. MessageQuotePreview.tsx handles null (not found), deleted, and normal message states
5. Message.tsx context menu has Reply option (hidden for deleted messages and existing replies)
6. Message.tsx renders compact quote preview above reply messages
7. MessageComposer.tsx shows reply preview with cancel button when in reply mode
8. Chat.tsx manages replyingTo state and passes replyToId in sendMessage
9. Reply mode clears edit mode and vice versa (mutual exclusivity)
10. Reply state cleared after successful message send
</verification>

<success_criteria>
- Right-clicking a non-deleted, non-reply message shows "Reply" in context menu
- Clicking Reply enters reply mode: composer shows quoted preview with cancel button
- Clicking cancel button exits reply mode
- Sending a message in reply mode creates a reply with replyToId
- Sent replies display compact quote preview above the message bubble
- If original message was deleted, reply shows "[Message deleted]" in quote
- Entering edit mode clears reply mode and vice versa
- No TypeScript errors, lint and build pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/10-inline-reply-to/10-02-SUMMARY.md`
</output>
