---
phase: 17-graceful-degradation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-document-collaboration.ts
  - src/hooks/use-yjs-provider.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "No orphan 'task-' IndexedDB database created when taskId is null"
    - "Reconnection loop has exponential backoff instead of fixed-interval hammering"
    - "After repeated auth failures, reconnection pauses instead of cycling infinitely"
  artifacts:
    - path: "src/hooks/use-document-collaboration.ts"
      provides: "IndexedDB persistence gated on enabled && documentId"
      contains: "enabled.*documentId"
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "Exponential backoff on provider recreation, max recreation limit"
      contains: "MAX_RECREATIONS"
  key_links:
    - from: "use-document-collaboration.ts IndexedDB effect"
      to: "IndexeddbPersistence constructor"
      via: "early return when disabled or no documentId"
      pattern: "if.*!enabled.*!documentId.*return"
    - from: "use-yjs-provider.ts reconnect check"
      to: "setReconnectTrigger"
      via: "exponential backoff delay and max recreation counter"
      pattern: "recreationCount|MAX_RECREATIONS"
---

<objective>
Fix two minor issues found in UAT: (1) orphan "task-" IndexedDB database created when taskId is null (GAP-2, cosmetic), and (2) reconnection auth storm with infinite provider recreation loop (GAP-3, resilience).

Purpose: Clean up edge cases in the offline collaboration system for production readiness.
Output: Guarded IndexedDB persistence and rate-limited reconnection with exponential backoff.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-graceful-degradation/17-01-SUMMARY.md
@src/hooks/use-document-collaboration.ts
@src/hooks/use-yjs-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate IndexedDB persistence on enabled and documentId</name>
  <files>src/hooks/use-document-collaboration.ts</files>
  <action>
GAP-2: When `useTaskDetail.ts` passes `documentId: taskId ?? ""` with a null taskId, `useDocumentCollaboration` creates an `IndexeddbPersistence("task-", yDoc)` — an orphan empty database in IndexedDB.

Fix the IndexedDB persistence useEffect (lines 56-68) to gate on `enabled` and a non-empty `documentId`:

```typescript
useEffect(() => {
  if (!enabled || !documentId) {
    return;
  }

  const persistence = new IndexeddbPersistence(`${resourceType}-${documentId}`, yDoc);
  // ... rest unchanged
```

Add `enabled` to the dependency array: `[documentId, resourceType, yDoc, enabled]`.

This prevents IndexedDB creation when:
- `enabled` is false (hook disabled)
- `documentId` is empty string (taskId was null, coerced to "")
  </action>
  <verify>
Run `npm run lint` — must pass with 0 warnings.
Grep `use-document-collaboration.ts` for the guard: should contain `if (!enabled || !documentId)` before the IndexeddbPersistence constructor.
  </verify>
  <done>
IndexedDB persistence only created when `enabled` is true AND `documentId` is non-empty. No orphan "task-" database created when TaskDetailSheet renders with null taskId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add exponential backoff and max recreation limit to provider reconnection</name>
  <files>src/hooks/use-yjs-provider.ts</files>
  <action>
GAP-3: After long disconnect, the provider recreation loop (MAX_UNSUCCESSFUL_RECONNECTS=5 -> destroy -> recreate via setReconnectTrigger) cycles infinitely, creating an auth storm against the server.

Fix approach — add exponential backoff delay and a maximum recreation count:

1. Add constants at the top of the file:
   ```typescript
   const MAX_RECREATIONS = 3; // Stop recreating after 3 attempts
   const BASE_RECREATION_DELAY = 2000; // 2s, 4s, 8s exponential backoff
   ```

2. Add a `recreationCountRef` to track how many times the provider has been recreated:
   ```typescript
   const recreationCountRef = useRef(0);
   ```

3. In the reconnectCheckRef interval (the `setInterval` block around line 117-139), instead of immediately destroying and recreating, add backoff:
   ```typescript
   if (newProvider.wsUnsuccessfulReconnects >= MAX_UNSUCCESSFUL_RECONNECTS) {
     if (reconnectCheckRef.current) clearInterval(reconnectCheckRef.current);
     reconnectCheckRef.current = null;

     // Check if we've exceeded max recreations
     if (recreationCountRef.current >= MAX_RECREATIONS) {
       console.warn(`Max provider recreations (${MAX_RECREATIONS}) reached — pausing reconnection`);
       setIsOffline(true);
       setIsLoading(false);
       return;
     }

     newProvider.shouldConnect = false;
     try {
       newProvider.awareness.setLocalState(null);
     } catch {
       // Awareness may already be destroyed
     }
     newProvider.destroy();
     providerRef.current = null;
     setProvider(null);

     if (!cancelled) {
       const delay = BASE_RECREATION_DELAY * Math.pow(2, recreationCountRef.current);
       recreationCountRef.current += 1;
       console.warn(`Recreating provider in ${delay}ms (attempt ${recreationCountRef.current}/${MAX_RECREATIONS})`);
       setTimeout(() => {
         if (!cancelled) {
           setReconnectTrigger((prev) => prev + 1);
         }
       }, delay);
     }
   }
   ```

4. Reset `recreationCountRef.current = 0` when a connection succeeds. In the `sync` event handler (around line 141-155), when `synced` is true:
   ```typescript
   if (synced) {
     recreationCountRef.current = 0; // Reset recreation counter on successful connection
     // ... existing timeout clearing and state updates
   }
   ```

5. Also in the `handleOnline` event handler (around line 230-246), reset the recreation counter since the user is explicitly coming back online:
   ```typescript
   const handleOnline = () => {
     console.info("Browser online event detected - triggering reconnection");
     recreationCountRef.current = 0; // Reset on explicit online event
     // ... rest unchanged
   ```

This ensures:
- After 5 failed reconnects, provider is destroyed and recreated with exponential backoff (2s, 4s, 8s)
- After 3 recreation attempts, stop trying and show offline mode
- Counter resets on successful connection or browser online event (user-initiated recovery)
  </action>
  <verify>
Run `npm run lint` — must pass with 0 warnings.
Run `npm run build` — must compile successfully.
Grep `use-yjs-provider.ts` for `MAX_RECREATIONS` — should appear as a constant and in the guard condition.
Grep `use-yjs-provider.ts` for `recreationCountRef` — should appear in declaration, increment, reset on sync, and reset on online.
  </verify>
  <done>
Provider recreation loop has exponential backoff (2s, 4s, 8s) and stops after 3 attempts, falling back to offline mode. Recreation counter resets on successful connection or browser online event. No more infinite auth storm against the server after long disconnects.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` compiles successfully
3. IndexedDB persistence in `use-document-collaboration.ts` is gated on `enabled && documentId`
4. `use-yjs-provider.ts` has `MAX_RECREATIONS` constant and `recreationCountRef`
5. Provider recreation uses `setTimeout` with exponential delay
6. Recreation counter resets on sync success and browser online event
</verification>

<success_criteria>
No orphan "task-" IndexedDB database created when taskId is null. Reconnection auth storm is eliminated — provider recreation has exponential backoff (2s/4s/8s) and stops after 3 attempts, showing offline mode instead of infinite cycling.
</success_criteria>

<output>
After completion, create `.planning/phases/17-graceful-degradation/17-04-SUMMARY.md`
</output>
