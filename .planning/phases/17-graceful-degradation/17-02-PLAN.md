---
phase: 17-graceful-degradation
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/pages/App/Document/DocumentEditor.tsx
  - src/pages/App/Diagram/DiagramPage.tsx
  - src/pages/App/Diagram/ExcalidrawEditor.tsx
  - src/pages/App/Project/useTaskDetail.ts
autonomous: true

must_haves:
  truths:
    - "When PartyKit is unreachable and IndexedDB has cached data, document editor is fully editable with offline indicator"
    - "When PartyKit is unreachable and IndexedDB has cached data, diagram editor is fully editable with offline indicator"
    - "When PartyKit is unreachable and IndexedDB has cached data, task description is fully editable with offline indicator"
    - "When PartyKit is unreachable on cold start, editors show read-only Convex snapshot with offline indicator"
    - "Active users panel is hidden when offline"
    - "When PartyKit reconnects, editors auto-transition to live collaboration mode"
  artifacts:
    - path: "src/pages/App/Document/DocumentEditor.tsx"
      provides: "Document editor with offline mode (hides ActiveUsers, shows ConnectionStatus)"
      contains: "isOffline"
    - path: "src/pages/App/Diagram/DiagramPage.tsx"
      provides: "Diagram page with offline mode (hides ActiveUsers, shows ConnectionStatus)"
      contains: "isOffline"
    - path: "src/pages/App/Diagram/ExcalidrawEditor.tsx"
      provides: "Excalidraw editor with optional read-only mode for snapshot fallback"
      contains: "viewModeEnabled"
    - path: "src/pages/App/Project/useTaskDetail.ts"
      provides: "Task detail hook exposing offline state"
      contains: "isOffline"
  key_links:
    - from: "src/pages/App/Document/DocumentEditor.tsx"
      to: "src/hooks/use-document-collaboration.ts"
      via: "isOffline prop from collaboration hook"
      pattern: "isOffline"
    - from: "src/pages/App/Diagram/DiagramPage.tsx"
      to: "src/hooks/use-diagram-collaboration.ts"
      via: "isOffline prop from collaboration hook"
      pattern: "isOffline"
    - from: "src/pages/App/Diagram/ExcalidrawEditor.tsx"
      to: "Excalidraw component"
      via: "viewModeEnabled prop for read-only snapshot mode"
      pattern: "viewModeEnabled"
---

<objective>
Wire offline mode into all three editor types: documents, diagrams, and task descriptions. When offline with IndexedDB, editors remain fully editable with collab-only features (active users, cursors) hidden. On cold start without IndexedDB, load Convex snapshot in read-only mode. Auto-recover when PartyKit reconnects.

Purpose: Completes the graceful degradation feature by connecting the offline infrastructure (Plan 01) to every editor UI, fulfilling all four success criteria for Phase 17.

Output: Updated editor components for documents, diagrams, and task descriptions with offline-aware rendering and recovery.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-graceful-degradation/17-CONTEXT.md
@.planning/phases/17-graceful-degradation/17-01-SUMMARY.md

Key source files to read before implementing:
@src/pages/App/Document/DocumentEditor.tsx
@src/pages/App/Diagram/DiagramPage.tsx
@src/pages/App/Diagram/ExcalidrawEditor.tsx
@src/pages/App/Project/useTaskDetail.ts
@src/pages/App/Document/ConnectionStatus.tsx
@src/pages/App/Document/ActiveUsers.tsx
@src/hooks/use-document-collaboration.ts
@src/hooks/use-diagram-collaboration.ts
@convex/snapshots.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire offline mode into DocumentEditor and DiagramPage with snapshot fallback</name>
  <files>
    src/pages/App/Document/DocumentEditor.tsx
    src/pages/App/Diagram/DiagramPage.tsx
    src/pages/App/Diagram/ExcalidrawEditor.tsx
  </files>
  <action>
**DocumentEditor changes (src/pages/App/Document/DocumentEditor.tsx):**

1. Destructure `isOffline` from `useDocumentCollaboration` hook (added in Plan 01).

2. **Hide ActiveUsers when offline.** Conditionally render the `ActiveUsers` component only when `isConnected` is true (when offline, there are no remote users to show and the panel adds confusion).

3. **Update ConnectionStatus props.** Pass only `isConnected` to the simplified ConnectionStatus component (Plan 01 removed the provider dependency). ConnectionStatus is always rendered (always visible per user decision).

4. **Convex snapshot fallback for cold start.** When `isOffline` is true AND the editor is null (IndexedDB had no data — cold start), load the Convex snapshot:
   - Import `useQuery` (already imported) and `api` (already imported).
   - Use `useQuery(api.snapshots.getSnapshotUrl, { resourceType: "doc", resourceId: documentId })` to get the snapshot URL.
   - When snapshotUrl is available, fetch the binary data, decode it as a Yjs update, apply it to a new Y.Doc, and render a read-only BlockNoteView.
   - For the read-only snapshot view: create a standalone editor with `useCreateBlockNote({ schema, initialContent: blocksFromSnapshot })` and render `<BlockNoteView editor={snapshotEditor} editable={false} />`.
   - Show a subtle text below the ConnectionStatus: "Viewing saved version" in muted text (Claude's discretion on messaging — I'm choosing to distinguish snapshot mode from regular offline since the user can't edit in this mode).

5. **Auto-recovery.** When `isConnected` transitions from false to true and we were in snapshot mode, the collaboration hook will have already loaded the live editor. Simply remove the snapshot fallback UI. The hook's `editor` becoming non-null (from provider sync) will naturally replace the snapshot view.

IMPLEMENTATION DETAIL for snapshot loading: Create a small helper function or useEffect that:
  - Fetches the blob from snapshotUrl
  - Creates a Y.Doc, applies the update via `Y.applyUpdate(doc, new Uint8Array(arrayBuffer))`
  - Converts the Y.Doc's XML fragment to BlockNote blocks
  - This is complex. SIMPLER APPROACH: Since BlockNote editors require specific initialization, and we only need read-only rendering, use a simpler strategy:
    - Fetch the snapshot URL
    - Create a new Y.Doc, apply the snapshot update
    - Create a BlockNote editor with the Y.Doc's fragment as collaboration source
    - Render as `editable={false}`
  - Wrap this in a `useSnapshotFallback` custom hook or inline it in DocumentEditor.

Actually, the SIMPLEST approach for snapshot fallback:
  - When `isOffline && !editor && snapshotUrl`, show a loading message "Loading saved version..."
  - Fetch the binary, create a Y.Doc, apply the update
  - Create a standalone BlockNote editor with `collaboration: { fragment: snapshotDoc.getXmlFragment("document-store"), provider: null as any }` — BUT BlockNote requires a real provider for collaboration mode.
  - EVEN SIMPLER: Just create a non-collaborative BlockNote editor and manually set its content from the Yjs snapshot. Use `yDocToBlockNote` or similar conversion.
  - SIMPLEST: Create a dedicated `SnapshotViewer` component that loads the snapshot, creates a Y.Doc, reads the XML fragment, initializes a BlockNote editor from it, and renders read-only. This avoids entangling the snapshot logic with the collaboration editor.

Create a small inline component `SnapshotFallback` inside DocumentEditor.tsx:
```tsx
function SnapshotFallback({ snapshotUrl, schema }: { snapshotUrl: string; schema: typeof schema }) {
  const [content, setContent] = useState<Block[] | null>(null);

  useEffect(() => {
    // Fetch binary snapshot, create Y.Doc, extract blocks
    fetch(snapshotUrl)
      .then(res => res.arrayBuffer())
      .then(buf => {
        const doc = new Y.Doc();
        Y.applyUpdate(doc, new Uint8Array(buf));
        // Read the XML fragment content — BlockNote uses "document-store"
        // We need to convert this... actually BlockNote doesn't expose a Yjs-to-blocks converter.
      });
  }, [snapshotUrl]);
}
```

REVISED SIMPLEST APPROACH: Since converting Yjs XML fragments to BlockNote blocks is not trivially exposed by the BlockNote API, and creating a read-only collaborative editor without a provider is tricky, take this approach:

For the snapshot cold-start fallback, create a non-collaborative BlockNote editor and use Yjs to hydrate it:
1. Fetch the snapshot binary from the Convex URL
2. Create a temporary Y.Doc
3. Apply the binary update: `Y.applyUpdate(tempDoc, new Uint8Array(buffer))`
4. Create a YPartyKitProvider-like wrapper is too complex. Instead, use the fact that BlockNote's collaboration mode works with any y-protocols provider.

FINAL APPROACH (pragmatic): For cold-start snapshot fallback, render a simple "This content is temporarily unavailable. The collaboration server is offline." message with a subtle muted style. The primary value of Phase 17 is IndexedDB-based offline editing (which handles 95%+ of cases since any user who has previously visited a document has IndexedDB cache). The cold-start-no-IndexedDB case is rare (new device + PartyKit down simultaneously). Making this work with full editor rendering is disproportionate effort for a rare edge case.

WAIT — the user decision says "Convex snapshot fallback (cold start, no IndexedDB): Claude's discretion on whether read-only or editable". I'll choose READ-ONLY with a simple approach:

For cold-start snapshot fallback, show a placeholder message: "Collaboration server unavailable. Content will load when the connection is restored." This is technically read-only (you can't edit what you can't see). BUT the success criteria says "shows read-only mode with the last Convex snapshot" — implying content should be visible.

OK, let me implement it properly. The Y.Doc from the snapshot can be used with BlockNote's collaboration mode by creating a local-only provider. Here's the approach:

1. Fetch snapshot URL, get binary
2. Create a Y.Doc, apply the update
3. Create a "fake" collaboration config for BlockNote using just the fragment from the local Y.Doc. BlockNote's `collaboration` option needs `provider` (for awareness) and `fragment`. For read-only mode, we can pass a minimal provider-like object. BUT `useCreateBlockNote` requires specific types.

ACTUALLY WORKING APPROACH: The cleanest solution is to NOT use collaboration mode for the snapshot editor. Instead:
1. Fetch the snapshot binary
2. Create a temp Y.Doc, apply update
3. Use BlockNote's `blocksToHTMLLossy` or similar to render — no, that's output not input.

Let me look at what BlockNote provides. The `collaboration.fragment` is a Y.XmlFragment. When BlockNote initializes with a collaboration fragment, it reads the content from it. So we can:
1. Fetch snapshot, create Y.Doc, apply update
2. Get the fragment: `tempDoc.getXmlFragment("document-store")`
3. Convert fragment to blocks using BlockNote's internal `yXmlFragmentToBlocks` — but this is not a public API.

PRAGMATIC DECISION: Create a dedicated state in the hook for snapshot data. When offline with no IndexedDB data:
1. The `useDocumentCollaboration` hook fetches the snapshot URL via useQuery
2. Fetches the binary, creates a Y.Doc, applies update
3. Passes this Y.Doc to BlockNote via collaboration mode with a dummy provider
4. Returns the editor as read-only

For the "dummy provider" approach: BlockNote's collaboration option needs `{ provider, fragment, user }`. The `provider` is used for awareness (cursor sync). We can create a minimal fake:
```typescript
const fakeProvider = { awareness: new Awareness(tempDoc) } as any;
```

This should work since BlockNote only uses `provider.awareness` for setting local cursor state. In read-only mode, cursors don't matter.

BUT `useCreateBlockNote` is a React hook — we can't conditionally call it. We'd need to always create the editor, or use conditional rendering with a separate component.

FINAL DECISION: Implement the snapshot fallback as a separate component rendered when `isOffline && !editor`. This component:
1. Uses `useQuery(api.snapshots.getSnapshotUrl, ...)` to get URL
2. Fetches binary in a useEffect, creates Y.Doc, applies update
3. Creates a BlockNote editor via `useCreateBlockNote` with collaboration using the local Y.Doc and a fake awareness
4. Renders `<BlockNoteView editor={editor} editable={false} />`

This keeps the main editor code clean and handles the rare cold-start case in isolation.

**DiagramPage changes (src/pages/App/Diagram/DiagramPage.tsx):**

1. Destructure `isOffline` from `useDiagramCollaboration` hook.

2. **Hide ActiveUsers when offline.** Conditionally render ActiveUsers only when `isConnected`.

3. **Update ConnectionStatus props.** Pass only `isConnected`.

4. **Snapshot fallback for diagrams (cold start).** When `isOffline && isLoading` (no IndexedDB data), similar approach but for Excalidraw:
   - Fetch snapshot URL from `useQuery(api.snapshots.getSnapshotUrl, { resourceType: "diagram", resourceId: diagramId })`
   - Fetch binary, create Y.Doc, apply update
   - Read yElements array: `tempDoc.getArray("elements")`
   - Convert to Excalidraw elements via `yjsToExcalidraw(yElements)`
   - Render Excalidraw in `viewModeEnabled` mode with these elements

5. **ExcalidrawEditor modification** for read-only support: The existing Excalidraw component already supports `viewModeEnabled` prop. No changes needed to ExcalidrawEditor.tsx for this — the snapshot fallback will render Excalidraw directly in DiagramPage without the full ExcalidrawEditor (which requires yElements/awareness/provider).

For the diagram snapshot fallback, render a simpler inline component:
```tsx
<Excalidraw
  initialData={{ elements: snapshotElements }}
  viewModeEnabled={true}
  theme={resolvedTheme as Theme}
  zenModeEnabled={true}
/>
```

6. **Auto-recovery.** When provider connects, the regular editor replaces the snapshot view naturally.

**ExcalidrawEditor changes (src/pages/App/Diagram/ExcalidrawEditor.tsx):**

Add an optional `readOnly` prop. When true, set `viewModeEnabled={true}` on the Excalidraw component and skip the binding setup (no awareness/yjs binding needed in read-only mode). This is used by the snapshot fallback in DiagramPage.

Actually, for the snapshot case, DiagramPage should render Excalidraw directly (not through ExcalidrawEditor which requires yElements/awareness). So ExcalidrawEditor.tsx changes are minimal — just ensure it handles `awareness === null` gracefully if the provider hasn't connected yet, which it already does via the `if (!excalidrawAPI || !provider || ...)` guard.

NO CHANGES to ExcalidrawEditor.tsx needed if DiagramPage handles snapshot rendering separately.
  </action>
  <verify>
Run `npm run lint` — 0 warnings.
Run `npm run build` — successful.
Verify DocumentEditor hides ActiveUsers when isOffline/not connected.
Verify DocumentEditor shows ConnectionStatus always.
Verify DiagramPage hides ActiveUsers when isOffline/not connected.
Verify DiagramPage has snapshot fallback rendering.
  </verify>
  <done>
DocumentEditor hides ActiveUsers when offline, always shows ConnectionStatus with green dot or cloud-off icon.
DocumentEditor renders read-only snapshot fallback on cold start without IndexedDB.
DiagramPage hides ActiveUsers when offline, shows snapshot fallback with viewModeEnabled Excalidraw.
Auto-recovery works: when provider connects, live editor replaces snapshot view.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire offline mode into task description editor</name>
  <files>
    src/pages/App/Project/useTaskDetail.ts
  </files>
  <action>
**useTaskDetail changes (src/pages/App/Project/useTaskDetail.ts):**

1. Destructure `isOffline` from `useDocumentCollaboration` hook call (it now returns `isOffline` from Plan 01).

2. Add `isOffline` to the return object so consuming components (TaskDetailSheet, TaskDetailPage) can use it.

3. The consuming components already use `isConnected`, `provider`, and `remoteUsers` from this hook. They render `ConnectionStatus` and `ActiveUsers` similarly to DocumentEditor.

Find the consuming components that render the task description editor UI and verify they:
- Render ConnectionStatus — update to pass just `isConnected` (matching Plan 01 simplification)
- Render ActiveUsers — conditionally render only when `isConnected`

To find consumers, search for imports of `useTaskDetail`:
- Look in `src/pages/App/Project/` for TaskDetailSheet.tsx or similar
- Look for components that render `<ConnectionStatus` and `<ActiveUsers` in the task context

For each consumer found:
- Update ConnectionStatus to use simplified props: `<ConnectionStatus isConnected={isConnected} />`
- Conditionally render ActiveUsers: `{isConnected && <ActiveUsers ... />}`

The task description offline behavior is identical to documents (per user decision: "Same offline behavior across documents, diagrams, and task descriptions"). The useDocumentCollaboration hook handles all the IndexedDB and timeout logic already — useTaskDetail just needs to expose `isOffline` and consumers need to adjust their UI.

For snapshot fallback in task descriptions (cold start): Follow the same pattern as DocumentEditor. When `isOffline && !editor`, show the snapshot fallback component or placeholder.
  </action>
  <verify>
Run `npm run lint` — 0 warnings.
Run `npm run build` — successful.
Verify useTaskDetail returns isOffline.
Verify task description consumers hide ActiveUsers when offline.
Verify task description consumers show simplified ConnectionStatus.
  </verify>
  <done>
useTaskDetail exposes isOffline from the collaboration hook.
Task description UI hides ActiveUsers when offline.
Task description ConnectionStatus uses simplified two-state indicator.
Offline task description editing works identically to documents.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` compiles successfully
3. DocumentEditor: hides ActiveUsers when offline, shows ConnectionStatus always, renders snapshot fallback on cold start
4. DiagramPage: hides ActiveUsers when offline, shows ConnectionStatus always, renders read-only Excalidraw on cold start
5. Task description: hides ActiveUsers when offline, shows ConnectionStatus, same behavior as documents
6. All three editors auto-recover when PartyKit reconnects (live editor replaces fallback)
7. ConnectionStatus shows green dot (connected) or cloud-off icon (offline) across all editors
</verification>

<success_criteria>
- All three resource types (documents, diagrams, tasks) show offline-capable editors when PartyKit unavailable
- ActiveUsers hidden in all editors when offline
- ConnectionStatus visible in all editors in both states
- Cold-start snapshot fallback renders content in read-only mode
- Auto-recovery from offline to live collaboration when provider connects
- All lint and build checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-graceful-degradation/17-02-SUMMARY.md`
</output>
