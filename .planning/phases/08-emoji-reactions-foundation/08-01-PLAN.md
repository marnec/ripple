---
phase: 08-emoji-reactions-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/messageReactions.ts
autonomous: true

must_haves:
  truths:
    - "messageReactions table exists in Convex schema with compound indexes"
    - "toggle mutation idempotently adds or removes a reaction for the current user"
    - "listForMessage query returns aggregated reactions grouped by emoji with counts and currentUserReacted flag"
  artifacts:
    - path: "convex/schema.ts"
      provides: "messageReactions table definition with indexes"
      contains: "messageReactions"
    - path: "convex/messageReactions.ts"
      provides: "toggle mutation and listForMessage query"
      exports: ["toggle", "listForMessage"]
  key_links:
    - from: "convex/messageReactions.ts"
      to: "convex/schema.ts"
      via: "messageReactions table with by_message and by_message_emoji_user indexes"
      pattern: "withIndex.*by_message"
---

<objective>
Create the Convex backend for emoji reactions: schema table with compound indexes, toggle mutation (idempotent add/remove), and aggregation query that returns grouped reactions with counts.

Purpose: Establish the data layer that all frontend reaction components will consume via Convex's reactive queries.
Output: Working messageReactions table, toggle mutation, and listForMessage aggregation query.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-emoji-reactions-foundation/08-RESEARCH.md
@convex/schema.ts
@convex/messages.ts
@convex/users.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add messageReactions table to Convex schema</name>
  <files>convex/schema.ts</files>
  <action>
Add a `messageReactions` table to the Convex schema in `convex/schema.ts`.

Fields:
- `messageId: v.id("messages")` ‚Äî the message being reacted to
- `userId: v.id("users")` ‚Äî who reacted
- `emoji: v.string()` ‚Äî unified emoji code (e.g., "1f44d")
- `emojiNative: v.string()` ‚Äî rendered emoji character (e.g., "üëç")

Indexes (all using `withIndex()` convention, never `filter()`):
- `by_message` ‚Üí `["messageId"]` ‚Äî fetch all reactions for a message
- `by_message_emoji_user` ‚Üí `["messageId", "emoji", "userId"]` ‚Äî uniqueness check for toggle idempotency

Place the table definition after the `messages` table block in the schema file. Follow the exact pattern used by other tables (e.g., `taskComments`).
  </action>
  <verify>Run `npx convex dev --once` or `npm run lint` to confirm schema is valid TypeScript with no errors.</verify>
  <done>messageReactions table exists in schema.ts with messageId, userId, emoji, emojiNative fields and two indexes (by_message, by_message_emoji_user).</done>
</task>

<task type="auto">
  <name>Task 2: Create messageReactions.ts with toggle mutation and listForMessage query</name>
  <files>convex/messageReactions.ts</files>
  <action>
Create `convex/messageReactions.ts` with two functions:

**1. `toggle` mutation:**
- Args: `{ messageId: v.id("messages"), emoji: v.string(), emojiNative: v.string() }`
- Returns: `v.null()`
- Handler:
  1. Get authenticated userId via `getAuthUserId(ctx)`, throw ConvexError if not authenticated
  2. Query `messageReactions` with `by_message_emoji_user` index matching `(messageId, emoji, userId)` using `.unique()`
  3. If exists ‚Üí `ctx.db.delete(existing._id)` (remove reaction)
  4. If not exists ‚Üí `ctx.db.insert("messageReactions", { messageId, userId, emoji, emojiNative })` (add reaction)
  5. Return null

**2. `listForMessage` query:**
- Args: `{ messageId: v.id("messages") }`
- Returns: `v.any()` (complex enriched return type ‚Äî use v.any() per project convention for enriched returns)
- Handler:
  1. Get authenticated userId, throw if not authenticated
  2. Fetch all reactions for messageId using `by_message` index with `.collect()`
  3. Group by `emoji` using `reduce()` to build `{ emoji, emojiNative, count, userIds[] }` per unique emoji
  4. Convert grouped result to array, add `currentUserReacted: boolean` by checking if `userId` is in `userIds`
  5. Return the array

Import pattern (follow existing convention in messages.ts):
```typescript
import { getAuthUserId } from "@convex-dev/auth/server";
import { ConvexError, v } from "convex/values";
import { mutation, query } from "./_generated/server";
```

Do NOT use `filter()` ‚Äî always use `withIndex()`.
  </action>
  <verify>Run `npm run lint` ‚Äî should pass with zero warnings. Run `npx convex dev --once` to confirm functions deploy without errors.</verify>
  <done>toggle mutation idempotently adds/removes reactions. listForMessage query returns array of `{ emoji, emojiNative, count, userIds, currentUserReacted }` grouped by emoji.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. Schema has messageReactions table with correct fields and indexes
3. messageReactions.ts exports toggle (mutation) and listForMessage (query)
4. toggle uses by_message_emoji_user index for idempotent add/remove
5. listForMessage uses by_message index and JavaScript aggregation
</verification>

<success_criteria>
- messageReactions table deployed to Convex with compound indexes
- toggle mutation handles add/remove idempotently (no race condition duplicates)
- listForMessage query returns aggregated reaction data suitable for frontend consumption
- All code follows project conventions (withIndex, ConvexError, getAuthUserId pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/08-emoji-reactions-foundation/08-01-SUMMARY.md`
</output>
