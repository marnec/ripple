# Phase 13.1: Fix Deployment Pipeline and Environment Configuration - Research

**Researched:** 2026-02-12
**Domain:** Multi-service deployment orchestration (Convex + PartyKit + Cloudflare Workers)
**Confidence:** HIGH

## Summary

This phase addresses critical deployment infrastructure gaps in a three-service architecture: Convex backend (serverless database/functions), PartyKit (WebSocket collaboration server), and Cloudflare Workers (React SPA frontend). The current deployment is manual with no CI/CD pipeline, missing environment variable documentation, and incomplete production configuration. Research reveals that each platform has distinct deployment mechanisms, secret management approaches, and configuration requirements that must be orchestrated cohesively.

**Key findings:** PartyKit requires production environment variables to be set via CLI (`npx partykit env add`) and deployed separately from local .env files. Vite build-time environment variables (VITE_ prefix) must be available during build phase, not runtime. GitHub Actions can orchestrate multi-service deployments with job dependencies (`needs:` keyword) and environment protection rules for production approval gates. Each platform uses different secret management: Convex uses per-deployment env vars via CLI/dashboard, PartyKit uses CLI-managed secrets or `--with-vars` flag, and Cloudflare Workers uses `.dev.vars` files and `wrangler secret` commands.

**Primary recommendation:** Create a comprehensive GitHub Actions workflow with three separate deployment jobs (Convex, PartyKit, frontend) that run sequentially with shared environment variables managed via GitHub Actions secrets. Document all required environment variables in `.env.example` with clear comments about where each variable is used (build-time vs runtime, which service needs it). Implement environment protection rules for production deployments with required approvals.

## Standard Stack

### Core Deployment Platforms

| Platform | Version | Purpose | Configuration File |
|----------|---------|---------|-------------------|
| Convex | 1.31.7 (current) | Serverless backend, database, HTTP endpoints | None (CLI-configured) |
| PartyKit | 0.0.115 (current) | WebSocket collaboration server (Yjs) | partykit.json |
| Cloudflare Workers | Wrangler 4.63.0 | React SPA hosting via Workers Assets | wrangler.jsonc |

### CI/CD Platform

| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| GitHub Actions | Latest | CI/CD orchestration, multi-service deployment | Native GitHub integration, environment secrets, job dependencies, deployment protection rules |

### Supporting Tools

| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| Vite | 7.3.1 | Frontend build, env var injection | Build-time VITE_ variables for frontend |
| npm-run-all | 4.1.5 | Parallel script execution | Local development only (not for CI/CD) |

### Environment Variable Management

**Convex:**
- CLI: `npx convex env set KEY value`
- Dashboard: Deployment Settings > Environment Variables
- Max 100 vars per deployment, 40 char names, 8KB values
- Access via `process.env.KEY`

**PartyKit:**
- CLI: `npx partykit env add KEY` (prompts for value)
- Deploy with vars: `npx partykit deploy --with-vars` (uses .env file)
- Direct flags: `npx partykit deploy --var KEY=value`
- Access via `room.env.KEY`

**Cloudflare Workers:**
- Development: `.dev.vars` file (gitignored, dotenv format)
- Production: `npx wrangler secret put KEY` or wrangler.jsonc `[vars]` section
- Plain-text vars in wrangler.jsonc, secrets via CLI
- Environment-specific: `.dev.vars.<env-name>` or `[env.staging]` blocks

**Vite (Frontend Build-Time):**
- `.env.local` (development, gitignored)
- `.env.production` (production build-time values)
- Only `VITE_` prefixed vars exposed to client code
- Statically replaced during `vite build` (not runtime-injectable)

**Installation:**
```bash
# Already installed in project
# For new GitHub Actions setup:
# - No additional dependencies needed
# - Use GitHub CLI in Actions: actions/checkout, actions/setup-node
```

## Architecture Patterns

### Multi-Service Deployment Orchestration

**Pattern: Sequential Deployment with Shared Secrets**

Three independent deployment targets require coordinated rollout with environment-aware configuration.

**Deployment Order (Critical):**
1. Convex backend (provides API endpoints)
2. PartyKit server (depends on Convex SITE_URL for auth verification)
3. Frontend (depends on both Convex and PartyKit URLs)

**Rationale:** Backend services must be deployed and healthy before frontend references their URLs in build-time environment variables.

```yaml
# GitHub Actions pattern
jobs:
  deploy-convex:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npx convex env set SENDGRID_API_KEY ${{ secrets.SENDGRID_API_KEY }}
      - run: npx convex deploy
        env:
          CONVEX_DEPLOY_KEY: ${{ secrets.CONVEX_DEPLOY_KEY }}

  deploy-partykit:
    needs: deploy-convex
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npx partykit deploy --var CONVEX_SITE_URL=${{ secrets.CONVEX_SITE_URL }}
        env:
          PARTYKIT_TOKEN: ${{ secrets.PARTYKIT_TOKEN }}

  deploy-frontend:
    needs: [deploy-convex, deploy-partykit]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npm run build
        env:
          VITE_CONVEX_URL: ${{ secrets.VITE_CONVEX_URL }}
          VITE_CONVEX_SITE_URL: ${{ secrets.VITE_CONVEX_SITE_URL }}
          VITE_PARTYKIT_HOST: ${{ secrets.VITE_PARTYKIT_HOST }}
      - run: npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

### Environment Variable Scoping

**Pattern: Service-Specific Variable Namespacing**

Different services require different subsets of environment variables at different lifecycle stages.

```
# Build-Time (Frontend Only)
VITE_CONVEX_URL          → Injected into bundle during vite build
VITE_CONVEX_SITE_URL     → Injected into bundle during vite build
VITE_PARTYKIT_HOST       → Injected into bundle during vite build

# Runtime (Convex Backend)
SENDGRID_API_KEY         → Accessed via process.env in Convex functions
CONVEX_CLOUD_URL         → Auto-provided by Convex
CONVEX_SITE_URL          → Auto-provided by Convex

# Runtime (PartyKit Server)
CONVEX_SITE_URL          → Accessed via room.env in PartyKit server

# CI/CD Only
CONVEX_DEPLOY_KEY        → Non-interactive Convex deployment
PARTYKIT_TOKEN           → PartyKit CLI authentication
CLOUDFLARE_API_TOKEN     → Wrangler deployment authentication
```

**Critical Rule:** Vite VITE_ variables are build-time only. Changing them post-build has no effect. They must be set during `npm run build` in CI/CD.

### Environment Protection Rules

**Pattern: Production Approval Gate**

GitHub Actions environments enable deployment protection with required approvals, wait timers, and branch restrictions.

**Configuration:**
1. Create `production` environment in GitHub repo settings
2. Add required reviewers (1-6 people)
3. Configure deployment branches (allow only `main`)
4. Set environment secrets (isolated from development)
5. Optional: Add wait timer (e.g., 5 minutes post-approval)

**Benefits:**
- Prevents accidental production deployments
- Audit trail of who approved deployments
- Environment-specific secrets (prod vs staging)
- Jobs cannot access environment secrets until approved

**Job Reference:**
```yaml
jobs:
  deploy-production:
    environment: production  # Triggers approval gate
    runs-on: ubuntu-latest
```

### Health Check and Verification

**Pattern: Post-Deployment Smoke Tests**

After each service deployment, verify critical functionality before proceeding.

**Recommended Checks:**

**Convex (Post-Deploy):**
```bash
# Check deployment status
curl -f https://$CONVEX_CLOUD_URL/_system/query?format=convex_json \
  -H "Content-Type: application/json" \
  -d '{"path":"users.viewer","args":{},"format":"json"}'
```

**PartyKit (Post-Deploy):**
```bash
# Check WebSocket endpoint is reachable
curl -f -I https://$PARTYKIT_HOST
```

**Frontend (Post-Deploy):**
```bash
# Check SPA is serving
curl -f -I https://ripple.conduits.space
```

**Advanced Pattern:** Create dedicated health check endpoints:
- Convex: Add HTTP route `/health` that returns 200 OK
- PartyKit: Already has `:port/health` for webhook event sources (not applicable here)
- Frontend: Cloudflare Workers automatically serves assets with 200 OK

### .env.example Template Structure

**Pattern: Comprehensive Developer Documentation**

Create `.env.example` with all variables, clear comments, and example values.

```bash
# =============================================================================
# Convex Backend Configuration
# =============================================================================
# Development deployment identifier (auto-set by `npx convex dev`)
CONVEX_DEPLOYMENT=dev:your-deployment-name

# Convex backend API URL (public, used by frontend)
# Dev: Auto-generated by Convex dev
# Prod: Set in GitHub Actions from production deployment URL
VITE_CONVEX_URL=https://your-deployment.convex.cloud

# Convex HTTP actions URL (public, used by PartyKit for auth verification)
# Dev: Auto-generated by Convex dev
# Prod: Set in GitHub Actions from production deployment URL
VITE_CONVEX_SITE_URL=https://your-deployment.convex.site
CONVEX_SITE_URL=https://your-deployment.convex.site

# =============================================================================
# PartyKit Collaboration Server
# =============================================================================
# PartyKit WebSocket host (public, used by frontend)
# Dev: localhost:1999 (local PartyKit dev server)
# Prod: your-project.your-username.partykit.dev
VITE_PARTYKIT_HOST=localhost:1999

# =============================================================================
# Cloudflare Workers (Frontend Hosting)
# =============================================================================
# No additional environment variables required for deployment
# Domain configured in wrangler.jsonc

# =============================================================================
# Development Setup Flag (Internal)
# =============================================================================
# Set by setup.mjs to prevent duplicate setup runs
SETUP_SCRIPT_RAN=1

# =============================================================================
# CI/CD Secrets (GitHub Actions only - DO NOT SET LOCALLY)
# =============================================================================
# CONVEX_DEPLOY_KEY        - Convex production deploy key
# PARTYKIT_TOKEN           - PartyKit CLI authentication
# CLOUDFLARE_API_TOKEN     - Cloudflare Workers deployment
# SENDGRID_API_KEY         - Email service (set via convex env set)
```

**Key Principles:**
- Mark required vs optional
- Indicate dev vs prod vs CI/CD only
- Provide example values or generation commands
- Group by service/purpose with clear headers
- Warn against committing real values

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Service deployment orchestration | Custom shell scripts with hardcoded order | GitHub Actions with `needs:` dependencies | Built-in job ordering, retry logic, parallel execution where safe, environment protection, secrets management, audit logging |
| Secret rotation and management | Manual .env file updates across services | Platform-native secret management (Convex CLI, PartyKit CLI, GitHub Actions secrets) | Per-deployment isolation, no git commits, encrypted at rest, audit trails, revocable tokens |
| Deployment health checks | Custom polling scripts | Platform health endpoints + GitHub Actions step conditionals | Native platform support (Cloudflare has built-in health, Convex has _system endpoints), fail-fast on errors, automatic rollback triggers |
| Environment variable validation | Runtime checks that fail after deployment | CI/CD pre-flight checks + .env.example validation | Catch missing vars before deployment, clear error messages, development parity checks |
| Rollback mechanism | Manual reversion of each service | Git-based rollback with GitHub Actions rerun | Atomic reversion to known-good state, preserves deployment order, automatic via workflow_dispatch |

**Key Insight:** Each platform (Convex, PartyKit, Cloudflare) already provides deployment CLI tools with authentication, error handling, and progress feedback. The orchestration layer (GitHub Actions) should coordinate these tools, not replace them. Custom deployment scripts introduce maintenance burden, lack platform-specific optimizations, and miss features like Convex's automatic schema validation or PartyKit's zero-downtime deployments.

## Common Pitfalls

### Pitfall 1: Vite Environment Variables as Runtime Configuration

**What goes wrong:** Deploying frontend without required VITE_ variables set during build, then trying to inject them post-deployment or expecting them to be runtime-configurable.

**Why it happens:** Misunderstanding Vite's static replacement mechanism. Developers familiar with traditional server-rendered apps expect environment variables to be runtime-injectable.

**How to avoid:**
- Always set VITE_ prefixed variables in the `npm run build` step of CI/CD
- Never deploy a frontend build without verifying VITE_ vars are correct for target environment
- Document clearly in .env.example that VITE_ vars are build-time only
- For multi-environment deployments, create separate build jobs per environment

**Warning signs:**
- `import.meta.env.VITE_CONVEX_URL` returning `undefined` in deployed app
- Console errors: "Cannot read property of undefined" when accessing Convex client
- Frontend trying to connect to `localhost:1999` in production (default fallback)

### Pitfall 2: PartyKit Production Without CONVEX_SITE_URL

**What goes wrong:** PartyKit server deploys successfully but all WebSocket connections fail with 401/403 errors because auth verification cannot reach Convex.

**Why it happens:** PartyKit server requires `CONVEX_SITE_URL` environment variable at runtime to call Convex's `/collaboration/verify` endpoint. Without it, authentication fails silently in production (works in dev because .env.local exists locally).

**How to avoid:**
- Set `CONVEX_SITE_URL` via `npx partykit env add` in production PartyKit deployment
- OR use `npx partykit deploy --var CONVEX_SITE_URL=$PROD_URL` in CI/CD
- Verify with post-deployment test: attempt WebSocket connection and check server logs
- Add health check that validates `room.env.CONVEX_SITE_URL` is set on startup

**Warning signs:**
- PartyKit deploy succeeds but WebSocket connections immediately close
- Server logs show "CONVEX_SITE_URL not configured" error
- Frontend shows "Failed to connect to collaboration server" indefinitely
- Network tab shows WebSocket 1011 error (Server configuration error)

### Pitfall 3: Deployment Order Dependency Violations

**What goes wrong:** Frontend deployed before backend, resulting in outdated API URLs baked into bundle, or PartyKit deployed before Convex, causing auth verification to fail against non-existent endpoint.

**Why it happens:** Parallel execution optimization without considering service dependencies, or manual deployment in wrong order.

**How to avoid:**
- Use GitHub Actions `needs:` keyword to enforce strict sequential order
- Document dependency graph clearly in deployment workflow comments
- Never deploy frontend until BOTH Convex and PartyKit are confirmed healthy
- Consider atomic deployment flag: only update DNS/routes after all services are deployed

**Warning signs:**
- Frontend shows "Network error" or "Failed to fetch" on load
- Frontend connects to stale/previous Convex deployment
- Rollback requires redeploying in reverse order
- Partial deployment leaves system in inconsistent state

### Pitfall 4: Secrets in wrangler.jsonc or partykit.json

**What goes wrong:** Sensitive values (API keys, tokens) committed to git in configuration files, exposing secrets to anyone with repo access.

**Why it happens:** Confusion between plain-text environment variables (safe for non-sensitive config like URLs) and secrets (must be encrypted). wrangler.jsonc `[vars]` section is for public configuration only.

**How to avoid:**
- NEVER put sensitive data in wrangler.jsonc `[vars]`
- Use `npx wrangler secret put` for secrets in Cloudflare Workers
- Use `npx partykit env add` for secrets in PartyKit (not partykit.json)
- Use `npx convex env set` for secrets in Convex (not committed anywhere)
- Mark secrets clearly in .env.example with "DO NOT COMMIT" warnings
- Add `.env*` to .gitignore (already present in this project)

**Warning signs:**
- Git history shows commits with API keys or tokens
- Secret scanning tools (GitHub, Snyk) flag security issues
- Accidental secret exposure in public forks or PR diffs

### Pitfall 5: Missing Production PartyKit Host URL in Frontend

**What goes wrong:** Frontend deployed with `VITE_PARTYKIT_HOST=localhost:1999` baked into bundle, causing all production users' browsers to attempt WebSocket connections to localhost.

**Why it happens:** Forgetting to override development default during production build, or not knowing PartyKit's production URL pattern (`project-name.username.partykit.dev`).

**How to avoid:**
- Document PartyKit production URL pattern in .env.example
- Add validation step in CI/CD: check VITE_PARTYKIT_HOST does not contain "localhost" before production build
- Set explicit VITE_PARTYKIT_HOST value in GitHub Actions production workflow
- Test production build locally with production env vars before deploying

**Warning signs:**
- Collaboration features work in dev, fail in production
- Browser console shows WebSocket connection to localhost in production
- No WebSocket connections visible in PartyKit logs/dashboard

### Pitfall 6: GitHub Actions Concurrency for Same Environment

**What goes wrong:** Two deployments to production trigger simultaneously (e.g., quick successive pushes to main), causing race conditions where services are in inconsistent states or deployments overwrite each other mid-execution.

**Why it happens:** GitHub Actions runs workflows in parallel by default unless concurrency controls are configured.

**How to avoid:**
- Add concurrency group at workflow level:
  ```yaml
  concurrency:
    group: production-deployment
    cancel-in-progress: false  # Queue deployments, don't cancel
  ```
- Use `cancel-in-progress: true` for staging/preview (safe to cancel)
- Use `cancel-in-progress: false` for production (finish in-progress deploys)

**Warning signs:**
- Deployment logs show overlapping timestamps for same environment
- Service versions mismatch (frontend references old Convex deployment)
- Race condition errors in deployment logs

### Pitfall 7: No .env.example Leads to Setup Friction

**What goes wrong:** New developers cannot set up project because required environment variables are undocumented, leading to cryptic runtime errors.

**Why it happens:** Original developers have working .env.local and forget to document it. .env files are gitignored (correctly) but no template exists.

**How to avoid:**
- Create comprehensive .env.example immediately (this phase)
- Add setup verification step: check required vars exist before running dev
- Document generation commands for auto-populated values (e.g., Convex dev creates CONVEX_DEPLOYMENT)
- Add .env.example to onboarding documentation

**Warning signs:**
- New contributors report "undefined environment variable" errors
- Slack/Discord questions about "how do I configure X"
- Multiple issues filed about missing configuration
- README has no environment setup section

## Code Examples

All examples verified from official documentation and current project codebase.

### GitHub Actions Multi-Service Deployment

Complete workflow with sequential deployment, environment protection, and health checks.

```yaml
# .github/workflows/deploy-production.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:  # Manual trigger option

# Prevent concurrent production deployments
concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  # Job 1: Deploy Convex Backend
  deploy-convex:
    name: Deploy Convex Backend
    runs-on: ubuntu-latest
    environment: production  # Requires approval
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set Convex environment variables
        run: |
          npx convex env set SENDGRID_API_KEY "${{ secrets.SENDGRID_API_KEY }}"
        env:
          CONVEX_DEPLOY_KEY: ${{ secrets.CONVEX_DEPLOY_KEY }}

      - name: Deploy Convex
        run: npx convex deploy --cmd 'npm run build'
        env:
          CONVEX_DEPLOY_KEY: ${{ secrets.CONVEX_DEPLOY_KEY }}

      - name: Health check Convex
        run: |
          curl -f "${{ secrets.VITE_CONVEX_URL }}" || exit 1

  # Job 2: Deploy PartyKit Server (depends on Convex)
  deploy-partykit:
    name: Deploy PartyKit Server
    runs-on: ubuntu-latest
    needs: deploy-convex
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Deploy PartyKit
        run: npx partykit deploy --var CONVEX_SITE_URL="${{ secrets.CONVEX_SITE_URL }}"
        env:
          PARTYKIT_TOKEN: ${{ secrets.PARTYKIT_TOKEN }}

      - name: Health check PartyKit
        run: |
          curl -f -I "https://${{ secrets.VITE_PARTYKIT_HOST }}" || exit 1

  # Job 3: Deploy Frontend (depends on both Convex and PartyKit)
  deploy-frontend:
    name: Deploy Frontend to Cloudflare
    runs-on: ubuntu-latest
    needs: [deploy-convex, deploy-partykit]
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build frontend
        run: npm run build
        env:
          VITE_CONVEX_URL: ${{ secrets.VITE_CONVEX_URL }}
          VITE_CONVEX_SITE_URL: ${{ secrets.VITE_CONVEX_SITE_URL }}
          VITE_PARTYKIT_HOST: ${{ secrets.VITE_PARTYKIT_HOST }}

      - name: Validate build contains environment variables
        run: |
          if ! grep -r "${{ secrets.VITE_CONVEX_URL }}" dist/; then
            echo "Error: VITE_CONVEX_URL not found in build output"
            exit 1
          fi

      - name: Deploy to Cloudflare Workers
        run: npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Health check frontend
        run: |
          curl -f -I "https://ripple.conduits.space" || exit 1
```

**Source:** GitHub Actions official docs + project requirements

### Manual Deployment with Environment Isolation

Script for manual deployment with proper environment variable management.

```bash
#!/bin/bash
# scripts/deploy-manual.sh
# Manual deployment script with environment prompts

set -e  # Exit on error

ENVIRONMENT="${1:-production}"

echo "====================================="
echo "Manual Deployment to $ENVIRONMENT"
echo "====================================="

# Validate environment
if [[ "$ENVIRONMENT" != "production" && "$ENVIRONMENT" != "staging" ]]; then
  echo "Error: Environment must be 'production' or 'staging'"
  exit 1
fi

# Load environment-specific variables
if [ -f ".env.$ENVIRONMENT" ]; then
  source ".env.$ENVIRONMENT"
else
  echo "Error: .env.$ENVIRONMENT not found"
  exit 1
fi

# Validate required variables
REQUIRED_VARS=(
  "VITE_CONVEX_URL"
  "VITE_CONVEX_SITE_URL"
  "CONVEX_SITE_URL"
  "VITE_PARTYKIT_HOST"
)

for var in "${REQUIRED_VARS[@]}"; do
  if [ -z "${!var}" ]; then
    echo "Error: $var is not set in .env.$ENVIRONMENT"
    exit 1
  fi
done

echo "✓ Environment variables validated"

# Step 1: Deploy Convex
echo ""
echo "Step 1/3: Deploying Convex backend..."
npx convex deploy --cmd 'npm run build'
echo "✓ Convex deployed"

# Step 2: Deploy PartyKit
echo ""
echo "Step 2/3: Deploying PartyKit server..."
npx partykit deploy --var CONVEX_SITE_URL="$CONVEX_SITE_URL"
echo "✓ PartyKit deployed"

# Step 3: Build and deploy frontend
echo ""
echo "Step 3/3: Building and deploying frontend..."
npm run build
npx wrangler deploy
echo "✓ Frontend deployed"

echo ""
echo "====================================="
echo "Deployment to $ENVIRONMENT complete!"
echo "====================================="
```

**Source:** Project deployment requirements + manual deployment best practices

### Convex Environment Variable Access Pattern

How to safely access environment variables in Convex functions.

```typescript
// convex/email.ts
// Source: Convex documentation + project collaboration.ts pattern
import { action } from "./_generated/server";
import { v } from "convex/values";

export const sendWelcomeEmail = action({
  args: {
    email: v.string(),
    name: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, { email, name }) => {
    // Access environment variable with fallback
    const sendgridApiKey = process.env.SENDGRID_API_KEY;

    if (!sendgridApiKey) {
      console.error("SENDGRID_API_KEY not configured");
      throw new Error("Email service not configured");
    }

    // Use API key for external service call
    const response = await fetch("https://api.sendgrid.com/v3/mail/send", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${sendgridApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        personalizations: [{ to: [{ email }] }],
        from: { email: "noreply@ripple.app" },
        subject: "Welcome to Ripple",
        content: [{ type: "text/plain", value: `Hi ${name}, welcome!` }],
      }),
    });

    if (!response.ok) {
      throw new Error(`SendGrid API error: ${response.statusText}`);
    }

    return null;
  },
});
```

**Key Pattern:** Always check for `undefined` and provide clear error messages. Environment variables in Convex are per-deployment, not per-function-call.

### PartyKit Server Environment Variable Access

How PartyKit server accesses environment variables at runtime.

```typescript
// partykit/server.ts
// Source: Current project implementation
import type * as Party from "partykit/server";
import { onConnect } from "y-partykit";

export default class CollaborationServer implements Party.Server {
  constructor(readonly room: Party.Room) {}

  async onConnect(conn: Party.Connection, ctx: Party.ConnectionContext) {
    const url = new URL(ctx.request.url);
    const token = url.searchParams.get("token");

    if (!token) {
      conn.close(1008, "Missing auth token");
      return;
    }

    // Access environment variable via room.env
    // CRITICAL: This must be set via partykit env add or --var flag
    const convexSiteUrl = this.room.env.CONVEX_SITE_URL as string;

    if (!convexSiteUrl) {
      console.error("CONVEX_SITE_URL not configured");
      conn.close(1011, "Server configuration error");
      return;
    }

    try {
      // Use environment variable to construct Convex API URL
      const response = await fetch(`${convexSiteUrl}/collaboration/verify`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({ roomId: this.room.id }),
      });

      if (!response.ok) {
        conn.close(1008, "Unauthorized");
        return;
      }

      const userData = await response.json();
      console.log(`User ${userData.userName} connected to room ${this.room.id}`);

      return onConnect(conn, this.room, {
        persist: { mode: "snapshot" },
      });
    } catch (error) {
      console.error("Auth verification error:", error);
      conn.close(1011, "Auth verification failed");
    }
  }
}
```

**Key Pattern:** Check for environment variable presence and fail gracefully with clear WebSocket close codes. Use `this.room.env.VAR_NAME` to access PartyKit environment variables.

### Frontend Environment Variable Usage Pattern

How to access Vite build-time environment variables in React code.

```typescript
// src/hooks/use-yjs-provider.ts
// Source: Current project implementation
import { useAction } from "convex/react";
import { useEffect, useMemo, useRef, useState } from "react";
import YPartyKitProvider from "y-partykit/provider";
import * as Y from "yjs";
import { api } from "../../convex/_generated/api";

export function useYjsProvider(opts: {
  resourceType: "doc" | "diagram";
  resourceId: string;
  enabled?: boolean;
}) {
  const { resourceType, resourceId, enabled = true } = opts;
  const getToken = useAction(api.collaboration.getCollaborationToken);
  const [provider, setProvider] = useState<YPartyKitProvider | null>(null);

  const yDoc = useMemo(() => new Y.Doc(), []);

  useEffect(() => {
    if (!enabled) return;

    let cancelled = false;

    const connect = async () => {
      try {
        const { token, roomId } = await getToken({ resourceType, resourceId });
        if (cancelled) return;

        // Access Vite environment variable with fallback
        // CRITICAL: This value is baked in at build time
        const host = import.meta.env.VITE_PARTYKIT_HOST || "localhost:1999";

        const newProvider = new YPartyKitProvider(host, roomId, yDoc, {
          connect: true,
          params: { token },
        });

        if (cancelled) {
          newProvider.destroy();
          return;
        }

        setProvider(newProvider);

        newProvider.on("sync", (synced: boolean) => {
          if (!cancelled) {
            console.log("Yjs sync status:", synced);
          }
        });
      } catch (err) {
        console.error("Failed to connect to collaboration server:", err);
      }
    };

    void connect();

    return () => {
      cancelled = true;
      provider?.destroy();
    };
  }, [resourceType, resourceId, enabled, yDoc]);

  return { yDoc, provider };
}
```

**Key Pattern:** Use `import.meta.env.VITE_VAR_NAME` to access build-time variables. Always provide development fallback. Value is statically replaced during build, not runtime-configurable.

### Validating VITE_ Variables in CI/CD

Pre-deployment validation to catch missing environment variables.

```yaml
# .github/workflows/validate-env.yml
# Source: Deployment best practices
name: Validate Environment Configuration

on:
  pull_request:
    branches: [main]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check .env.example exists and is up to date
        run: |
          if [ ! -f ".env.example" ]; then
            echo "Error: .env.example not found"
            exit 1
          fi

          # Extract VITE_ variables from source code
          USED_VARS=$(grep -rho "import\.meta\.env\.VITE_[A-Z_]*" src/ | sort -u | sed 's/import\.meta\.env\.//')

          # Check each is documented in .env.example
          for var in $USED_VARS; do
            if ! grep -q "^$var=" .env.example; then
              echo "Error: $var used in code but not documented in .env.example"
              exit 1
            fi
          done

          echo "✓ All VITE_ variables documented in .env.example"

      - name: Validate no secrets in committed files
        run: |
          # Check for common secret patterns
          if grep -r "sk-" --include="*.ts" --include="*.js" --include="*.json" .; then
            echo "Error: Possible API key found in committed files"
            exit 1
          fi

          if grep -r "CONVEX_DEPLOY_KEY" --include="*.ts" --include="*.js" .; then
            echo "Error: Deploy key found in committed code"
            exit 1
          fi

          echo "✓ No secrets found in committed files"
```

**Source:** GitHub Actions security best practices + Vite environment variable patterns

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual deployment scripts per service | GitHub Actions workflow with job dependencies | 2024-2026 | Standardized on workflow_dispatch for manual triggers, needs: keyword for ordering (stable since 2020) |
| Runtime environment variable injection | Build-time static replacement (Vite) | Vite 2.0+ (2021) | Improved security (no runtime variable leakage), better tree-shaking, but requires rebuild per environment |
| Single .env file for all environments | Environment-specific .env files (.env.production, .env.staging) | Vite 2.0+ (2021) | Clearer environment separation, reduces accidental production variable usage in dev |
| wrangler.toml (TOML format) | wrangler.jsonc (JSON with comments) | Wrangler 3.0+ (2023) | JSON schema validation, better IDE support, "Cloudflare recommends using wrangler.jsonc for new projects" |
| PartyKit vars in partykit.json | CLI-managed secrets via partykit env add | PartyKit 0.0.x (2023-2024) | Removed secret exposure in git, per-deployment secret management |
| GitHub Actions environment secrets without protection | Environment protection rules with required approvers | GitHub Actions 2021+ | Production deployment safety, approval audit trail, wait timers for gradual rollouts |
| Separate deployment for Convex via dashboard | Convex CLI deploy with CONVEX_DEPLOY_KEY | Convex 1.0+ (2023) | Non-interactive CI/CD deployments, automatic schema migrations |

**Deprecated/outdated:**

- **PartyKit `vars` in partykit.json**: Deprecated in favor of CLI-managed environment variables via `npx partykit env add` or `--var` flags. The `vars` field in partykit.json is no longer recommended per official documentation.

- **Wrangler 2.x commands**: Several commands changed in Wrangler 3.x. Use `wrangler deploy` instead of `wrangler publish`. Use `.dev.vars` instead of `wrangler secret:bulk` for development secrets.

- **Convex dashboard-only deployments**: While still supported, Convex now recommends CLI-based deployments for production via deploy keys for better automation and schema migration handling.

- **GitHub Actions `ubuntu-18.04` runner**: Deprecated as of October 2022. Use `ubuntu-latest` or `ubuntu-22.04`.

- **Manual secret management via .env files in production**: Industry standard now uses platform-native secret stores (GitHub Actions secrets, Cloudflare Workers secrets, Convex env vars) instead of deploying .env files to servers.

## Open Questions

### 1. PartyKit Production Host URL Determination

**What we know:** PartyKit deploys to `project-name.username.partykit.dev` format. The project name comes from `partykit.json` `name` field ("ripple-collaboration"). Username is GitHub username of authenticated user.

**What's unclear:** Exact production URL until first deployment. Does `npx partykit deploy` output the final URL? Can we query it programmatically after deployment?

**Recommendation:**
- Perform initial manual PartyKit deployment to determine exact production URL
- Document URL in .env.example and GitHub Actions secrets
- Add comment in CI/CD workflow: "Update VITE_PARTYKIT_HOST if PartyKit project name changes"
- LOW RISK: PartyKit project name rarely changes, URL stable after first deployment

### 2. Rollback Strategy for Multi-Service Deployments

**What we know:** Each service can be rolled back independently via redeployment of previous version. GitHub Actions allows manual workflow_dispatch with git ref selection. Service dependencies mean rollback order matters (reverse of deployment order).

**What's unclear:** Best practice for coordinated rollback when frontend requires specific backend versions. Should we tag releases atomically? Create rollback-specific workflow? Maintain version compatibility matrix?

**Recommendation:**
- Create separate GitHub Actions workflow: `rollback-production.yml`
- Accept git tag/commit as input via workflow_dispatch
- Deploy services in reverse order (frontend, PartyKit, Convex)
- For now, rollback is manual via rerun of deployment workflow on previous commit
- MEDIUM RISK: Partial rollbacks could leave services incompatible
- Future enhancement: Version compatibility checking in deployment workflow

### 3. Staging Environment Provisioning

**What we know:** All three platforms support multiple environments. Convex has dev/prod deployments. PartyKit supports `--preview` flag for preview deployments. Cloudflare Workers supports environment-specific wrangler.jsonc config via `[env.staging]` blocks.

**What's unclear:** Whether user wants full staging environment with separate database, separate Convex deployment, separate PartyKit instance. Cost implications of running duplicate infrastructure.

**Recommendation:**
- Start with production-only deployment (this phase scope)
- Document staging setup in deployment workflow comments for future
- Staging would require:
  - Separate Convex deployment (free for additional dev deployments)
  - Separate PartyKit preview deployment (`--preview staging`)
  - Separate Cloudflare Workers route or custom domain
- LOW PRIORITY: Production deployment more critical than staging initially

### 4. Deployment Notification and Observability

**What we know:** GitHub Actions supports webhook notifications, Slack integration, and custom action outputs. Each platform has deployment logs (Convex dashboard, PartyKit logs via `npx partykit tail`, Cloudflare Workers logs).

**What's unclear:** User preference for deployment notifications (Slack, Discord, email?) and whether to implement uptime monitoring or error tracking (Sentry, Datadog, etc.).

**Recommendation:**
- Add basic deployment notification: GitHub Actions job summary (built-in, free)
- Post-deployment, add step to post summary to GitHub Actions summary:
  ```yaml
  - name: Deployment summary
    run: |
      echo "✓ Convex deployed to ${{ secrets.VITE_CONVEX_URL }}" >> $GITHUB_STEP_SUMMARY
      echo "✓ PartyKit deployed to ${{ secrets.VITE_PARTYKIT_HOST }}" >> $GITHUB_STEP_SUMMARY
      echo "✓ Frontend deployed to https://ripple.conduits.space" >> $GITHUB_STEP_SUMMARY
  ```
- Future enhancement: Webhook to Slack/Discord if user requests
- LOW COMPLEXITY: GitHub Actions summary sufficient for MVP

### 5. Database Migration Coordination with Deployments

**What we know:** Convex handles schema migrations automatically during `npx convex deploy`. The `--cmd` flag runs a command after schema push (typically `npm run build` to regenerate types). Convex deployments are atomic at the schema level.

**What's unclear:** How to handle breaking schema changes that require multi-step deployments (e.g., renaming a field requires deploy-with-both-fields, migrate-data, deploy-removing-old-field pattern).

**Recommendation:**
- Convex migration system handles most cases automatically
- For breaking changes requiring coordination:
  - Use `@convex-dev/migrations` library (already installed in project)
  - Document breaking migration process in deployment workflow
  - Add workflow_dispatch input for "migration mode" that pauses between steps
- LOW RISK: Convex schema evolution is designed to minimize breaking changes
- Most schema updates are additive and handled automatically

## Sources

### Primary (HIGH confidence)

- [PartyKit Environment Variables Management](https://docs.partykit.io/guides/managing-environment-variables/) - Official PartyKit docs on CLI secrets management
- [PartyKit Configuration (partykit.json)](https://docs.partykit.io/reference/partykit-configuration/) - Official config file structure
- [PartyKit Deployment Guide](https://docs.partykit.io/guides/deploying-your-partykit-server/) - Production deployment process
- [Cloudflare Wrangler Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/) - Complete wrangler.jsonc reference
- [Convex Environment Variables](https://docs.convex.dev/production/environment-variables) - CLI and dashboard env var management
- [Convex Project Configuration](https://docs.convex.dev/production/project-configuration) - Production deployment setup
- [Vite Environment Variables and Modes](https://vite.dev/guide/env-and-mode) - VITE_ prefix build-time behavior
- [GitHub Actions Workflow Syntax](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions) - Official needs: keyword documentation
- [GitHub Actions Environments](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment) - Environment protection rules

### Secondary (MEDIUM confidence)

- [GitHub Actions Environment Protection Rules (2026)](https://oneuptime.com/blog/post/2026-01-25-github-actions-environment-protection-rules/view) - Recent guide on protection rules
- [GitHub Actions Workflow Dispatch (2026)](https://oneuptime.com/blog/post/2026-01-25-github-actions-workflow-dispatch/view) - Manual trigger patterns
- [Best Practices for .env Files](https://www.getfishtank.com/insights/best-practices-for-committing-env-files-to-version-control) - .env.example template guidance
- [Vite Environment Variables in Production](https://medium.com/@gosagnik/mastering-environment-variables-in-your-vite-react-project-89cf6bb66599) - Build-time vs runtime clarification
- [Cloudflare Custom Domains](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/) - Custom domain routing setup

### Tertiary (LOW confidence - requires validation)

- [Deployment Health Checks Guide](https://moss.sh/reviews/how-to-set-up-deployment-health-checks/) - General health check patterns
- [Atomic Deployment Techniques](https://moss.sh/deployment/atomic-deployment-techniques/) - Multi-service deployment strategies
- [Monorepo Rollback Strategies](https://seed.run/blog/how-to-handle-service-dependencies-when-rolling-back-a-monorepo-serverless-app.html) - Service dependency rollback patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All platforms documented in official docs, versions confirmed in package.json and wrangler.jsonc
- Architecture patterns: HIGH - Sequential deployment verified in GitHub Actions docs, environment variable scoping confirmed in Vite/Convex/PartyKit official docs
- Pitfalls: MEDIUM-HIGH - Common issues identified from platform documentation and community discussions, validated against project's current implementation
- Code examples: HIGH - All examples derived from official documentation or current project codebase (verified via file reads)

**Research date:** 2026-02-12
**Valid until:** 2026-03-12 (30 days - stable technologies, but CI/CD best practices evolve quarterly)

**Critical dependencies:**
- Convex 1.31.7 (stable, quarterly major updates)
- PartyKit 0.0.115 (beta phase, frequent updates)
- Wrangler 4.63.0 (stable, monthly minor updates)
- Vite 7.3.1 (stable, quarterly major updates)
- GitHub Actions (stable, features rarely deprecated)

**Recommend re-validation if:**
- PartyKit reaches 1.0.0 (may change environment variable management)
- Vite 8.x releases (may change environment variable behavior)
- GitHub Actions announces changes to environment protection rules
- Cloudflare deprecates wrangler.jsonc format (low probability based on 2026 docs)
