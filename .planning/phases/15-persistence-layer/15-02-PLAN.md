---
phase: 15-persistence-layer
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - partykit/server.ts
autonomous: true

user_setup:
  - service: convex
    why: "PartyKit needs shared secret to call Convex snapshot endpoints"
    env_vars:
      - name: PARTYKIT_SECRET
        source: "Generate a random secret (e.g., openssl rand -hex 32), then set in both Convex and PartyKit"
    dashboard_config:
      - task: "Set PARTYKIT_SECRET environment variable in Convex"
        location: "npx convex env set PARTYKIT_SECRET <secret>"
      - task: "Set PARTYKIT_SECRET and CONVEX_SITE_URL in PartyKit vars"
        location: "partykit.json vars section or PartyKit dashboard environment"

must_haves:
  truths:
    - "When the last user disconnects from a room, PartyKit saves the full Yjs state to Convex after a debounce delay"
    - "While users are connected, PartyKit periodically saves snapshots to Convex every 30 seconds"
    - "When a user opens a resource with no active PartyKit state, the Yjs document loads from the Convex snapshot"
    - "Quick tab refresh/reopen within the debounce window does not trigger an unnecessary save"
    - "Save failures are logged but do not crash the server or disconnect users"
  artifacts:
    - path: "partykit/server.ts"
      provides: "Periodic saves, disconnect debounce, cold-start loading, snapshot persistence to Convex"
      contains: "onAlarm"
  key_links:
    - from: "partykit/server.ts"
      to: "POST /collaboration/snapshot"
      via: "fetch to Convex HTTP endpoint"
      pattern: "collaboration/snapshot"
    - from: "partykit/server.ts"
      to: "GET /collaboration/snapshot"
      via: "fetch to Convex HTTP endpoint for cold-start"
      pattern: "collaboration/snapshot"
    - from: "partykit/server.ts"
      to: "y-partykit unstable_getYDoc"
      via: "Access Yjs document state for encoding"
      pattern: "unstable_getYDoc"
---

<objective>
Implement Yjs snapshot persistence in the PartyKit server: periodic saves every 30 seconds, debounced save on last-user disconnect, and cold-start loading from Convex snapshots.

Purpose: This is the core persistence logic that prevents data loss. Without this, all collaborative content lives only in PartyKit's Durable Objects storage and client IndexedDB -- a server restart or storage eviction would lose content. After this plan, Yjs state is durably backed up to Convex file storage.

Output: Rewritten partykit/server.ts with full persistence lifecycle management.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-persistence-layer/15-CONTEXT.md
@.planning/phases/15-persistence-layer/15-01-SUMMARY.md
@.planning/phases/14-protocol-foundation/14-01-SUMMARY.md

Key files to read before starting:
@partykit/server.ts
@shared/protocol/errors.ts
@shared/protocol/rooms.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement periodic saves and disconnect debounce with alarm-based persistence</name>
  <files>partykit/server.ts</files>
  <action>
Rewrite partykit/server.ts to add full snapshot persistence lifecycle. Keep the existing auth logic intact, adding persistence on top.

**Imports to add:**
- `import { onConnect, unstable_getYDoc } from "y-partykit";` (add unstable_getYDoc)
- `import type { YPartyKitOptions } from "y-partykit";` (for shared options)
- `import * as Y from "yjs";` (for Y.encodeStateAsUpdate)

**Shared y-partykit options:**
Create a constant `YJS_OPTIONS` of type `YPartyKitOptions` that both `onConnect` and `unstable_getYDoc` must use (they must match for consistency):
```typescript
const YJS_OPTIONS: YPartyKitOptions = {
  persist: { mode: "snapshot" },
};
```

**Class-level state to track:**
```typescript
private saveAlarmScheduled = false;
private periodicAlarmScheduled = false;
```

**Constants:**
```typescript
const PERIODIC_SAVE_INTERVAL = 30_000; // 30 seconds
const DISCONNECT_DEBOUNCE = 7_000; // 7 seconds (within 5-10s per user decision)
const ALARM_TYPE_PERIODIC = "periodic";
const ALARM_TYPE_DISCONNECT = "disconnect";
```

For alarm type tracking, store the alarm reason in room storage:
```typescript
await this.room.storage.put("alarmType", "periodic" | "disconnect");
```

**Persistence method -- `saveSnapshotToConvex()`:**
1. Get the Yjs document: `const yDoc = await unstable_getYDoc(this.room, YJS_OPTIONS);`
2. Encode full state: `const update = Y.encodeStateAsUpdate(yDoc);`
3. If update is empty (length 0 or just the empty state marker), skip save
4. Build the Convex endpoint URL: `const convexSiteUrl = this.room.env.CONVEX_SITE_URL as string;`
5. Get the shared secret: `const secret = this.room.env.PARTYKIT_SECRET as string;`
6. If either is missing, log error and return
7. POST to Convex:
```typescript
const response = await fetch(
  `${convexSiteUrl}/collaboration/snapshot?roomId=${encodeURIComponent(this.room.id)}`,
  {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${secret}`,
      "Content-Type": "application/octet-stream",
    },
    body: update.buffer,
  }
);
```
8. If response is not ok, log error with status and response text. Do NOT throw (per user decision: log and rely on Durable Object storage as fallback)
9. If successful, log: `console.log(\`Snapshot saved for room ${this.room.id}\`);`

**Modified `onConnect()` method:**
After the existing auth verification and `onConnect(conn, this.room, YJS_OPTIONS)` call:
1. Schedule periodic save alarm if not already scheduled:
```typescript
if (!this.periodicAlarmScheduled) {
  await this.room.storage.put("alarmType", ALARM_TYPE_PERIODIC);
  await this.room.storage.setAlarm(Date.now() + PERIODIC_SAVE_INTERVAL);
  this.periodicAlarmScheduled = true;
}
```
Note: Use `YJS_OPTIONS` instead of the inline `{ persist: { mode: "snapshot" } }` in the existing onConnect call.

**New `onClose()` method:**
Called when any connection closes. Check if this was the last connection:
```typescript
async onClose(conn: Party.Connection) {
  // Count remaining connections (excluding the one that just closed)
  // PartyKit's room.getConnections() returns an iterable of active connections
  let connectionCount = 0;
  for (const _ of this.room.getConnections()) {
    connectionCount++;
  }

  if (connectionCount === 0) {
    // Last user disconnected -- schedule debounced save
    console.log(`Last user disconnected from room ${this.room.id}, scheduling debounced save`);
    await this.room.storage.put("alarmType", ALARM_TYPE_DISCONNECT);
    await this.room.storage.setAlarm(Date.now() + DISCONNECT_DEBOUNCE);
    this.saveAlarmScheduled = true;
    this.periodicAlarmScheduled = false; // Stop periodic saves
  }
}
```

**New `onAlarm()` method:**
Handles both periodic saves and disconnect debounce:
```typescript
async onAlarm() {
  const alarmType = await this.room.storage.get("alarmType") as string | undefined;

  if (alarmType === ALARM_TYPE_DISCONNECT) {
    // Check if someone reconnected during the debounce window
    let connectionCount = 0;
    for (const _ of this.room.getConnections()) {
      connectionCount++;
    }

    if (connectionCount === 0) {
      // Still no connections -- save snapshot
      console.log(`Debounce expired for room ${this.room.id}, saving final snapshot`);
      await this.saveSnapshotToConvex();
      this.saveAlarmScheduled = false;
    } else {
      // Someone reconnected -- cancel disconnect save, resume periodic
      console.log(`User reconnected to room ${this.room.id} during debounce, cancelling save`);
      this.saveAlarmScheduled = false;
      // Periodic alarm will be rescheduled by onConnect
    }
  } else if (alarmType === ALARM_TYPE_PERIODIC) {
    // Periodic save while users are connected
    let connectionCount = 0;
    for (const _ of this.room.getConnections()) {
      connectionCount++;
    }

    if (connectionCount > 0) {
      await this.saveSnapshotToConvex();
      // Reschedule next periodic save
      await this.room.storage.put("alarmType", ALARM_TYPE_PERIODIC);
      await this.room.storage.setAlarm(Date.now() + PERIODIC_SAVE_INTERVAL);
    } else {
      // No connections, don't reschedule periodic. Disconnect handler will trigger save.
      this.periodicAlarmScheduled = false;
    }
  }
}
```

**Cold-start loading -- `onStart()` method (or via load callback):**
Use y-partykit's `load` callback in the YJS_OPTIONS to hydrate from Convex when the Durable Object cold-starts with no existing state.

Actually, the better approach for cold-start: use y-partykit's `load` option in `onConnect`. But `load` must return a `Y.Doc` -- we need to fetch from Convex HTTP endpoint.

**Design decision (Claude's Discretion -- cold-start architecture):**
Use the `load` callback in y-partykit options. BUT the `load` function needs access to `this.room.env` for the Convex URL and secret. Since YJS_OPTIONS is a module-level constant, we can't use `load` there.

Instead, make YJS_OPTIONS a method that returns the options:
```typescript
private getYjsOptions(): YPartyKitOptions {
  return {
    persist: { mode: "snapshot" },
    load: async () => {
      return this.loadSnapshotFromConvex();
    },
  };
}
```

And `loadSnapshotFromConvex()`:
```typescript
private async loadSnapshotFromConvex(): Promise<Y.Doc | null> {
  const convexSiteUrl = this.room.env.CONVEX_SITE_URL as string;
  const secret = this.room.env.PARTYKIT_SECRET as string;

  if (!convexSiteUrl || !secret) {
    console.warn("Cannot load snapshot: missing CONVEX_SITE_URL or PARTYKIT_SECRET");
    return null;
  }

  try {
    const response = await fetch(
      `${convexSiteUrl}/collaboration/snapshot?roomId=${encodeURIComponent(this.room.id)}`,
      {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${secret}`,
        },
      }
    );

    if (response.status === 404) {
      // No snapshot exists -- new document
      return null;
    }

    if (!response.ok) {
      console.error(`Failed to load snapshot for room ${this.room.id}: ${response.status}`);
      return null;
    }

    const buffer = await response.arrayBuffer();
    const update = new Uint8Array(buffer);

    const yDoc = new Y.Doc();
    Y.applyUpdate(yDoc, update);
    return yDoc;
  } catch (error) {
    console.error(`Error loading snapshot for room ${this.room.id}:`, error);
    return null;
  }
}
```

**IMPORTANT:** Since YJS_OPTIONS needs to be a method now, `unstable_getYDoc` in `saveSnapshotToConvex` must also use `this.getYjsOptions()`. Update the `saveSnapshotToConvex` call: `const yDoc = await unstable_getYDoc(this.room, this.getYjsOptions());`

**Conflict resolution (Claude's Discretion):**
When both PartyKit Durable Object storage AND Convex snapshot exist, PartyKit's Durable Object storage takes precedence (it's the most recent). The `load` callback is only called when Durable Object storage is empty (cold start). This is the default y-partykit behavior with `persist: { mode: "snapshot" }` -- `load` is a fallback.

**Summary of methods in the final CollaborationServer class:**
- `constructor(readonly room: Party.Room)` (existing)
- `private getYjsOptions(): YPartyKitOptions` (new)
- `private async saveSnapshotToConvex(): Promise<void>` (new)
- `private async loadSnapshotFromConvex(): Promise<Y.Doc | null>` (new)
- `async onConnect(conn, ctx)` (modified -- add periodic alarm scheduling, use getYjsOptions())
- `async onClose(conn)` (new -- detect last user, schedule debounced save)
- `async onAlarm()` (new -- execute periodic or debounced saves)

Keep all existing auth logic (token extraction, Convex verify call, error messages) exactly as-is.
  </action>
  <verify>
1. Run TypeScript check on partykit: `npx tsc --noEmit -p partykit/tsconfig.json` (or check that the PartyKit server compiles)
2. Verify partykit/server.ts has:
   - `unstable_getYDoc` imported from y-partykit
   - `Y.encodeStateAsUpdate` usage for snapshot encoding
   - `Y.applyUpdate` usage for cold-start loading
   - `onClose` method that checks connection count
   - `onAlarm` method with periodic and disconnect alarm types
   - `saveSnapshotToConvex` method that POSTs to `/collaboration/snapshot`
   - `loadSnapshotFromConvex` method that GETs from `/collaboration/snapshot`
   - `getYjsOptions` method returning options with `load` callback
   - DISCONNECT_DEBOUNCE constant between 5000-10000
   - PERIODIC_SAVE_INTERVAL = 30000
3. Run `npm run lint` -- verify 0 warnings
4. Existing auth flow preserved (token extraction, Convex verify, error codes)
  </verify>
  <done>
PartyKit server saves Yjs snapshots to Convex on two triggers: periodic (every 30s while connections active) and debounced (7s after last user disconnects). Cold-starts hydrate from Convex snapshots via load callback. Quick tab refresh within debounce window does not trigger unnecessary save. Save failures logged but don't crash.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. PartyKit TypeScript compilation succeeds
4. partykit/server.ts implements:
   - Periodic save alarm every 30 seconds
   - Debounced save on last-user disconnect (5-10s window)
   - Cold-start loading from Convex snapshot
   - Error-resilient save (log on failure, don't crash)
   - Existing auth flow preserved
5. End-to-end flow: onConnect -> periodic alarm -> saveSnapshotToConvex -> POST /collaboration/snapshot -> Convex file storage
6. End-to-end flow: cold start -> load callback -> loadSnapshotFromConvex -> GET /collaboration/snapshot -> Y.applyUpdate
</verification>

<success_criteria>
PartyKit server persists Yjs state to Convex file storage for all three resource types (documents, diagrams, tasks). Periodic saves protect against browser crashes. Debounced disconnect saves handle the last-user-leaves scenario. Cold starts hydrate from Convex snapshots when Durable Object storage is empty. The system is resilient to save failures (logs error, continues operating).
</success_criteria>

<output>
After completion, create `.planning/phases/15-persistence-layer/15-02-SUMMARY.md`
</output>
