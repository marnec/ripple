---
phase: 15-persistence-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/snapshots.ts
  - convex/http.ts
  - convex/diagrams.ts
autonomous: true

must_haves:
  truths:
    - "Convex file storage can receive and store binary Yjs snapshots from PartyKit"
    - "Each resource table (documents, diagrams, tasks) has a yjsSnapshotId field linking to _storage"
    - "A Convex HTTP endpoint exists that PartyKit can POST binary snapshot data to"
    - "A Convex HTTP endpoint exists that PartyKit can GET snapshot binary from for cold-start hydration"
    - "Legacy diagrams.content field is removed from schema"
  artifacts:
    - path: "convex/snapshots.ts"
      provides: "Snapshot save/load mutations and queries for all three resource types"
      exports: ["saveSnapshot", "getSnapshot"]
    - path: "convex/schema.ts"
      provides: "yjsSnapshotId field on documents, diagrams, and tasks tables"
      contains: "yjsSnapshotId"
    - path: "convex/http.ts"
      provides: "POST /collaboration/snapshot and GET /collaboration/snapshot HTTP endpoints"
  key_links:
    - from: "convex/http.ts"
      to: "convex/snapshots.ts"
      via: "ctx.runMutation(internal.snapshots.saveSnapshot)"
      pattern: "internal\\.snapshots\\.saveSnapshot"
    - from: "convex/http.ts"
      to: "ctx.storage.store"
      via: "Convex file storage API"
      pattern: "ctx\\.storage\\.store"
---

<objective>
Create the Convex backend infrastructure for Yjs snapshot persistence: schema changes, file storage mutations, and HTTP endpoints for PartyKit to save and load binary Yjs state.

Purpose: PartyKit needs a server-to-server API to flush Yjs document state to durable Convex storage. This plan creates the receiving end -- the Convex HTTP endpoints and storage mutations that accept binary snapshots, store them in Convex file storage, and serve them back for cold-start hydration.

Output: Schema with yjsSnapshotId fields, convex/snapshots.ts module, and two HTTP endpoints in convex/http.ts.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-persistence-layer/15-CONTEXT.md
@.planning/phases/14-protocol-foundation/14-01-SUMMARY.md

Key files to read before starting:
@convex/schema.ts
@convex/http.ts
@convex/collaboration.ts
@shared/protocol/rooms.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add yjsSnapshotId to schema and create snapshot mutations</name>
  <files>convex/schema.ts, convex/snapshots.ts, convex/diagrams.ts</files>
  <action>
**Schema changes (convex/schema.ts):**
1. Add `yjsSnapshotId: v.optional(v.id("_storage"))` field to the `documents` table definition
2. Add `yjsSnapshotId: v.optional(v.id("_storage"))` field to the `diagrams` table definition
3. Add `yjsSnapshotId: v.optional(v.id("_storage"))` field to the `tasks` table definition
4. Remove `content: v.optional(v.string())` from the `diagrams` table definition (legacy Excalidraw JSON -- per user decision)

**Diagram validator fix (convex/diagrams.ts):**
- Remove `content: v.optional(v.string())` from the `diagramValidator` object at the top of the file
- Remove the `content: JSON.stringify(...)` from the `create` mutation handler (in the `ctx.db.insert` call). New diagrams will start with empty Yjs state, no legacy JSON needed.

**Snapshot module (convex/snapshots.ts):**
Create a new module with internal mutations/queries for snapshot persistence:

1. `saveSnapshot` - internalMutation:
   - Args: `{ resourceType: v.union(v.literal("doc"), v.literal("diagram"), v.literal("task")), resourceId: v.string(), storageId: v.id("_storage") }`
   - Returns: `v.null()`
   - Logic:
     a. Parse resourceType to determine table name ("doc" -> "documents", "diagram" -> "diagrams", "task" -> "tasks")
     b. Get the resource document by ID (`ctx.db.get(resourceId as Id<"documents"|"diagrams"|"tasks">)`)
     c. If resource doesn't exist, log warning and return (resource may have been deleted)
     d. If resource already has a `yjsSnapshotId`, delete the old storage file: `await ctx.storage.delete(resource.yjsSnapshotId)`
     e. Patch the resource with the new `yjsSnapshotId: storageId`
   - Use `Id` type import from `"./_generated/dataModel"`

2. `getSnapshot` - internalQuery:
   - Args: `{ resourceType: v.union(v.literal("doc"), v.literal("diagram"), v.literal("task")), resourceId: v.string() }`
   - Returns: `v.union(v.id("_storage"), v.null())`
   - Logic:
     a. Parse resourceType to determine table name
     b. Get the resource document by ID
     c. Return `resource.yjsSnapshotId ?? null`

Import from `"./_generated/server"` for `internalMutation`/`internalQuery`, from `"convex/values"` for `v`, and from `"./_generated/dataModel"` for `Id`.
  </action>
  <verify>
Run `npx convex dev --once` (or check that `npm run lint` passes) to verify schema changes are valid and there are no TypeScript errors. Specifically verify:
- `convex/schema.ts` has yjsSnapshotId on all three tables
- `convex/schema.ts` does NOT have `content` on diagrams
- `convex/diagrams.ts` diagramValidator does NOT have content field
- `convex/diagrams.ts` create mutation does NOT insert content
- `convex/snapshots.ts` exports saveSnapshot and getSnapshot
- `npm run lint` passes with 0 warnings
  </verify>
  <done>
Schema has yjsSnapshotId field on documents, diagrams, and tasks. Legacy diagrams.content removed. convex/snapshots.ts has saveSnapshot (internal mutation) and getSnapshot (internal query) working against all three resource types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP endpoints for snapshot save and load</name>
  <files>convex/http.ts</files>
  <action>
Add two new HTTP routes to convex/http.ts for PartyKit server-to-server snapshot operations. These are authenticated via a shared secret (PARTYKIT_SECRET env var) rather than user tokens, since PartyKit server calls them directly.

**POST /collaboration/snapshot** (save endpoint):
1. Validate shared secret from `Authorization: Bearer <secret>` header against `process.env.PARTYKIT_SECRET`
   - If missing or mismatch, return 401 with `{ error: "Unauthorized" }`
2. Extract `roomId` from URL query params: `new URL(request.url).searchParams.get("roomId")`
   - If missing, return 400 with `{ error: "Missing roomId" }`
3. Parse roomId to get resourceType and resourceId. Import `parseRoomId` from the shared protocol module. Note: in Convex http actions you can't import from `@shared/*` path aliases, so use relative import: `import { parseRoomId } from "../shared/protocol/rooms"` (or inline the parsing logic: split on first "-", validate resource type is doc/diagram/task, rest is resourceId)
   - Actually, Convex httpActions are bundled separately and may not resolve relative imports to `../shared/`. The safest approach: inline the roomId parsing directly in the handler (split on first "-", validate type). It's 5 lines and avoids import resolution issues.
4. Read request body as Blob: `const blob = await request.blob()`
5. Store blob in Convex file storage: `const storageId = await ctx.storage.store(blob)`
6. Call saveSnapshot mutation: `await ctx.runMutation(internal.snapshots.saveSnapshot, { resourceType, resourceId, storageId })`
7. Return 200 with `{ success: true }`
8. Wrap in try/catch, return 500 on errors

**GET /collaboration/snapshot** (load endpoint):
1. Validate shared secret from `Authorization: Bearer <secret>` header (same as above)
2. Extract `roomId` from URL query params
3. Parse roomId to get resourceType and resourceId (same inline logic)
4. Call getSnapshot query: `const storageId = await ctx.runQuery(internal.snapshots.getSnapshot, { resourceType, resourceId })`
5. If storageId is null, return 404 with `{ error: "No snapshot found" }`
6. Get the blob from storage: `const blob = await ctx.storage.get(storageId)`
7. If blob is null (file was deleted), return 404
8. Return the blob directly as the response body with `Content-Type: application/octet-stream`

**CORS:** These are server-to-server endpoints (PartyKit -> Convex), no CORS headers needed.

**Import additions:** Add `import { internal } from "./_generated/api";` (already imported). Ensure httpAction import is available (already imported).

**Environment variable:** The `PARTYKIT_SECRET` must be set as a Convex environment variable. The executor should note this requires `npx convex env set PARTYKIT_SECRET <value>` but do NOT actually set it -- just document it in the code comments. Use a fallback for local dev: if `process.env.PARTYKIT_SECRET` is undefined, skip auth check (development mode). Actually, better approach: always require the secret. Log a warning if not configured.
  </action>
  <verify>
Run `npm run lint` to verify no TypeScript errors. Verify:
- Two new routes exist in convex/http.ts: POST /collaboration/snapshot and GET /collaboration/snapshot
- Both routes validate PARTYKIT_SECRET
- POST route stores blob and calls saveSnapshot
- GET route calls getSnapshot and returns blob
- `npm run build` succeeds
  </verify>
  <done>
Two HTTP endpoints exist for snapshot persistence. POST /collaboration/snapshot accepts binary Yjs state from PartyKit, stores it in Convex file storage, and links it to the resource via yjsSnapshotId. GET /collaboration/snapshot returns the binary snapshot for cold-start hydration. Both authenticated via shared secret.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 warnings
2. `npm run build` succeeds
3. convex/schema.ts has `yjsSnapshotId: v.optional(v.id("_storage"))` on documents, diagrams, and tasks tables
4. convex/schema.ts does NOT have `content` field on diagrams table
5. convex/snapshots.ts has saveSnapshot (internalMutation) and getSnapshot (internalQuery)
6. convex/http.ts has POST /collaboration/snapshot and GET /collaboration/snapshot routes
7. Both HTTP routes validate PARTYKIT_SECRET authorization
</verification>

<success_criteria>
Convex backend is ready to receive and serve binary Yjs snapshots for all three resource types (documents, diagrams, tasks). Schema has yjsSnapshotId fields. HTTP endpoints exist for PartyKit server-to-server communication. Legacy diagrams.content field removed.
</success_criteria>

<output>
After completion, create `.planning/phases/15-persistence-layer/15-01-SUMMARY.md`
</output>
