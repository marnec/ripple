---
phase: 04-chat-to-task-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/projects.ts
  - convex/tasks.ts
  - src/pages/App/Chat/Message.tsx
  - src/pages/App/Chat/CreateTaskFromMessagePopover.tsx
  - src/pages/App/Chat/Chat.tsx
autonomous: true

must_haves:
  truths:
    - "User can right-click a chat message and see 'Create task from message' in the context menu"
    - "Clicking 'Create task from message' opens a popover with title pre-filled from message text"
    - "Popover auto-selects the channel's linked project if one exists"
    - "Creating a task captures the message content as the task's BlockNote description"
    - "A system message appears in chat after task creation confirming the action"
  artifacts:
    - path: "src/pages/App/Chat/CreateTaskFromMessagePopover.tsx"
      provides: "Quick task creation popover with title, project picker, Create button"
    - path: "convex/projects.ts"
      provides: "getByLinkedChannel query for reverse channel-to-project lookup"
  key_links:
    - from: "src/pages/App/Chat/Message.tsx"
      to: "src/pages/App/Chat/CreateTaskFromMessagePopover.tsx"
      via: "context menu item triggers popover open"
      pattern: "handleCreateTask.*setIsCreatingTask"
    - from: "src/pages/App/Chat/CreateTaskFromMessagePopover.tsx"
      to: "convex/tasks.ts"
      via: "tasks.create mutation call"
      pattern: "useMutation.*api\\.tasks\\.create"
    - from: "src/pages/App/Chat/CreateTaskFromMessagePopover.tsx"
      to: "convex/messages.ts"
      via: "messages.send mutation for system message"
      pattern: "useMutation.*api\\.messages\\.send"
---

<objective>
Create task from chat message via right-click context menu with context capture.

Purpose: Users can capture action items from conversations by right-clicking a message and creating a task. The message content is preserved as the task description, and a system message confirms the action in chat.

Output: Context menu extension on Message.tsx, CreateTaskFromMessagePopover component, backend query for channel-to-project lookup, system message feedback.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-chat-to-task-integration/04-RESEARCH.md

Key existing files to reference:
@src/pages/App/Chat/Message.tsx â€” Context menu pattern (ContextMenu, ContextMenuItem)
@src/pages/App/Chat/Chat.tsx â€” Chat component with handleSubmit, channelId prop
@src/pages/App/Chat/MessageComposer.tsx â€” BlockNote editor, tryParseHTMLToBlocks pattern
@convex/messages.ts â€” send mutation, list query
@convex/tasks.ts â€” create mutation, get query
@convex/projects.ts â€” listByUserMembership query
@convex/schema.ts â€” projects.linkedChannelId field
@src/components/ui/safe-html.tsx â€” SafeHtml component
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend â€” add channel-to-project lookup query</name>
  <files>convex/projects.ts</files>
  <action>
Add a `getByLinkedChannel` query to convex/projects.ts:

```typescript
export const getByLinkedChannel = query({
  args: { channelId: v.id("channels") },
  returns: v.union(projectValidator, v.null()),
  handler: async (ctx, { channelId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return null;

    // Get channel to find workspace
    const channel = await ctx.db.get(channelId);
    if (!channel) return null;

    // Find project that has this channel as linked channel
    // Projects per workspace are small (<100), so filter is acceptable
    const projects = await ctx.db
      .query("projects")
      .withIndex("by_workspace", (q) => q.eq("workspaceId", channel.workspaceId))
      .collect();

    const project = projects.find((p) => p.linkedChannelId === channelId);
    if (!project) return null;

    // Verify user has project membership
    const membership = await ctx.db
      .query("projectMembers")
      .withIndex("by_project_user", (q) =>
        q.eq("projectId", project._id).eq("userId", userId)
      )
      .first();

    if (!membership) return null;

    return project;
  },
});
```

This enables the popover to auto-select the linked project when creating a task from a channel message.
  </action>
  <verify>Run `npx convex dev --once` or check `npm run lint` passes. The query should be callable from the frontend.</verify>
  <done>projects.getByLinkedChannel query exists and returns the project linked to a given channelId (or null if none exists or user lacks access).</done>
</task>

<task type="auto">
  <name>Task 2: Create task from message â€” context menu + popover + system message</name>
  <files>
    src/pages/App/Chat/Message.tsx
    src/pages/App/Chat/CreateTaskFromMessagePopover.tsx
    src/pages/App/Chat/Chat.tsx
    convex/tasks.ts
  </files>
  <action>
**CreateTaskFromMessagePopover.tsx** (NEW):

Create a popover component that receives a message and channelId, and allows quick task creation:

Props:
- `message: MessageWithAuthor` â€” the right-clicked message
- `channelId: Id<"channels">` â€” current channel
- `workspaceId: Id<"workspaces">` â€” current workspace
- `open: boolean` â€” controlled open state
- `onOpenChange: (open: boolean) => void`
- `anchorRef: React.RefObject<HTMLElement>` â€” positioned near message
- `onTaskCreated: (taskId: Id<"tasks">, taskTitle: string) => void` â€” callback after creation

Implementation:
1. State: `taskTitle` (pre-filled from message plainText first line, truncated to ~80 chars), `selectedProjectId`
2. Queries:
   - `useQuery(api.projects.getByLinkedChannel, { channelId })` â€” auto-select linked project
   - `useQuery(api.projects.listByUserMembership, { workspaceId })` â€” project picker dropdown
3. Auto-select: When linkedProject exists, pre-select it. Otherwise show dropdown.
4. On Create button click:
   - Convert message.body (HTML) to BlockNote JSON using a temporary BlockNote editor: `BlockNoteEditor.create()`, then `editor.tryParseHTMLToBlocks(message.body)`, serialize with `JSON.stringify(blocks)`
   - Call `tasks.create` mutation with: projectId, title, description (BlockNote JSON string)
   - Call `onTaskCreated` callback with returned taskId and title
5. UI: Use shadcn `Popover` with `PopoverAnchor` pattern. Content has:
   - Input for title (pre-filled, editable)
   - Select dropdown for project (pre-selected if linked project exists)
   - "Create Task" Button
   - Compact layout: `className="w-80 p-4"` with `space-y-3`

Title extraction helper:
```typescript
function extractTitle(plainText: string): string {
  const firstLine = plainText.split('\n')[0].trim();
  return firstLine.length > 80 ? firstLine.substring(0, 77) + '...' : firstLine;
}
```

**Message.tsx** modifications:

1. Enable context menu for ALL users (not just message author). Currently `ContextMenuTrigger` has `disabled={userId !== user?._id}`. Change this:
   - Keep Edit and Delete only for message author (conditional rendering)
   - Add "Create task from message" for all users
   - The context menu trigger should be enabled for everyone

2. Add state: `isCreatingTask` boolean, `messageRef` React ref on the message container
3. Add "Create task from message" context menu item that sets `isCreatingTask = true`
4. Render `CreateTaskFromMessagePopover` component conditionally when `isCreatingTask` is true
5. Pass channelId and workspaceId (get from URL params via `useParams`)

The Message component needs channelId. Either:
- Pass it as a prop from Chat.tsx (preferred â€” cleaner than parsing URL)
- Or use useParams to get it

Choose: Add `channelId` and `workspaceId` as props to Message component. Update Chat.tsx to pass these through.

**Chat.tsx** modifications:

1. Pass `channelId` and `workspaceId` to each Message component
2. Get `workspaceId` from `useParams()`
3. Add `onTaskCreated` handler that sends a system message:
   - Use `sendMessage` mutation with a system message body
   - Body: `<p class="text-muted-foreground text-sm italic">ðŸ“‹ {userName} created a task: <strong>{taskTitle}</strong></p>`
   - plainText: `{userName} created a task: {taskTitle}`
   - Use `crypto.randomUUID()` for isomorphicId
4. Pass `onTaskCreated` handler to Message via props, which passes it to the popover

**Important details:**
- The popover should close after successful task creation
- Use `BlockNoteSchema.create({ blockSpecs: remainingBlockSpecs })` matching MessageComposer schema for the temp editor (import from MessageComposer or recreate)
- Handle loading states: disable Create button while mutation is pending
- Show toast on success: "Task created successfully"
  </action>
  <verify>
1. `npm run lint` passes with no errors
2. Right-clicking any message shows "Create task from message" option
3. Clicking it opens a popover with pre-filled title and project dropdown
4. Creating a task generates a system message in chat confirming the action
  </verify>
  <done>
User can right-click any chat message, see "Create task from message" in context menu, fill out title and project in a popover, and create a task with the message content captured as the task description. A system message confirms the creation in chat.
  </done>
</task>

</tasks>

<verification>
1. Right-click on a message â†’ "Create task from message" appears in context menu
2. Clicking opens popover near message with title pre-filled from first line of message
3. If channel has a linked project, it is auto-selected in the project picker
4. If no linked project, all user's projects appear in dropdown
5. Click "Create Task" â†’ task is created with:
   - Title from popover input
   - Description containing the message content as BlockNote JSON
   - Default status and priority
6. System message appears in chat: "[User] created a task: [Task Title]"
7. `npm run lint` passes
</verification>

<success_criteria>
- Context menu shows "Create task from message" on any chat message
- Task created with message content as BlockNote description
- System message confirms creation in chat
- Auto-selects linked project when channel has one
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-chat-to-task-integration/04-01-SUMMARY.md`
</output>
