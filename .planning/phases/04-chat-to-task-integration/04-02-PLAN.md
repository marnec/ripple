---
phase: 04-chat-to-task-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/App/Chat/MessageComposer.tsx
  - src/pages/App/Chat/CustomInlineContent/TaskMention.tsx
  - src/pages/App/Chat/TaskMentionChip.tsx
  - src/pages/App/Chat/message-composer.css
autonomous: true

must_haves:
  truths:
    - "User can type # in the message composer to open a task autocomplete dropdown"
    - "Autocomplete shows tasks from the channel's linked project (or all user tasks if no linked project)"
    - "Selecting a task from autocomplete inserts an inline chip in the message"
    - "Sent messages display task mentions as clickable chips with colored status dot and title"
    - "Task chips update in real-time when the task's status changes"
  artifacts:
    - path: "src/pages/App/Chat/CustomInlineContent/TaskMention.tsx"
      provides: "BlockNote inline content spec for task mentions"
    - path: "src/pages/App/Chat/TaskMentionChip.tsx"
      provides: "Read-only task chip component with live status updates for sent messages"
  key_links:
    - from: "src/pages/App/Chat/MessageComposer.tsx"
      to: "src/pages/App/Chat/CustomInlineContent/TaskMention.tsx"
      via: "BlockNote schema with taskMention inline content spec"
      pattern: "inlineContentSpecs.*taskMention"
    - from: "src/pages/App/Chat/MessageComposer.tsx"
      to: "convex/tasks.ts"
      via: "SuggestionMenuController getItems fetches tasks"
      pattern: "SuggestionMenuController.*triggerCharacter.*#"
    - from: "src/pages/App/Chat/TaskMentionChip.tsx"
      to: "convex/tasks.ts"
      via: "useQuery for live task data"
      pattern: "useQuery.*api\\.tasks\\.get"
---

<objective>
Add task mention syntax (#) to the chat message composer with inline task chips in sent messages.

Purpose: Users can reference tasks in conversations using # autocomplete. Task mentions render as compact, clickable chips with live-updating status indicators, creating a seamless bridge between chat and task management.

Output: TaskMention BlockNote inline content spec, SuggestionMenuController integration in MessageComposer, TaskMentionChip for rendering in sent messages.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-chat-to-task-integration/04-RESEARCH.md

Key existing files to reference:
@src/pages/App/Document/CustomBlocks/UserBlock.tsx — Inline content spec pattern (createReactInlineContentSpec)
@src/pages/App/Document/DocumentEditor.tsx — SuggestionMenuController pattern (@ for users, # for diagrams)
@src/pages/App/Chat/MessageComposer.tsx — Current BlockNote editor setup, schema, blocksToFullHTML
@src/pages/App/Chat/Message.tsx — SafeHtml rendering of message body
@src/components/ui/safe-html.tsx — SafeHtml component (DOMPurify)
@convex/tasks.ts — listByProject query, get query for live task data
@convex/projects.ts — getByLinkedChannel query (added by plan 04-01, but may not exist yet — handle gracefully)
@convex/schema.ts — tasks and projects schema
</context>

<tasks>

<task type="auto">
  <name>Task 1: TaskMention inline content spec + TaskMentionChip</name>
  <files>
    src/pages/App/Chat/CustomInlineContent/TaskMention.tsx
    src/pages/App/Chat/TaskMentionChip.tsx
  </files>
  <action>
**TaskMention.tsx** (NEW — `src/pages/App/Chat/CustomInlineContent/TaskMention.tsx`):

Create a BlockNote inline content spec for task mentions, following the UserBlock.tsx pattern:

```typescript
import { createReactInlineContentSpec } from "@blocknote/react";
import { Id } from "../../../../../convex/_generated/dataModel";

// Lightweight editor-time render (just shows task title text, no live queries)
// The actual interactive chip is rendered post-send via TaskMentionChip
export const TaskMention = createReactInlineContentSpec(
  {
    type: "taskMention",
    propSchema: {
      taskId: {
        default: "" as unknown as string,
      },
      taskTitle: {
        default: "",
      },
    },
    content: "none",
  } as const,
  {
    render: ({ inlineContent }) => {
      const { taskId, taskTitle } = inlineContent.props;

      if (!taskId) {
        return (
          <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full bg-destructive/20 text-sm">
            #unknown-task
          </span>
        );
      }

      // In-editor preview: show task title as a styled chip
      return (
        <span className="inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted text-sm font-medium cursor-default">
          <span className="h-2 w-2 rounded-full bg-gray-400" />
          <span className="max-w-50 truncate">{taskTitle || "Task"}</span>
        </span>
      );
    },
  }
);
```

Key decisions:
- Store both `taskId` and `taskTitle` in props. The taskTitle is used for editor-time display (no Convex query in editor to keep it fast). The taskId is used post-send for live rendering.
- The render function shows a simple chip in the editor. When the message is sent and rendered via SafeHtml, the `TaskMentionChip` component takes over with live data.

**TaskMentionChip.tsx** (NEW — `src/pages/App/Chat/TaskMentionChip.tsx`):

This component renders task mentions in already-sent messages. It uses `useQuery` for live status updates.

```typescript
import { cn } from "@/lib/utils";
import { useQuery } from "convex/react";
import { useNavigate, useParams } from "react-router-dom";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";

interface TaskMentionChipProps {
  taskId: string; // comes from data attribute as string
}

export function TaskMentionChip({ taskId }: TaskMentionChipProps) {
  const task = useQuery(api.tasks.get, {
    taskId: taskId as Id<"tasks">,
  });
  const navigate = useNavigate();
  const { workspaceId } = useParams();

  if (!task) {
    return (
      <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full bg-muted/50 text-muted-foreground text-sm">
        #deleted-task
      </span>
    );
  }

  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    navigate(`/workspaces/${workspaceId}/projects/${task.projectId}`, {
      state: { highlightTaskId: taskId },
    });
  };

  return (
    <button
      onClick={handleClick}
      className="inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted hover:bg-muted/80 transition-colors cursor-pointer text-sm font-medium"
    >
      <span
        className={cn(
          "h-2 w-2 rounded-full shrink-0",
          task.status?.color || "bg-gray-500"
        )}
      />
      <span className="max-w-50 truncate">{task.title}</span>
    </button>
  );
}
```

Key features:
- Uses `useQuery(api.tasks.get)` for real-time status updates — when task status changes, the dot color updates live
- Click navigates to the project page with `highlightTaskId` in state (for future highlighting)
- Graceful fallback for deleted tasks: shows "#deleted-task" styled chip
- Compact inline chip that flows with surrounding text
  </action>
  <verify>Files exist and compile without TypeScript errors. Check: `npm run lint`</verify>
  <done>TaskMention inline content spec created with editor-time preview. TaskMentionChip component created with live status dot updates and click-to-navigate behavior.</done>
</task>

<task type="auto">
  <name>Task 2: MessageComposer — # autocomplete and task mention rendering in sent messages</name>
  <files>
    src/pages/App/Chat/MessageComposer.tsx
    src/pages/App/Chat/Message.tsx
    src/pages/App/Chat/message-composer.css
  </files>
  <action>
**MessageComposer.tsx** modifications:

1. **Update BlockNote schema** to include the TaskMention inline content spec:

```typescript
import { defaultInlineContentSpecs } from "@blocknote/core";
import { SuggestionMenuController } from "@blocknote/react";
import { TaskMention } from "./CustomInlineContent/TaskMention";

const schema = BlockNoteSchema.create({
  blockSpecs: { ...remainingBlockSpecs },
  inlineContentSpecs: {
    ...defaultInlineContentSpecs,
    taskMention: TaskMention,
  },
});
```

2. **Add new props** to MessageComposer:
   - `channelId: Id<"channels">` — needed to determine linked project scope
   - `workspaceId: Id<"workspaces">` — needed for cross-project task lookup

3. **Add Convex queries** inside MessageComposer:
   - Query all projects the user is a member of: `useQuery(api.projects.listByUserMembership, { workspaceId })`
   - Find the linked project from projects list: `const linkedProject = projects?.find(p => p.linkedChannelId === channelId)`
   - Query tasks for autocomplete: use `useQuery(api.tasks.listByProject, { projectId: linkedProject._id, hideCompleted: true })` if linkedProject exists, otherwise use `useQuery(api.tasks.listByAssignee, { workspaceId, hideCompleted: true })`

4. **Add SuggestionMenuController** inside BlockNoteView:

```tsx
<BlockNoteView editor={editor} ...>
  <SuggestionMenuController
    triggerCharacter={"#"}
    getItems={async (query) => {
      const tasksToSearch = linkedProject ? projectTasks : myTasks;
      if (!tasksToSearch) return [];

      return tasksToSearch
        .filter((task) =>
          task.title.toLowerCase().includes(query.toLowerCase())
        )
        .slice(0, 10)
        .map((task) => ({
          title: task.title,
          onItemClick: () => {
            editor.insertInlineContent([
              {
                type: "taskMention",
                props: {
                  taskId: task._id,
                  taskTitle: task.title,
                },
              },
              " ",
            ]);
          },
          icon: (
            <div
              className={cn(
                "h-3 w-3 rounded-full",
                task.status?.color || "bg-gray-500"
              )}
            />
          ),
          group: linkedProject ? "Project tasks" : "My tasks",
          key: task._id,
        }));
    }}
  />
</BlockNoteView>
```

5. **Update Chat.tsx** to pass `channelId` and `workspaceId` props to MessageComposer:

```tsx
<MessageComposer
  handleSubmit={...}
  channelId={channelId}
  workspaceId={workspaceId as Id<"workspaces">}
/>
```

Get workspaceId from `useParams()`.

**Message.tsx — Rendering task mention chips in sent messages:**

The critical challenge: When a message is sent, BlockNote serializes the content to HTML via `blocksToFullHTML()`. The TaskMention inline content will serialize to an HTML span with data attributes (BlockNote's default serialization for inline content includes the type and props as data attributes).

To render interactive task chips in sent messages:

1. **Replace SafeHtml with a new MessageContent component** (or enhance Message.tsx inline):
   - After rendering the HTML via SafeHtml, use a `useEffect` + `useRef` to find all `[data-inline-content-type="taskMention"]` spans in the rendered DOM
   - For each span, extract `data-task-id` from the serialized props
   - Use React `createRoot` to render a `TaskMentionChip` component inside each span

However, this approach with `createRoot` is complex. A simpler alternative:

**Simpler approach — Parse HTML and replace task mention spans:**

Create a wrapper component around SafeHtml in Message.tsx that:
1. Parses the HTML string to find task mention patterns
2. Splits the content into segments (text + task chips)
3. Renders segments with React components

Actually, the simplest approach: BlockNote inline content specs render their `render` function output to HTML when `blocksToFullHTML()` is called. The TaskMention render function outputs `<span>` elements. We need to customize this.

**Best approach (DOMPurify + post-process):**

In Message.tsx, instead of using SafeHtml directly:
1. Keep SafeHtml for sanitization
2. Add `ref` to the message container
3. After render, use `useEffect` to find spans with `data-inline-content-type="taskMention"`
4. For each, create a portal with `createRoot` to render `TaskMentionChip`
5. Clean up roots on unmount

But wait — BlockNote's `blocksToFullHTML` might not serialize inline content with data attributes by default. Need to check.

**Pragmatic approach**: Override the serialization in the inline content spec. In the TaskMention definition, the `render` function already outputs HTML with task info. When `blocksToFullHTML()` runs, it renders the React component to static HTML. The rendered HTML will contain the span with the task title.

The issue is we need to get the taskId into the serialized HTML for post-processing. Options:
- Add a `data-task-id` attribute to the span in the render function
- Use a recognizable pattern in the HTML

**Updated TaskMention render** to include data attribute:
```tsx
render: ({ inlineContent }) => {
  const { taskId, taskTitle } = inlineContent.props;
  return (
    <span
      data-task-id={taskId}
      data-content-type="task-mention"
      className="inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted text-sm font-medium"
    >
      <span className="h-2 w-2 rounded-full bg-gray-400" />
      <span>{taskTitle || "Task"}</span>
    </span>
  );
},
```

Then in Message.tsx, after SafeHtml renders:
```tsx
import { TaskMentionChip } from "./TaskMentionChip";
import { createRoot, Root } from "react-dom/client";

// Inside Message component:
const contentRef = useRef<HTMLDivElement>(null);
const rootsRef = useRef<Root[]>([]);

useEffect(() => {
  // Clean up previous roots
  rootsRef.current.forEach(root => root.unmount());
  rootsRef.current = [];

  if (!contentRef.current) return;

  const taskSpans = contentRef.current.querySelectorAll('[data-content-type="task-mention"]');
  taskSpans.forEach(span => {
    const taskId = span.getAttribute('data-task-id');
    if (!taskId) return;

    const root = createRoot(span);
    root.render(<TaskMentionChip taskId={taskId} />);
    rootsRef.current.push(root);
  });

  return () => {
    rootsRef.current.forEach(root => root.unmount());
    rootsRef.current = [];
  };
}, [body]);
```

IMPORTANT: The `createRoot` approach needs the Convex and Router providers. Since Message.tsx is already inside these providers in the component tree, `TaskMentionChip` rendered via `createRoot` will NOT have access to them.

**Better approach**: Don't use `createRoot`. Instead, parse the HTML to extract task IDs and render everything in React:

1. In Message.tsx, parse `body` HTML string to find `data-content-type="task-mention"` spans
2. Split the content into an array of segments: `{ type: 'html', content: string } | { type: 'taskMention', taskId: string }`
3. Render each segment: HTML segments via SafeHtml, task mentions via TaskMentionChip

Implementation:
```typescript
function parseMessageContent(html: string): Array<{ type: 'html'; content: string } | { type: 'taskMention'; taskId: string }> {
  const segments: Array<{ type: 'html'; content: string } | { type: 'taskMention'; taskId: string }> = [];
  // Use regex to split on task mention spans
  const pattern = /<span[^>]*data-content-type="task-mention"[^>]*data-task-id="([^"]*)"[^>]*>.*?<\/span>/g;
  let lastIndex = 0;
  let match;

  while ((match = pattern.exec(html)) !== null) {
    if (match.index > lastIndex) {
      segments.push({ type: 'html', content: html.slice(lastIndex, match.index) });
    }
    segments.push({ type: 'taskMention', taskId: match[1] });
    lastIndex = match.index + match[0].length;
  }

  if (lastIndex < html.length) {
    segments.push({ type: 'html', content: html.slice(lastIndex) });
  }

  return segments;
}
```

Then render:
```tsx
const segments = useMemo(() => parseMessageContent(body), [body]);

return (
  <div className={cn("rounded-xl bg-muted px-3 py-2 transition-all", ...)}>
    {segments.map((seg, i) =>
      seg.type === 'html' ? (
        <SafeHtml key={i} html={seg.content} className="inline" />
      ) : (
        <TaskMentionChip key={i} taskId={seg.taskId} />
      )
    )}
  </div>
);
```

This approach keeps everything in the React tree with full provider access.

**DOMPurify configuration**: Make sure DOMPurify in SafeHtml does NOT strip `data-*` attributes. Check and update if needed. Add to DOMPurify.sanitize options: `ADD_ATTR: ['data-task-id', 'data-content-type']`. Actually, since we're parsing before sanitization, this isn't needed — the task mention spans are replaced with React components, so SafeHtml only sees the remaining HTML fragments.

**message-composer.css** — may need minor styling for the suggestion dropdown if it doesn't look right by default.
  </action>
  <verify>
1. `npm run lint` passes
2. Typing # in message composer opens autocomplete dropdown showing tasks
3. Selecting a task inserts a chip in the editor
4. Sending the message renders the chip with live status dot
5. Clicking the chip navigates to the project page
  </verify>
  <done>
# autocomplete works in message composer showing tasks from linked project (or all user tasks). Task mentions appear as inline chips in sent messages with live-updating status dots. Clicking a chip navigates to the project page.
  </done>
</task>

</tasks>

<verification>
1. Type # in message composer → autocomplete dropdown appears with task list
2. Tasks shown are from the channel's linked project (or all user tasks if no linked project)
3. Selecting a task inserts an inline chip showing task title in the editor
4. Send the message → task chip renders with colored status dot + truncated title
5. Update the task's status in kanban → status dot color updates live in the chat message
6. Click the task chip → navigates to the project page
7. Deleted tasks show "#deleted-task" fallback
8. `npm run lint` passes
</verification>

<success_criteria>
- # trigger opens task autocomplete in message composer
- Task chips render inline in sent messages with live status dot
- Click on chip navigates to project page
- Autocomplete scopes to linked project or all user tasks
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-chat-to-task-integration/04-02-SUMMARY.md`
</output>
