# Phase 13.2: Add Document-Like Collaboration to BlockNote Editor in Tasks - Research

**Researched:** 2026-02-12
**Domain:** Real-time collaborative editing for task descriptions using existing Yjs/PartyKit infrastructure
**Confidence:** HIGH

## Summary

Phase 13.2 extends the Yjs-based collaborative editing infrastructure (built in Phases 11-12) to task descriptions. Currently, tasks use BlockNote for descriptions but with local-only editing and 500ms debounced auto-save to Convex. This phase adds real-time collaboration (multi-user cursors, live updates) by integrating the existing `useYjsProvider` hook and `useDocumentCollaboration` pattern into task editors. The key technical challenge is managing multiple task editor instances (one per open TaskDetailSheet or full-page task view) where each must connect to its own PartyKit room (`task-{taskId}`) while reusing the exact same infrastructure patterns proven in document/diagram collaboration.

The migration path requires removing the Convex `description` field (currently stores BlockNote JSON as string) and moving content to PartyKit/Yjs only, similar to the document migration in Phase 12. However, unlike documents where content deletion was acceptable, tasks may have existing descriptions that need migration. The research recommends a hybrid approach: wipe development data, implement one-time migration script for production that converts existing JSON to Yjs format on first load.

**Primary recommendation:** Reuse `useDocumentCollaboration` hook with minor adjustments for task-specific schema, implement `task-{taskId}` room naming, remove `description` field from Convex tasks table, migrate existing task descriptions via one-time script that loads JSON and saves to Yjs, and add ActiveUsers + ConnectionStatus components to both TaskDetailSheet and full-page task views.

## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| yjs | ^13.6.29 | CRDT document sync | Already in use for documents/diagrams (Phase 11-12) |
| y-partykit | ^0.0.33 | WebSocket provider | Already deployed, handles Yjs transport over PartyKit |
| @blocknote/core | 0.46.2 | Block-based editor | Already in use for documents and task descriptions |
| @blocknote/react | 0.46.2 | React bindings | Already integrated, `useCreateBlockNote` hook |
| y-indexeddb | Latest | Offline persistence | Already used for documents, provides offline editing |
| color-hash | Latest | Consistent user colors | Already implemented via `getUserColor` singleton |

### Supporting
No new packages required. All collaboration infrastructure exists from Phases 11-12.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Reuse existing hooks | Build task-specific hooks | No benefit - pattern proven in documents, copy-paste introduces maintenance burden |
| Remove Convex description field | Keep dual storage (Convex + Yjs) | Dual storage creates sync conflicts, increases complexity, same rationale as Phase 12 document migration |
| Wipe all task descriptions | Implement full migration | Migration adds complexity but preserves user data. Recommend hybrid: dev wipe, production migration script |

**Installation:**
```bash
# No new packages needed - all dependencies installed in Phase 11/12
# Verify existing packages:
npm list yjs y-partykit y-indexeddb color-hash
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── hooks/
│   ├── use-yjs-provider.ts              # EXISTS: Generic Yjs provider hook
│   ├── use-document-collaboration.ts    # EXISTS: Document-specific integration
│   ├── use-task-collaboration.ts        # NEW: Task-specific wrapper (minimal diff)
│   └── use-cursor-awareness.ts          # EXISTS: Awareness state management
├── pages/App/Project/
│   ├── TaskDetailSheet.tsx              # UPDATE: Replace local editor with collaborative
│   ├── TaskDescriptionEditor.tsx        # UPDATE: Accept provider + awareness props
│   ├── useTaskDetail.ts                 # UPDATE: Replace useCreateBlockNote with useTaskCollaboration
│   ├── Task.tsx (full-page)             # UPDATE (if exists): Add collaboration
│   └── taskDescriptionSchema.ts         # EXISTS: Custom blocks/inline content
└── lib/
    └── user-colors.ts                   # EXISTS: ColorHash singleton

convex/
├── tasks.ts                             # UPDATE: Remove description field mutations
├── schema.ts                            # UPDATE: Remove description field from tasks table
└── collaboration.ts                     # UPDATE: Add "task" resourceType support
```

### Pattern 1: Reuse Document Collaboration Hook for Tasks
**What:** Adapt `useDocumentCollaboration` pattern for task-specific schema
**When to use:** Every task editor instance (sheet or full-page)
**Example:**
```typescript
// src/hooks/use-task-collaboration.ts
import { useDocumentCollaboration } from "./use-document-collaboration";
import { taskDescriptionSchema } from "../pages/App/Project/taskDescriptionSchema";

export function useTaskCollaboration({
  taskId,
  userName,
  userId,
}: {
  taskId: string;
  userName: string;
  userId: string;
}) {
  return useDocumentCollaboration({
    documentId: taskId, // Reuse documentId param but pass taskId
    userName,
    userId,
    schema: taskDescriptionSchema, // Task-specific schema with custom inline content
  });
}
```

**Why:** `useDocumentCollaboration` is generic - accepts any BlockNoteSchema. Only difference for tasks is the schema (already defined in `taskDescriptionSchema.ts`). Avoids duplicating Yjs provider setup, IndexedDB persistence, and user color logic.

### Pattern 2: Task-Specific PartyKit Room Naming
**What:** Use `task-{taskId}` room naming convention for isolation
**When to use:** All task collaboration connections
**Example:**
```typescript
// Update convex/collaboration.ts to support task resourceType
export const getCollaborationToken = action({
  args: {
    resourceType: v.union(
      v.literal("doc"),
      v.literal("diagram"),
      v.literal("task") // ADD THIS
    ),
    resourceId: v.string(),
  },
  returns: v.object({
    token: v.string(),
    roomId: v.string(),
  }),
  handler: async (ctx, { resourceType, resourceId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify permissions based on resourceType
    if (resourceType === "task") {
      const task = await ctx.runQuery(internal.tasks.getById, {
        id: resourceId as Id<"tasks">,
      });
      if (!task) throw new Error("Task not found");

      // Check project membership
      const member = await ctx.runQuery(internal.projectMembers.getByProjectUser, {
        projectId: task.projectId,
        userId,
      });
      if (!member) throw new Error("No access to task");
    }
    // ... existing doc/diagram logic ...

    const roomId = `${resourceType}-${resourceId}`;
    const token = (await ctx.auth.getUserIdentity())?.tokenIdentifier || "";
    return { token, roomId };
  },
});
```

**Why:** Consistent with existing `doc-{documentId}` and `diagram-{diagramId}` patterns. Enables permission verification at PartyKit connection time (onBeforeConnect hook already handles type-prefixed rooms from Phase 11).

### Pattern 3: Migration from Convex to Yjs Storage
**What:** One-time migration of existing task descriptions from Convex JSON to Yjs
**When to use:** Production deployment only (dev can wipe)
**Example:**
```typescript
// convex/migrations/migrateTaskDescriptions.ts
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";

export const migrateTaskDescription = internalMutation({
  args: { taskId: v.id("tasks") },
  returns: v.null(),
  handler: async (ctx, { taskId }) => {
    const task = await ctx.db.get(taskId);
    if (!task || !task.description) return;

    // Parse BlockNote JSON from Convex
    let blocks;
    try {
      blocks = JSON.parse(task.description);
    } catch {
      console.error(`Failed to parse description for task ${taskId}`);
      return;
    }

    // Convert to Yjs format (handled by BlockNote Yjs utilities)
    // This will be triggered client-side on first editor load:
    // 1. Check if PartyKit room is empty (no content)
    // 2. If empty AND task.description exists, load blocks from Convex
    // 3. Insert blocks into editor (syncs to Yjs automatically)
    // 4. Clear task.description in Convex to mark as migrated

    // Clear description field after migration
    await ctx.db.patch(taskId, { description: undefined });
  },
});
```

**Client-side migration trigger:**
```typescript
// In useTaskDetail.ts or TaskDescriptionEditor
useEffect(() => {
  if (!editor || !provider || !task) return;

  // Check if Yjs document is empty (no migration yet)
  const isEmpty = editor.document.length === 0 ||
    (editor.document.length === 1 && editor.document[0].type === "paragraph" && !editor.document[0].content);

  // If Yjs empty but Convex has description, migrate
  if (isEmpty && task.description) {
    try {
      const blocks = JSON.parse(task.description);
      editor.replaceBlocks(editor.document, blocks);
      // Trigger mutation to clear Convex description (marks as migrated)
      void migrateMutation({ taskId: task._id });
    } catch (err) {
      console.error("Migration failed:", err);
    }
  }
}, [editor, provider, task]);
```

**Why:** Preserves existing user data during production migration while avoiding dual storage complexity. Client-side migration leverages BlockNote's existing JSON handling and Yjs auto-sync. One-way migration (Convex → Yjs) prevents conflicts.

### Pattern 4: Multiple Concurrent Task Editors (Sheet + Full-Page)
**What:** Support multiple task editors for same task (e.g., user opens full-page view while sheet is open)
**When to use:** Always - users may have multiple views of same task
**Example:**
```typescript
// Both TaskDetailSheet and Task (full-page) use same collaboration hook
// Yjs handles concurrent editors automatically - they share same Y.Doc

function TaskDetailSheet({ taskId, ... }) {
  const viewer = useQuery(api.users.viewer);
  const { editor, isConnected, provider } = useTaskCollaboration({
    taskId,
    userName: viewer?.name ?? "Anonymous",
    userId: viewer?._id ?? "anonymous",
  });

  const { remoteUsers } = useCursorAwareness(provider?.awareness ?? null);

  return (
    <Sheet>
      <div className="flex items-center gap-2">
        <ConnectionStatus isConnected={isConnected} provider={provider} />
        <ActiveUsers remoteUsers={remoteUsers} currentUser={...} />
      </div>
      <TaskDescriptionEditor editor={editor} ... />
    </Sheet>
  );
}
```

**Why:** Yjs CRDTs handle concurrent edits from same user in multiple windows/tabs. `useYjsProvider` creates separate provider instances but connects to same PartyKit room. IndexedDB persistence shared across tabs (same origin). This is proven behavior from document editors (Phase 12).

### Pattern 5: Remove Convex Description Field After Migration
**What:** Schema change to remove `description` field from tasks table
**When to use:** After migration complete (all tasks migrated to Yjs)
**Example:**
```typescript
// convex/schema.ts - BEFORE
tasks: defineTable({
  // ...
  description: v.optional(v.string()), // BlockNote JSON content stored as string
  // ...
})

// convex/schema.ts - AFTER (Phase 13.2)
tasks: defineTable({
  // ...
  // description field REMOVED - content lives in PartyKit/Yjs only
  // ...
})
```

**Convex mutations updated:**
```typescript
// convex/tasks.ts - BEFORE
export const update = mutation({
  args: {
    taskId: v.id("tasks"),
    description: v.optional(v.string()), // REMOVE THIS
    // ...
  },
  handler: async (ctx, { taskId, description, ... }) => {
    // ...
    await ctx.db.patch(taskId, { description, ... }); // REMOVE description
  },
});

// convex/tasks.ts - AFTER
export const update = mutation({
  args: {
    taskId: v.id("tasks"),
    // description removed from args
    // ...
  },
  handler: async (ctx, { taskId, ... }) => {
    // description no longer patched
    await ctx.db.patch(taskId, { ... });
  },
});
```

**Why:** Same rationale as Phase 12 document migration - single source of truth (PartyKit/Yjs), eliminates sync conflicts, reduces Convex storage costs, enables offline editing with IndexedDB.

### Anti-Patterns to Avoid
- **Keeping description field in Convex alongside Yjs:** Creates dual storage, sync conflicts, complexity. Phase 12 established Yjs as single source of truth for content.
- **Building task-specific Yjs provider logic:** Duplicates proven code from `useDocumentCollaboration`. Reuse with different schema instead.
- **Creating new Y.Doc per render:** Memory leaks. Use `useMemo(() => new Y.Doc(), [taskId])` pattern from existing hooks.
- **Skipping migration for production:** Users lose existing task descriptions. Acceptable for dev, not for production.
- **Implementing custom debounced save logic:** Yjs auto-saves to PartyKit, IndexedDB persists locally. No manual save needed after migration.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Task-specific Yjs setup | Custom task collaboration hook from scratch | Reuse `useDocumentCollaboration` with task schema | Pattern proven in documents, only schema differs |
| Description migration logic | Custom migration service, API endpoints | Client-side migration on first editor load | Simpler, leverages BlockNote JSON utilities, no new API surface |
| Multiple editor coordination | Custom synchronization between sheet + full-page | Yjs CRDT automatic sync | Yjs handles concurrent editors, same room = same state |
| Permission verification | Task-specific auth logic in PartyKit | Extend existing `collaboration.getCollaborationToken` | Reuses project membership checks, consistent with doc/diagram pattern |
| Offline persistence | Custom local storage for task descriptions | y-indexeddb (already integrated) | Already handles offline editing for documents, same for tasks |

**Key insight:** Phases 11-12 built reusable collaboration infrastructure. Phase 13.2 is primarily integration work (connecting existing hooks to task editors) rather than new infrastructure. Focus effort on migration strategy and removing manual save logic.

## Common Pitfalls

### Pitfall 1: Not Removing Debounced Auto-Save Logic
**What goes wrong:** `useTaskDetail` currently has 500ms debounced `handleDescriptionChange` that saves to Convex. After Yjs migration, this creates conflicts - Yjs syncs live, debounced save overwrites with stale data.
**Why it happens:** Migration focuses on adding Yjs but forgets to remove old save logic. Both systems run simultaneously, creating race conditions.
**How to avoid:** Delete `descriptionTimeoutRef`, `handleDescriptionChange`, and all `updateTask({ description })` calls. Yjs handles sync automatically. Update `TaskDescriptionEditor` to remove `onChange` prop entirely.
**Warning signs:** Users report "my edits disappear after typing," "content reverts after 500ms," "duplicate cursors."

### Pitfall 2: Forgetting to Update PartyKit Server for Task ResourceType
**What goes wrong:** Client requests token with `resourceType: "task"` but PartyKit `onBeforeConnect` only handles "doc" and "diagram". Connection rejected with 403 Unauthorized.
**Why it happens:** New resourceType added to client but server not updated. Room naming works (`task-{id}`) but permission verification fails.
**How to avoid:** Update `partykit/server.ts` onBeforeConnect to parse `task-*` rooms and verify project membership via Convex query. Add `resourceType: "task"` to `getCollaborationToken` action in `convex/collaboration.ts`.
**Warning signs:** Console errors "Unauthorized: Unknown resource type," "Failed to connect to collaboration server," users can't see each other's cursors.

### Pitfall 3: Task Schema Differs from Document Schema (Custom Inline Content)
**What goes wrong:** Task descriptions use different custom inline content types than documents (e.g., `projectReference` in tasks but not in documents). If schema mismatch between client and server, Yjs fails to serialize custom nodes.
**Why it happens:** `taskDescriptionSchema` defines custom inline content (`diagramEmbed`, `documentLink`, `userMention`, `projectReference`) that must serialize correctly with Yjs. If BlockNote Yjs integration doesn't understand custom specs, content loss occurs.
**How to avoid:** Test migration with all custom inline content types. Verify `taskDescriptionSchema` follows BlockNote `createReactInlineContentSpec` pattern (it does - verified in code). Test: insert custom content, reload page, verify content restored from IndexedDB.
**Warning signs:** Custom inline content (mentions, diagram embeds) disappear after reload, show as plain text instead of React components.

### Pitfall 4: IndexedDB Cache Key Conflicts Between Tasks and Documents
**What goes wrong:** `IndexeddbPersistence` uses cache key `doc-{resourceId}`. If taskId conflicts with documentId (both use Convex IDs), cache collision occurs.
**Why it happens:** Reusing `useDocumentCollaboration` which hardcodes `doc-${documentId}` cache key. Tasks need separate namespace.
**How to avoid:** Update `useDocumentCollaboration` to accept optional `cachePrefix` parameter, or create `useTaskCollaboration` wrapper that uses `task-${taskId}` prefix. Check existing code - `use-document-collaboration.ts` line 52 uses `doc-${documentId}`, needs parameterization.
**Warning signs:** Opening task shows document content, cache size grows unexpectedly, content from wrong resource appears in editor.

### Pitfall 5: Migration Runs on Every Editor Load (Infinite Loop)
**What goes wrong:** Client-side migration checks if Yjs empty, loads Convex description, inserts blocks. But if mutation to clear `task.description` fails, migration runs again on next load, creating duplicate content.
**Why it happens:** Migration logic doesn't verify Convex description cleared before running again. Network failures or mutation errors leave `task.description` populated.
**How to avoid:** Add migration state tracking - either check Convex `description` is null before migrating, or add `migrated: boolean` flag to tasks table. Ensure mutation to clear description is idempotent and retries on failure.
**Warning signs:** Task content duplicates on page reload, console shows "migrating task description" repeatedly, Yjs document grows unbounded.

### Pitfall 6: Full-Page Task View Missing Collaboration UI
**What goes wrong:** TaskDetailSheet gets collaboration (ActiveUsers, ConnectionStatus) but full-page task view (`/tasks/{taskId}` route) doesn't. Users confused why collaboration only works in sheet.
**Why it happens:** Phase focuses on TaskDetailSheet, forgets about full-page route. Both views should have feature parity.
**How to avoid:** Audit all task editor locations - TaskDetailSheet, full-page Task component, potentially task cards in kanban view (if editable). Add collaboration UI to all editing contexts.
**Warning signs:** User reports "collaboration works in popup but not on task page," missing ActiveUsers component in full-page view.

## Code Examples

Verified patterns from official sources and existing codebase:

### Task Collaboration Hook (Reusing Document Pattern)
```typescript
// src/hooks/use-task-collaboration.ts
import { BlockNoteSchema, BlockSchema, InlineContentSchema, StyleSchema } from "@blocknote/core";
import { useDocumentCollaboration, UseDocumentCollaborationOptions } from "./use-document-collaboration";

export interface UseTaskCollaborationOptions<
  BSchema extends BlockSchema,
  ISchema extends InlineContentSchema,
  SSchema extends StyleSchema,
> extends Omit<UseDocumentCollaborationOptions<BSchema, ISchema, SSchema>, 'documentId'> {
  taskId: string;
}

export function useTaskCollaboration<
  BSchema extends BlockSchema,
  ISchema extends InlineContentSchema,
  SSchema extends StyleSchema,
>({
  taskId,
  ...options
}: UseTaskCollaborationOptions<BSchema, ISchema, SSchema>) {
  // Reuse document collaboration hook with task-specific ID
  return useDocumentCollaboration({
    ...options,
    documentId: taskId, // PartyKit room will be task-{taskId}
  });
}
```

**Source:** Adapted from `src/hooks/use-document-collaboration.ts` (Phase 12)

### Updated useTaskDetail with Collaboration
```typescript
// src/pages/App/Project/useTaskDetail.ts
import { useTaskCollaboration } from "../../../hooks/use-task-collaboration";
import { taskDescriptionSchema } from "./taskDescriptionSchema";

export function useTaskDetail({ taskId, ... }) {
  const task = useQuery(api.tasks.get, taskId ? { taskId } : "skip");
  const currentUser = useQuery(api.users.viewer);

  // BEFORE (Phase 2): Local-only editor with debounced save
  // const editor = useCreateBlockNote({ schema: taskDescriptionSchema });
  // const descriptionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  // const handleDescriptionChange = () => { /* debounced save */ };

  // AFTER (Phase 13.2): Collaborative editor
  const { editor, isConnected, provider, isLoading } = useTaskCollaboration({
    taskId: taskId ?? "",
    userName: currentUser?.name ?? "Anonymous",
    userId: currentUser?._id ?? "anonymous",
    schema: taskDescriptionSchema,
  });

  // REMOVED: descriptionTimeoutRef, handleDescriptionChange, editor loading logic
  // Yjs handles sync automatically, no manual save needed

  return {
    task,
    editor,
    isConnected,
    provider,
    isLoading,
    // ... other fields
  };
}
```

**Source:** Adapted from existing `src/pages/App/Project/useTaskDetail.ts` (Phase 2)

### TaskDetailSheet with Collaboration UI
```typescript
// src/pages/App/Project/TaskDetailSheet.tsx
import { ActiveUsers } from "../../Document/ActiveUsers";
import { ConnectionStatus } from "../../Document/ConnectionStatus";
import { useCursorAwareness } from "../../../hooks/use-cursor-awareness";
import { getUserColor } from "../../../lib/user-colors";

export function TaskDetailSheet({ taskId, ... }) {
  const { editor, isConnected, provider, currentUser } = useTaskDetail({ taskId, ... });
  const { remoteUsers } = useCursorAwareness(provider?.awareness ?? null);

  if (isLoading || !editor) {
    return <LoadingSpinner />;
  }

  return (
    <Sheet>
      <SheetContent>
        {/* Add collaboration UI in header */}
        <div className="absolute top-4 right-14 flex items-center gap-2">
          <ConnectionStatus isConnected={isConnected} provider={provider} />
          <ActiveUsers
            remoteUsers={remoteUsers}
            currentUser={
              currentUser
                ? {
                    name: currentUser.name,
                    color: getUserColor(currentUser._id),
                  }
                : undefined
            }
          />
        </div>

        <SheetTitle>Task Details</SheetTitle>

        <TaskDescriptionEditor
          editor={editor}
          // REMOVED: onChange prop (no manual save)
          documents={...}
          diagrams={...}
          members={...}
        />
      </SheetContent>
    </Sheet>
  );
}
```

**Source:** Adapted from `src/pages/App/Document/DocumentEditor.tsx` (Phase 12) + existing TaskDetailSheet

### Convex Token Generation for Task ResourceType
```typescript
// convex/collaboration.ts
export const getCollaborationToken = action({
  args: {
    resourceType: v.union(
      v.literal("doc"),
      v.literal("diagram"),
      v.literal("task") // ADD THIS
    ),
    resourceId: v.string(),
  },
  returns: v.object({
    token: v.string(),
    roomId: v.string(),
  }),
  handler: async (ctx, { resourceType, resourceId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Verify permissions based on resourceType
    if (resourceType === "task") {
      const task = await ctx.runQuery(internal.tasks.getById, {
        id: resourceId as Id<"tasks">,
      });
      if (!task) throw new Error("Task not found");

      // Check project membership via projectMembers.by_project_user index
      const member = await ctx.db
        .query("projectMembers")
        .withIndex("by_project_user", (q) =>
          q.eq("projectId", task.projectId).eq("userId", userId)
        )
        .first();

      if (!member) throw new Error("No access to task's project");
    }
    // ... existing doc/diagram logic ...

    const roomId = `${resourceType}-${resourceId}`;
    const token = (await ctx.auth.getUserIdentity())?.tokenIdentifier || "";
    return { token, roomId };
  },
});
```

**Source:** Adapted from existing `convex/collaboration.ts` (Phase 11)

### Client-Side Migration from Convex to Yjs
```typescript
// src/pages/App/Project/useTaskDetail.ts
const migrateMutation = useMutation(api.tasks.clearDescription);

useEffect(() => {
  if (!editor || !provider || !task || !taskId) return;

  // Wait for provider to sync (avoid racing with initial load)
  if (!provider.synced) return;

  // Check if Yjs document is empty (no content migrated yet)
  const isEmpty = editor.document.length === 0 ||
    (editor.document.length === 1 &&
     editor.document[0].type === "paragraph" &&
     (!editor.document[0].content || editor.document[0].content.length === 0));

  // If Yjs empty AND Convex has description, migrate once
  if (isEmpty && task.description) {
    console.log(`Migrating task ${taskId} description from Convex to Yjs`);

    try {
      const blocks = JSON.parse(task.description);

      // Insert blocks into editor (syncs to Yjs automatically via provider)
      editor.replaceBlocks(editor.document, blocks);

      // Clear Convex description to mark as migrated (prevents re-migration)
      void migrateMutation({ taskId });
    } catch (err) {
      console.error("Task description migration failed:", err);
    }
  }
}, [editor, provider, provider?.synced, task, taskId, migrateMutation]);
```

**Source:** Pattern from Phase 12 document migration discussion, adapted for tasks

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Local BlockNote editing | Yjs collaborative editing | Phase 13.2 | Multi-user real-time collaboration in task descriptions, live cursors, presence awareness |
| Convex stores task descriptions | PartyKit stores task descriptions | Phase 13.2 | Consistent with documents/diagrams, offline editing via IndexedDB, Convex becomes metadata-only |
| 500ms debounced auto-save | Yjs automatic sync | Phase 13.2 | No save latency, live updates, no manual save logic needed |
| Task-specific editor logic | Reuse document collaboration hooks | Phase 13.2 | Less code duplication, consistent patterns, easier maintenance |

**Deprecated/outdated:**
- Task description debounced save (500ms timeout in `useTaskDetail`) - Remove after Yjs migration
- Convex `tasks.description` field mutations - Remove after migration complete
- TaskDescriptionEditor `onChange` callback - Yjs handles sync automatically

## Open Questions

1. **Full-page task view implementation**
   - What we know: TaskDetailSheet exists and is primary edit location. May have full-page task view at `/tasks/{taskId}` route.
   - What's unclear: Does full-page task view exist? If so, does it have separate editor instance?
   - Recommendation: Audit routes for task detail pages. If full-page view exists, apply same collaboration pattern. If not, document that only sheet is collaborative (acceptable for v1).

2. **Migration strategy: wipe vs preserve**
   - What we know: Phase 12 wiped all document content (early development, acceptable). Tasks may have more established content.
   - What's unclear: How much existing task data exists in production? Is it acceptable to lose descriptions?
   - Recommendation: Implement client-side migration (preserves data). Dev environment can wipe. Production runs migration on first load. If migration fails, fallback to empty description (log error, notify user).

3. **IndexedDB cache key conflicts**
   - What we know: `useDocumentCollaboration` uses `doc-${documentId}` cache key. Convex IDs are globally unique across tables.
   - What's unclear: Could taskId collide with documentId (both use same ID format)?
   - Recommendation: Convex IDs are table-scoped with unique identifiers. Collision risk is near-zero. If paranoid, use `task-${taskId}` prefix for clarity. Check existing code to see if `use-document-collaboration` already uses resource-specific prefix.

4. **Awareness cursor rendering in BlockNote**
   - What we know: Documents use BlockNote with Yjs, cursors render automatically via collaboration option. Phase 12 implemented custom cursor styling.
   - What's unclear: Does BlockNote handle cursor rendering out-of-box, or did Phase 12 add custom overlay?
   - Recommendation: Review Phase 12 implementation. If BlockNote built-in cursors work, reuse. If custom overlay needed, copy pattern from DocumentEditor.

## Sources

### Primary (HIGH confidence)
- BlockNote Collaboration Docs: https://www.blocknotejs.org/docs/features/collaboration (Yjs integration, collaboration option)
- Existing codebase: `src/hooks/use-document-collaboration.ts` (Phase 12 implementation)
- Existing codebase: `src/hooks/use-yjs-provider.ts` (Phase 11 infrastructure)
- Existing codebase: `src/pages/App/Project/taskDescriptionSchema.ts` (Custom schema for tasks)
- Existing codebase: `convex/tasks.ts` (Current description field handling)
- Phase 12 Research: `.planning/phases/12-document-multiplayer-cursors-yjs-migration/12-RESEARCH.md`
- Phase 11 Research: `.planning/phases/11-partykit-infrastructure-persistence/11-RESEARCH.md`

### Secondary (MEDIUM confidence)
- BlockNote Yjs Utilities: https://www.blocknotejs.org/docs/reference/editor/yjs-utilities (Migration helpers)
- Context7 BlockNote docs: `/websites/blocknotejs` (Collaboration examples)

### Tertiary (LOW confidence - informational only)
- None - all findings verified against existing codebase and official docs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All packages already installed and proven in Phases 11-12
- Architecture: HIGH - Patterns directly copied from working document collaboration (Phase 12)
- Migration strategy: MEDIUM - Client-side migration pattern inferred from Phase 12 discussion, not explicitly implemented yet
- Pitfalls: HIGH - Identified from existing code patterns (debounced save removal, schema conflicts from taskDescriptionSchema)

**Research date:** 2026-02-12
**Valid until:** 2026-03-14 (30 days - stable ecosystem, reusing existing infrastructure)

**Phase 11-12 foundation:** PartyKit server deployed with Yjs persistence and authentication, `useYjsProvider` and `useDocumentCollaboration` hooks production-ready, ColorHash singleton for consistent user colors, ActiveUsers and ConnectionStatus components built and tested. Phase 13.2 is integration work, not new infrastructure.

**Key unknowns requiring validation during planning/execution:**
1. Full-page task view existence and editor requirements
2. Production task description data volume (impacts migration strategy)
3. IndexedDB cache key naming in `useDocumentCollaboration` (may need refactoring for tasks)
4. Current status of task description auto-save logic (verify 500ms debounce still exists)
