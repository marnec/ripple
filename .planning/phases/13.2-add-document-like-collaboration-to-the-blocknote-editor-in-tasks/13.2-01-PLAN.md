---
phase: 13.2-add-document-like-collaboration-to-the-blocknote-editor-in-tasks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/collaboration.ts
  - convex/tasks.ts
  - src/hooks/use-yjs-provider.ts
  - src/hooks/use-document-collaboration.ts
autonomous: true

must_haves:
  truths:
    - "Task collaboration tokens can be generated and verified for authenticated project members"
    - "useDocumentCollaboration hook accepts a resourceType parameter so tasks use task-prefixed cache keys and room names"
    - "A clearDescription mutation exists for post-migration cleanup of Convex description field"
  artifacts:
    - path: "convex/collaboration.ts"
      provides: "Task resource type in getCollaborationToken + checkTaskAccess internal query"
      contains: "v.literal(\"task\")"
    - path: "convex/tasks.ts"
      provides: "clearDescription mutation for post-migration cleanup"
      contains: "clearDescription"
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "Updated ResourceType union to include task"
      contains: "\"task\""
    - path: "src/hooks/use-document-collaboration.ts"
      provides: "Parameterized resourceType for cache key prefix and Yjs provider"
      contains: "resourceType"
  key_links:
    - from: "convex/collaboration.ts"
      to: "convex/collaboration.ts"
      via: "checkTaskAccess internal query for task permission check"
      pattern: "internal\\.collaboration\\.checkTaskAccess"
    - from: "src/hooks/use-document-collaboration.ts"
      to: "src/hooks/use-yjs-provider.ts"
      via: "resourceType parameter passed through"
      pattern: "resourceType"
---

<objective>
Add "task" resource type support to the collaboration backend and parameterize the document collaboration hook for task reuse.

Purpose: Enable task descriptions to use the same Yjs/PartyKit collaboration infrastructure as documents and diagrams. This plan creates the backend token/permission layer and generalizes the frontend collaboration hook so Plan 02 can wire it into the task UI.

Output: Updated collaboration token system supporting tasks, generalized useDocumentCollaboration hook with resourceType parameter, clearDescription mutation for migration.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@convex/collaboration.ts
@convex/tasks.ts
@convex/http.ts
@convex/schema.ts
@src/hooks/use-yjs-provider.ts
@src/hooks/use-document-collaboration.ts
@partykit/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add "task" resource type to collaboration token system</name>
  <files>convex/collaboration.ts, src/hooks/use-yjs-provider.ts</files>
  <action>
1. In `convex/collaboration.ts`:
   - Add `v.literal("task")` to the `resourceType` union in `getCollaborationToken` args (alongside existing "doc" and "diagram").
   - Add a `checkTaskAccess` internal query that checks project membership for a given task:
     ```typescript
     export const checkTaskAccess = internalQuery({
       args: {
         userId: v.id("users"),
         taskId: v.string(),
       },
       returns: v.boolean(),
       handler: async (ctx, { userId, taskId }) => {
         const task = await ctx.db.get(taskId as any);
         if (!task) return false;
         const member = await ctx.db
           .query("projectMembers")
           .withIndex("by_project_user", (q) =>
             q.eq("projectId", task.projectId).eq("userId", userId)
           )
           .first();
         return member !== null;
       },
     });
     ```
   - In the `getCollaborationToken` handler, add an `else if (resourceType === "task")` branch (before the existing `else` for diagram) that calls `checkTaskAccess`:
     ```typescript
     } else if (resourceType === "task") {
       const hasAccess = await ctx.runQuery(internal.collaboration.checkTaskAccess, {
         userId,
         taskId: resourceId,
       });
       if (!hasAccess) {
         throw new ConvexError("You do not have access to this task");
       }
     } else {
       // existing diagram logic
     }
     ```

2. In `src/hooks/use-yjs-provider.ts`, update the `ResourceType` type from `"doc" | "diagram"` to `"doc" | "diagram" | "task"`.

Run `npm run lint` to verify no TypeScript or ESLint errors.
  </action>
  <verify>Run `npm run lint` passes with 0 errors and 0 warnings.</verify>
  <done>getCollaborationToken accepts resourceType "task", verifies project membership via checkTaskAccess, and useYjsProvider accepts "task" as resource type.</done>
</task>

<task type="auto">
  <name>Task 2: Parameterize useDocumentCollaboration for task reuse and add clearDescription mutation</name>
  <files>src/hooks/use-document-collaboration.ts, convex/tasks.ts</files>
  <action>
1. In `src/hooks/use-document-collaboration.ts`:
   - Add `resourceType` as an optional parameter to `UseDocumentCollaborationOptions` interface, defaulting to `"doc"`. Type it as `"doc" | "diagram" | "task"`.
   - In the `useYjsProvider` call, pass `resourceType` (from options, default `"doc"`) instead of the hardcoded `"doc"`.
   - In the `IndexeddbPersistence` constructor (line 52), change the cache key from `\`doc-${documentId}\`` to `\`${resourceType ?? "doc"}-${documentId}\`` so tasks get `task-{taskId}` cache keys and documents keep their existing `doc-{documentId}` keys.
   - In `useCreateBlockNote`, the `fragment` key `"document-store"` can stay the same (it's scoped per Y.Doc which is per resourceId, so no collision).

   The interface change:
   ```typescript
   export interface UseDocumentCollaborationOptions<...> {
     documentId: string;
     userName: string;
     userId: string;
     schema: BlockNoteSchema<BSchema, ISchema, SSchema>;
     resourceType?: "doc" | "diagram" | "task"; // NEW - defaults to "doc"
   }
   ```

   Inside the function body, destructure resourceType with default:
   ```typescript
   const { documentId, userName, userId, schema, resourceType = "doc" } = ...;
   ```

   Pass to useYjsProvider:
   ```typescript
   const { yDoc, provider, isConnected, isLoading: providerLoading } = useYjsProvider({
     resourceType, // was hardcoded "doc"
     resourceId: documentId,
   });
   ```

   Update IndexedDB key:
   ```typescript
   const persistence = new IndexeddbPersistence(`${resourceType}-${documentId}`, yDoc);
   ```

2. In `convex/tasks.ts`, add a `clearDescription` public mutation for the client-side migration to call after copying content to Yjs:
   ```typescript
   export const clearDescription = mutation({
     args: { taskId: v.id("tasks") },
     returns: v.null(),
     handler: async (ctx, { taskId }) => {
       const userId = await getAuthUserId(ctx);
       if (!userId) throw new ConvexError("Not authenticated");

       const task = await ctx.db.get(taskId);
       if (!task) throw new ConvexError("Task not found");

       // Auth: validate membership
       const membership = await ctx.db
         .query("projectMembers")
         .withIndex("by_project_user", (q) =>
           q.eq("projectId", task.projectId).eq("userId", userId)
         )
         .first();
       if (!membership) throw new ConvexError("Not a member of this project");

       // Clear the description field (content now lives in Yjs/PartyKit)
       await ctx.db.patch(taskId, { description: undefined });
       return null;
     },
   });
   ```

Run `npm run lint` to verify.
  </action>
  <verify>Run `npm run lint` passes with 0 errors and 0 warnings. Verify that the existing DocumentEditor.tsx still works by checking it doesn't pass `resourceType` (it shouldn't need to since the default is "doc").</verify>
  <done>useDocumentCollaboration accepts optional resourceType parameter (defaulting to "doc") that flows through to useYjsProvider and IndexedDB cache key prefix. clearDescription mutation available for migration.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with 0 errors
2. `npm run build` succeeds
3. Grep confirms: `v.literal("task")` appears in convex/collaboration.ts
4. Grep confirms: `resourceType` parameter in UseDocumentCollaborationOptions interface
5. Grep confirms: `clearDescription` mutation in convex/tasks.ts
6. Grep confirms: `"task"` in ResourceType union in use-yjs-provider.ts
</verification>

<success_criteria>
- Collaboration token system supports "task" resource type with project membership verification
- useDocumentCollaboration accepts resourceType parameter, defaulting to "doc" for backward compatibility
- IndexedDB cache keys use resource-type prefix (task-{id}, doc-{id}) to prevent collisions
- clearDescription mutation exists for post-migration Convex cleanup
- All existing document/diagram collaboration is unaffected (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/13.2-add-document-like-collaboration-to-the-blocknote-editor-in-tasks/13.2-01-SUMMARY.md`
</output>
