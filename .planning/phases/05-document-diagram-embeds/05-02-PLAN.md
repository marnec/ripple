---
phase: 05-document-diagram-embeds
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/pages/App/Project/TaskDetailSheet.tsx
  - src/pages/App/Project/TaskDetailPage.tsx
autonomous: true

must_haves:
  truths:
    - "User can type # in task description to see combined autocomplete with documents, diagrams, and projects"
    - "User can type @ in task description to see project members for @mention"
    - "Inserting a diagram via # creates inline preview with SVG rendering"
    - "Inserting a document via # creates clickable link with document icon"
    - "Inserting a project via # creates colored chip with project dot"
    - "Inserting a user via @ creates bold text @mention"
    - "Autocomplete items show appropriate icons (PenTool for diagrams, FileText for documents, FolderKanban for projects, Avatar for users)"
    - "Task description content with inline content types persists correctly through save/reload cycle"
  artifacts:
    - path: "src/pages/App/Project/TaskDetailSheet.tsx"
      provides: "Task detail sheet with custom schema, # and @ autocomplete"
    - path: "src/pages/App/Project/TaskDetailPage.tsx"
      provides: "Task detail full page with same custom schema and autocomplete"
  key_links:
    - from: "src/pages/App/Project/TaskDetailSheet.tsx"
      to: "src/pages/App/Project/taskDescriptionSchema.ts"
      via: "import taskDescriptionSchema"
      pattern: "taskDescriptionSchema"
    - from: "src/pages/App/Project/TaskDetailSheet.tsx"
      to: "SuggestionMenuController"
      via: "# trigger for docs/diagrams/projects, @ trigger for users"
      pattern: "SuggestionMenuController.*triggerCharacter"
---

<objective>
Upgrade TaskDetailSheet and TaskDetailPage to use the custom task description schema with `#` and `@` autocomplete controllers, enabling users to embed diagrams, link documents, @mention users, and reference projects in task descriptions.

Purpose: This is the primary user-facing integration. After this plan, users can insert all four reference types directly in task descriptions.

Output: Two modified files (TaskDetailSheet.tsx, TaskDetailPage.tsx) with custom schema and dual autocomplete.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-diagram-embeds/05-CONTEXT.md
@.planning/phases/05-document-diagram-embeds/05-RESEARCH.md
@.planning/phases/05-document-diagram-embeds/05-01-SUMMARY.md

# Key files to reference:
@src/pages/App/Project/TaskDetailSheet.tsx
@src/pages/App/Project/TaskDetailPage.tsx
@src/pages/App/Project/taskDescriptionSchema.ts
@src/pages/App/Chat/MessageComposer.tsx
@src/pages/App/Document/DocumentEditor.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade TaskDetailSheet with custom schema and autocomplete</name>
  <files>
    src/pages/App/Project/TaskDetailSheet.tsx
  </files>
  <action>
Modify `TaskDetailSheet.tsx` to use the custom task description schema and add `#` and `@` autocomplete.

**Schema change:**
- Replace `import { useCreateBlockNote } from "@blocknote/react"` with `import { useCreateBlockNote, SuggestionMenuController } from "@blocknote/react"`
- Import `taskDescriptionSchema` from `./taskDescriptionSchema`
- Change `const editor = useCreateBlockNote({})` to `const editor = useCreateBlockNote({ schema: taskDescriptionSchema })`

**Data queries for autocomplete (add these inside the component):**
- `const diagrams = useQuery(api.diagrams.list, { workspaceId });` — all workspace diagrams for `#`
- `const documents = useQuery(api.documents.listByUserMembership, { workspaceId });` — user's accessible docs for `#`
- `const projects = useQuery(api.projects.listByUserMembership, { workspaceId });` — user's projects for `#`
- `members` already queried (for assignee dropdown) — reuse for `@` autocomplete

**Add SuggestionMenuController components inside BlockNoteView:**

Replace the bare `<BlockNoteView>` with:
```tsx
<BlockNoteView
  editor={editor}
  onChange={handleDescriptionChange}
  theme={resolvedTheme === "dark" ? "dark" : "light"}
>
  <SuggestionMenuController
    triggerCharacter={"#"}
    getItems={async (query) => {
      const items: Array<{title: string; onItemClick: () => void; icon: React.ReactNode; group: string; key: string}> = [];

      // Documents
      if (documents) {
        documents
          .filter(doc => doc.name.toLowerCase().includes(query.toLowerCase()))
          .slice(0, 5)
          .forEach(doc => {
            items.push({
              title: doc.name,
              onItemClick: () => {
                editor.insertInlineContent([
                  { type: "documentLink", props: { documentId: doc._id } },
                  " ",
                ]);
              },
              icon: <FileText className="h-4 w-4" />,
              group: "Documents",
              key: `doc-${doc._id}`,
            });
          });
      }

      // Diagrams
      if (diagrams) {
        diagrams
          .filter(d => d.name.toLowerCase().includes(query.toLowerCase()))
          .slice(0, 5)
          .forEach(d => {
            items.push({
              title: d.name,
              onItemClick: () => {
                editor.insertInlineContent([
                  { type: "diagramEmbed", props: { diagramId: d._id } },
                  " ",
                ]);
              },
              icon: <PenTool className="h-4 w-4" />,
              group: "Diagrams",
              key: `dia-${d._id}`,
            });
          });
      }

      // Projects
      if (projects) {
        projects
          .filter(p => p.name.toLowerCase().includes(query.toLowerCase()))
          .slice(0, 5)
          .forEach(p => {
            items.push({
              title: p.name,
              onItemClick: () => {
                editor.insertInlineContent([
                  { type: "projectReference", props: { projectId: p._id } },
                  " ",
                ]);
              },
              icon: <FolderKanban className="h-4 w-4" />,
              group: "Projects",
              key: `proj-${p._id}`,
            });
          });
      }

      return items;
    }}
  />
  <SuggestionMenuController
    triggerCharacter={"@"}
    getItems={async (query) => {
      if (!members) return [];
      return members
        .filter(m => m.name?.toLowerCase().includes(query.toLowerCase()))
        .slice(0, 10)
        .map(m => ({
          title: m.name ?? "Unknown",
          onItemClick: () => {
            editor.insertInlineContent([
              { type: "userMention", props: { userId: m.userId } },
              " ",
            ]);
          },
          icon: (
            <Avatar className="h-5 w-5">
              {m.image && <AvatarImage src={m.image} />}
              <AvatarFallback className="text-xs">
                {m.name?.slice(0, 2).toUpperCase() ?? "?"}
              </AvatarFallback>
            </Avatar>
          ),
          group: "Project members",
          key: m.userId,
        }));
    }}
  />
</BlockNoteView>
```

**Add necessary imports:**
- `PenTool`, `FileText`, `FolderKanban` from `lucide-react`
- `SuggestionMenuController` from `@blocknote/react`
- `taskDescriptionSchema` from `./taskDescriptionSchema`

**Important detail:** The `useCreateBlockNote` must use `useMemo` for the config to avoid re-creating the editor on every render. Wrap the schema config:
```tsx
const editorConfig = useMemo(() => ({ schema: taskDescriptionSchema }), []);
const editor = useCreateBlockNote(editorConfig);
```
Actually, `useCreateBlockNote` already handles memoization internally. Just pass `{ schema: taskDescriptionSchema }` directly. But check if the existing code passes `{}` — it does. Just change it to `{ schema: taskDescriptionSchema }`.

**Schema compatibility note:** When loading existing task descriptions that were saved with the default schema (no custom inline content), the JSON will parse fine since the custom inline content types simply weren't present. No migration needed.
  </action>
  <verify>
1. `npm run lint` passes with zero warnings
2. Open a task detail sheet in the browser
3. Type `#` in the description — autocomplete should appear with documents, diagrams, and projects grouped
4. Type `@` in the description — autocomplete should appear with project members
5. Select items from autocomplete — they should render correctly inline
  </verify>
  <done>
TaskDetailSheet uses custom schema with all four inline content types. `#` triggers combined autocomplete for documents/diagrams/projects. `@` triggers user mention autocomplete scoped to project members. All inserted content renders correctly and persists through save/reload.
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade TaskDetailPage with same custom schema and autocomplete</name>
  <files>
    src/pages/App/Project/TaskDetailPage.tsx
  </files>
  <action>
Apply the same changes to `TaskDetailPage.tsx` as Task 1 applied to `TaskDetailSheet.tsx`. The two files are structurally very similar (copy of sheet logic in full-page layout).

**Changes mirror Task 1:**
1. Import `SuggestionMenuController` from `@blocknote/react`
2. Import `taskDescriptionSchema` from `./taskDescriptionSchema`
3. Import `PenTool`, `FileText`, `FolderKanban` from `lucide-react`
4. Change `useCreateBlockNote({})` to `useCreateBlockNote({ schema: taskDescriptionSchema })`
5. Add same data queries: `diagrams`, `documents`, `projects` (members already queried)
6. Wrap `BlockNoteView` with the same two `SuggestionMenuController` components (# and @)

**The autocomplete logic is identical** — same getItems functions, same insertion patterns. The only difference is the containing layout (full page vs sheet).

Make sure the BlockNoteView in the full page also gets the two SuggestionMenuController children.
  </action>
  <verify>
1. `npm run lint` passes with zero warnings
2. Navigate to a task full page view
3. Type `#` — autocomplete appears with docs/diagrams/projects
4. Type `@` — autocomplete appears with project members
5. Verify inserted inline content renders the same as in TaskDetailSheet
  </verify>
  <done>
TaskDetailPage has identical custom schema and autocomplete capabilities as TaskDetailSheet. Both views support all four inline content types with consistent behavior.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero warnings
2. Both TaskDetailSheet and TaskDetailPage use `taskDescriptionSchema`
3. `#` autocomplete shows three groups: Documents, Diagrams, Projects
4. `@` autocomplete shows project members
5. Inserted diagram renders as SVG preview (not interactive)
6. Inserted document shows icon + title with clickable link
7. Inserted user mention shows bold @name text
8. Inserted project reference shows colored chip
9. Content persists after saving and reloading the editor
</verification>

<success_criteria>
- TaskDetailSheet and TaskDetailPage both use custom schema with four inline content types
- `#` triggers combined autocomplete with three entity groups
- `@` triggers project member autocomplete
- All autocomplete items use correct icons (PenTool, FileText, FolderKanban, Avatar)
- Inserted content renders correctly in editor
- Content saves and loads without data loss
- Existing task descriptions without custom inline content still load correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-diagram-embeds/05-02-SUMMARY.md`
</output>
