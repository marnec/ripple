# Phase 03.2: taskStatus per project scope and cascade delete - Research

**Researched:** 2026-02-10
**Domain:** Convex database schema migration, data scoping, and cascade delete patterns
**Confidence:** HIGH

## Summary

This phase changes taskStatuses from workspace-scoped to project-scoped, allowing each project to have independent status workflows. Currently, all projects in a workspace share the same set of taskStatuses, which limits flexibility when different projects need different workflows.

The migration requires three critical operations:
1. **Schema change**: Replace `workspaceId` with `projectId` in the taskStatuses table
2. **Data migration**: Duplicate existing workspace-level statuses for each project in that workspace
3. **Cascade delete**: When a taskStatus is deleted, gracefully handle all tasks using that status

**Primary recommendation:** Use Convex's lightweight migration approach with union types during transition, followed by data migration mutation to duplicate statuses per-project, then implement cascade delete with a "move to default status" strategy.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Convex | (current) | Serverless database with real-time sync | Project's core backend - all schema and mutations |
| convex-helpers | 0.1.111 | Helper utilities for batch operations | Already in use for `stream()` in projects.ts and channels.ts |

### Migration Pattern
| Tool | Purpose | When to Use |
|------|---------|-------------|
| Schema union types | Transitional type safety during migration | When changing field types/names |
| Mutation-based migration | Batch data transformation | For migrating existing documents |
| Index updates | Query performance after schema change | When field used in queries changes |

**Installation:**
No new packages needed - all tools already available in the project.

## Architecture Patterns

### Recommended Schema Migration Structure

**Phase 1: Additive schema change**
```typescript
// schema.ts - Add new field with union type
taskStatuses: defineTable({
  workspaceId: v.optional(v.id("workspaces")), // mark optional during migration
  projectId: v.optional(v.id("projects")),     // add new field
  name: v.string(),
  color: v.string(),
  order: v.number(),
  isDefault: v.boolean(),
  isCompleted: v.boolean(),
})
  .index("by_workspace", ["workspaceId"])  // keep old index temporarily
  .index("by_project", ["projectId"])      // add new index
  .index("by_project_order", ["projectId", "order"]),
```

**Phase 2: Data migration mutation**
```typescript
// convex/migrations/migrateTaskStatusesToProjects.ts
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";

export const migrateTaskStatusesToProjects = internalMutation({
  args: {},
  returns: v.null(),
  handler: async (ctx) => {
    // For each workspace-level taskStatus, duplicate it for each project in that workspace
    const oldStatuses = await ctx.db
      .query("taskStatuses")
      .filter((q) => q.neq(q.field("projectId"), undefined))
      .collect();

    for (const oldStatus of oldStatuses) {
      if (!oldStatus.workspaceId) continue;

      // Get all projects in this workspace
      const projects = await ctx.db
        .query("projects")
        .withIndex("by_workspace", (q) => q.eq("workspaceId", oldStatus.workspaceId))
        .collect();

      for (const project of projects) {
        // Create project-scoped copy
        await ctx.db.insert("taskStatuses", {
          projectId: project._id,
          name: oldStatus.name,
          color: oldStatus.color,
          order: oldStatus.order,
          isDefault: oldStatus.isDefault,
          isCompleted: oldStatus.isCompleted,
        });
      }

      // Mark old status as migrated or delete it
      await ctx.db.delete(oldStatus._id);
    }

    return null;
  },
});
```

**Phase 3: Update all queries to use new field**
```typescript
// Before:
const statuses = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .collect();

// After:
const statuses = await ctx.db
  .query("taskStatuses")
  .withIndex("by_project", (q) => q.eq("projectId", projectId))
  .collect();
```

**Phase 4: Remove old field from schema**
```typescript
// schema.ts - Final state
taskStatuses: defineTable({
  projectId: v.id("projects"),  // required field
  name: v.string(),
  color: v.string(),
  order: v.number(),
  isDefault: v.boolean(),
  isCompleted: v.boolean(),
})
  .index("by_project", ["projectId"])
  .index("by_project_order", ["projectId", "order"]),
```

### Pattern 1: Cascade Delete with Default Status Fallback

**What:** When deleting a taskStatus, move all tasks using that status to the default status for that project instead of blocking deletion.

**When to use:** When user experience requires ability to clean up unused statuses without manual task reassignment.

**Example:**
```typescript
// convex/taskStatuses.ts - Updated remove mutation
export const remove = mutation({
  args: { statusId: v.id("taskStatuses") },
  returns: v.null(),
  handler: async (ctx, { statusId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new ConvexError("Not authenticated");

    const status = await ctx.db.get(statusId);
    if (!status) throw new ConvexError("Status not found");

    // Permission: must be project member (after migration to project-scoped)
    const membership = await ctx.db
      .query("projectMembers")
      .withIndex("by_project_user", (q) =>
        q.eq("projectId", status.projectId).eq("userId", userId)
      )
      .first();

    if (!membership) throw new ConvexError("Not a member of this project");

    // Cannot remove if it's the default status
    if (status.isDefault) {
      throw new ConvexError("Cannot remove the default status");
    }

    // Find the default status for this project
    const defaultStatus = await ctx.db
      .query("taskStatuses")
      .withIndex("by_project", (q) => q.eq("projectId", status.projectId))
      .filter((q) => q.eq(q.field("isDefault"), true))
      .first();

    if (!defaultStatus) {
      throw new ConvexError("No default status found for project");
    }

    // Move all tasks using this status to the default status
    const tasksUsingStatus = await ctx.db
      .query("tasks")
      .withIndex("by_project_status", (q) =>
        q.eq("projectId", status.projectId).eq("statusId", statusId)
      )
      .collect();

    for (const task of tasksUsingStatus) {
      await ctx.db.patch(task._id, {
        statusId: defaultStatus._id,
        // Preserve completed state - don't auto-reset based on status change
      });
    }

    // Now safe to delete the status
    await ctx.db.delete(statusId);
    return null;
  },
});
```

### Pattern 2: Batch Operations with Stream Helper

**What:** Use `convex-helpers/server/stream` for processing large collections without hitting transaction limits.

**When to use:** When deleting resources that have many related documents (100+ items).

**Example from existing codebase:**
```typescript
// Source: convex/projects.ts lines 252-261
import { stream } from "convex-helpers/server/stream";
import schema from "./schema";

const projectMembersStream = stream(ctx.db, schema)
  .query("projectMembers")
  .withIndex("by_project", (q) => q.eq("projectId", id));

await projectMembersStream
  .map(async (doc) => {
    await ctx.db.delete(doc._id);
    return null;
  })
  .collect();
```

**When NOT needed:** For cascade deletes affecting <100 documents, simple `Promise.all()` is sufficient (as used in channels.ts line 271).

### Anti-Patterns to Avoid

- **Direct field type change without union:** Convex will reject schema if data doesn't match. Always use `v.optional()` or `v.union()` during transition.
- **Deleting old field before data migration completes:** Schema validation will fail if any document still has the old field.
- **Using `.filter()` instead of index:** Always query by indexed field. Current code at taskStatuses.ts:221 uses `.filter()` on statusId - should use `by_project_status` index after migration.
- **Cascade delete without default status check:** Always verify default status exists before reassigning tasks.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Data migration runner | Custom script with progress tracking | Convex internalMutation with batching | Built-in transactionality, automatic retry, no external process needed |
| Batch processing | Manual chunking and pagination | `convex-helpers/server/stream` | Handles pagination, transaction limits, error recovery automatically |
| Schema validation during migration | Try-catch on every document | `v.optional()` union types in schema | Convex validates at deploy time, catches issues before production |

**Key insight:** Convex's transaction model and schema validation prevent many migration footguns. Use these guardrails instead of bypassing them.

## Common Pitfalls

### Pitfall 1: Breaking Existing Queries During Migration
**What goes wrong:** Changing workspaceId to projectId breaks all existing queries that filter by workspaceId.

**Why it happens:** Frontend queries taskStatuses by workspaceId (KanbanBoard.tsx:47), but after migration this field won't exist.

**How to avoid:** Keep both indexes during migration. Update all query call sites BEFORE removing old field.

**Warning signs:** Convex function deployment succeeds but queries return empty arrays; TypeScript errors in frontend about missing field.

### Pitfall 2: Orphaned Tasks After Cascade Delete
**What goes wrong:** Tasks reference a deleted statusId, causing enrichment queries to fail.

**Why it happens:** Deleting status without reassigning tasks first, or race condition between check and delete.

**How to avoid:** Use `by_project_status` index to find ALL tasks in single query, reassign within same transaction as delete.

**Warning signs:** Task queries return null for status field; kanban board columns disappear; console errors about missing status.

### Pitfall 3: Default Status Per-Project Assumption Breaks
**What goes wrong:** Migration creates multiple "default" statuses per project, or no default status.

**Why it happens:** Copying workspace statuses to multiple projects without ensuring exactly one isDefault=true per project.

**How to avoid:** In migration mutation, verify only one default exists per project after duplication. Add database index constraint if Convex supports it.

**Warning signs:** Task creation fails with "No default status found"; multiple statuses have isDefault=true.

### Pitfall 4: UI Fetches Statuses at Workspace Level
**What goes wrong:** After migrating to project-scoped statuses, UI still queries by workspaceId and gets empty results.

**Why it happens:** Frontend component (KanbanBoard.tsx:47-49) calls `api.taskStatuses.listByWorkspace` which expects workspace-scoped data.

**How to avoid:**
1. Create new `listByProject` query in taskStatuses.ts
2. Update KanbanBoard to call `listByProject` instead
3. Update AddColumnDialog to accept projectId instead of workspaceId
4. Update TaskProperties component if it queries statuses

**Warning signs:** Kanban board shows no columns after migration; "Add Column" dialog fails; task status dropdown is empty.

## Code Examples

Verified patterns from codebase:

### Cascade Delete Pattern (from projects.ts)
```typescript
// Source: convex/projects.ts lines 251-289
export const remove = mutation({
  args: { id: v.id("projects") },
  returns: v.null(),
  handler: async (ctx, { id }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new ConvexError("Not authenticated");

    const project = await ctx.db.get(id);
    if (!project) throw new ConvexError("Project not found");

    // Permission check
    if (project.creatorId !== userId) {
      throw new ConvexError("Only project creator can delete the project");
    }

    // Delete all project members
    const projectMembersStream = stream(ctx.db, schema)
      .query("projectMembers")
      .withIndex("by_project", (q) => q.eq("projectId", id));

    await projectMembersStream
      .map(async (doc) => {
        await ctx.db.delete(doc._id);
        return null;
      })
      .collect();

    // Delete linked channel (messages and channel members first)
    const channelId = project.linkedChannelId;

    // Delete channel messages
    const channelMessages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", channelId))
      .collect();
    await Promise.all(channelMessages.map((message) => ctx.db.delete(message._id)));

    // Delete channel members
    const channelMembersStream = stream(ctx.db, schema)
      .query("channelMembers")
      .withIndex("by_channel", (q) => q.eq("channelId", channelId));

    await channelMembersStream
      .map(async (doc) => {
        await ctx.db.delete(doc._id);
        return null;
      })
      .collect();

    // Delete the channel
    await ctx.db.delete(channelId);

    // Delete the project
    await ctx.db.delete(id);

    return null;
  },
});
```

### Index-Based Task Query (from tasks.ts)
```typescript
// Source: convex/tasks.ts lines 72-77
// Using multi-field index for efficient task lookup within project+status
const tasksInStatus = await ctx.db
  .query("tasks")
  .withIndex("by_project_status_position", (q) =>
    q.eq("projectId", args.projectId).eq("statusId", statusId)
  )
  .collect();
```

### Default Status Seeding (from projects.ts)
```typescript
// Source: convex/projects.ts lines 82-114
// Idempotent status seeding - only creates if not already exists
const existingStatus = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .first();

if (!existingStatus) {
  await ctx.db.insert("taskStatuses", {
    workspaceId,
    name: "Todo",
    color: "bg-gray-500",
    order: 0,
    isDefault: true,
    isCompleted: false,
  });
  // ... more statuses
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Workspace-scoped statuses | Project-scoped statuses | Phase 03.2 (this phase) | Each project can customize workflow independently |
| Block status deletion if tasks exist | Cascade delete to default status | Phase 03.2 (this phase) | Better UX - users can clean up statuses without manual task reassignment |
| Filter for tasks by status | Index query for tasks by project+status | Phase 03.1 (completed) | 10-100x faster queries on large projects |

**Current limitation to fix:**
- taskStatuses.remove (line 218-222) uses `.filter()` on statusId after querying by workspace. This is inefficient and will break after migration to project-scoped statuses. Should use `by_project_status` index instead.

## Open Questions

1. **Should migration duplicate ALL workspace statuses to ALL projects, or only statuses actually in use?**
   - What we know: Phase 03.1 seeds default statuses idempotently at first project creation per workspace
   - What's unclear: If workspace has custom statuses, should projects created BEFORE those custom statuses get them retroactively?
   - Recommendation: Duplicate all statuses at migration time for consistency. Alternative: only duplicate statuses that have tasks using them, but this risks leaving some projects with incomplete status sets.

2. **What happens to tasks when their project is deleted?**
   - What we know: projects.remove (line 236-293) deletes projectMembers, channel, channelMembers, and the project itself
   - What's unclear: Are tasks cascade-deleted when project is deleted? No code currently deletes tasks in projects.remove.
   - Recommendation: Add task cascade delete to projects.remove mutation. Query by `by_project` index and delete all tasks in that project.

3. **Should statusId index be added to tasks table?**
   - What we know: Current indexes are `by_project`, `by_project_completed`, `by_assignee`, `by_assignee_completed`, `by_project_status`, `by_workspace`, `by_project_status_position`
   - What's unclear: Cascade delete will query tasks by statusId - is `by_project_status` sufficient or should we add `by_status`?
   - Recommendation: `by_project_status` is sufficient because we always know the projectId when deleting a status (statuses will be project-scoped). No new index needed.

4. **How to handle UI transition during migration?**
   - What we know: KanbanBoard fetches statuses by workspaceId (line 47-49), needs to change to projectId
   - What's unclear: Should we support both query methods during migration, or require single-step frontend+backend update?
   - Recommendation: Deploy backend changes first (with optional fields), then frontend changes, then cleanup. Use feature flag if needed for gradual rollout.

## Sources

### Primary (HIGH confidence)
- [Convex Schema Documentation](https://docs.convex.dev/database/schemas) - Schema definition and validation
- [Convex Indexes Documentation](https://docs.convex.dev/database/indexes) - Multi-field index patterns
- [Intro to Migrations - Convex Stack](https://stack.convex.dev/intro-to-migrations) - Data migration best practices
- [Lightweight Migrations - Convex Stack](https://stack.convex.dev/lightweight-zero-downtime-migrations) - Zero-downtime migration patterns

### Secondary (MEDIUM confidence)
- [Convex Ents: Cascade Deletes](https://labs.convex.dev/convex-ents/schema/deletes) - Third-party library patterns (not using, but informative)
- Current codebase (convex/schema.ts, convex/projects.ts, convex/taskStatuses.ts, convex/tasks.ts) - Existing patterns

### Tertiary (LOW confidence)
- WebSearch results for Convex migration patterns - Multiple sources agree on union type approach, cross-verified with official docs

## Metadata

**Confidence breakdown:**
- Schema migration approach: HIGH - Verified with official Convex docs and existing codebase patterns
- Cascade delete pattern: HIGH - Existing pattern in projects.ts shows clear precedent
- Index design: HIGH - Current schema has similar multi-field indexes, documented in official Convex docs
- UI impact: MEDIUM - Identified affected files, but full scope requires code review of all taskStatus usages
- Migration timing/rollout: MEDIUM - Best practices are clear, but project-specific deployment constraints unknown

**Research date:** 2026-02-10
**Valid until:** 2026-04-10 (60 days - stable Convex patterns unlikely to change rapidly)
