# Phase 03.1: default taskStatus logic - Research

**Researched:** 2026-02-10
**Domain:** Convex backend mutations, task status seeding, denormalized field synchronization
**Confidence:** HIGH

## Summary

This phase implements default task status logic for the existing task management system. The schema already exists (`taskStatuses` table with proper indexes), a seeding mutation exists (`taskStatuses.seedDefaultStatuses`), but the integration is incomplete. The codebase currently seeds statuses lazily in `tasks.create` when no statusId is provided, but the user decision specifies seeding should happen at **project creation time** instead.

The technical challenge is straightforward: move the seeding logic from `tasks.create` into `projects.create`, ensure every new task gets the default status, and maintain the one-way sync where setting status to "Done" automatically sets `completed=true`. The existing implementation in `tasks.ts` already demonstrates correct patterns for status-to-completed synchronization.

**Primary recommendation:** Inline the default status seeding into `projects.create` mutation (matching Phase 1's pattern), update `tasks.create` to fetch the default status instead of seeding, and verify the existing status-change-to-completed sync logic covers all update paths.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- 3-column workflow: **Todo**, **In Progress**, **Done**
- Todo is marked as `default=true` (the status assigned to new tasks)
- Statuses are seeded at project creation time (inline in the create project mutation)
- Every new task automatically gets the default status (Todo)
- No tasks should exist without a status
- Setting status to Done → `completed=true` (auto-sync)
- Moving a task OUT of Done does NOT auto-reset `completed` — requires explicit uncomplete action
- One-way automatic sync only

### Claude's Discretion
- Schema design for taskStatuses table (fields, indexes) — ALREADY IMPLEMENTED
- How to wire status seeding into existing project creation mutation
- How kanban board columns map to these statuses
- UI updates needed in task creation and status display

### Deferred Ideas (OUT OF SCOPE)
None specified
</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Convex | Current | Backend database & mutations | Project's primary backend framework |
| fractional-indexing | 3.2.0 | Task position ordering within columns | Already in use for task position management |
| React | 18 | Frontend UI | Project's frontend framework |
| shadcn/ui | Current | UI components | Project's component library |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @dnd-kit/core | Latest | Drag-and-drop foundation | Future kanban board implementation |
| @dnd-kit/sortable | Latest | Sortable preset for columns | Future kanban board implementation |
| Tailwind CSS | Current | Status color classes | Already in use for `color` field |

### Already Implemented
The schema and core mutations already exist:
- `taskStatuses` table with `by_workspace` and `by_workspace_order` indexes
- `taskStatuses.seedDefaultStatuses` mutation
- `taskStatuses.listByWorkspace` query
- Status sync logic in `tasks.update` and `tasks.updatePosition`

**Installation:**
No new packages needed — all dependencies already installed.

## Architecture Patterns

### Recommended Project Structure
```
convex/
├── projects.ts          # Add inline status seeding here
├── tasks.ts             # Update to fetch default status
├── taskStatuses.ts      # Already exists — no changes needed
└── schema.ts            # Already complete

src/pages/App/Project/
├── Tasks.tsx            # List view (already exists)
├── TaskRow.tsx          # Row component (already exists)
├── TaskProperties.tsx   # Status selector (already exists)
└── KanbanBoard.tsx      # Future: column view (out of scope)
```

### Pattern 1: Inline Status Seeding at Project Creation
**What:** Insert default statuses directly in `projects.create` mutation
**When to use:** When data must exist before dependent entities are created
**Example:**
```typescript
// In projects.create mutation (after creating project)
// Inline seed default statuses (matches Phase 1 pattern)
await ctx.db.insert("taskStatuses", {
  workspaceId,
  name: "To Do",
  color: "bg-gray-500",
  order: 0,
  isDefault: true,
  isCompleted: false,
});

await ctx.db.insert("taskStatuses", {
  workspaceId,
  name: "In Progress",
  color: "bg-blue-500",
  order: 1,
  isDefault: false,
  isCompleted: false,
});

await ctx.db.insert("taskStatuses", {
  workspaceId,
  name: "Done",
  color: "bg-green-500",
  order: 2,
  isDefault: false,
  isCompleted: true,
});
```
**Why this pattern:** Per CONTEXT.md decision and project conventions from CLAUDE.md memory: "Mutations can't call other mutations — inline shared logic instead"

### Pattern 2: Fetching Default Status
**What:** Query for `isDefault=true` status when creating tasks
**When to use:** Every task creation
**Example:**
```typescript
// In tasks.create, replace seeding logic with:
const defaultStatus = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", project.workspaceId))
  .filter((q) => q.eq(q.field("isDefault"), true))
  .first();

if (!defaultStatus) {
  throw new ConvexError("No default status found for workspace");
}
const statusId = defaultStatus._id;
```

### Pattern 3: Status-to-Completed Sync (One-Way)
**What:** Automatically set `completed=true` when status changes to a status with `isCompleted=true`
**When to use:** All status change operations (`tasks.update`, `tasks.updatePosition`)
**Example:**
```typescript
// Already implemented in tasks.ts:
if (statusId !== undefined) {
  const newStatus = await ctx.db.get(statusId);
  if (!newStatus) throw new ConvexError("Status not found");

  patch.statusId = statusId;
  patch.completed = newStatus.isCompleted; // One-way sync
}
```
**CRITICAL:** This is one-way only. Moving OUT of "Done" does not auto-reset `completed` — user must explicitly uncomplete the task.

### Pattern 4: Index-Based Queries
**What:** Use `.withIndex()` for all workspace-scoped queries
**When to use:** Always — never use `.filter()` for indexed fields
**Example:**
```typescript
// Correct:
await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .collect();

// Incorrect (per CLAUDE.md):
await ctx.db
  .query("taskStatuses")
  .filter((q) => q.eq(q.field("workspaceId"), workspaceId))
  .collect();
```

### Anti-Patterns to Avoid
- **Calling mutations from mutations:** Convex doesn't support this. Inline the logic instead.
- **Lazy seeding in task creation:** User decision specifies seeding at project creation time.
- **Two-way auto-sync:** Moving OUT of "Done" should NOT auto-reset `completed`. User must explicitly uncomplete.
- **Using filter() for indexed fields:** Always use `.withIndex()` for workspace/project scoped queries.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Task ordering in columns | Manual position integers, reindexing on insert | `fractional-indexing` library with `generateKeyBetween()` | Already implemented; handles infinite precision ordering without reindexing |
| Status seeding transaction safety | Separate mutation calls | Inline inserts in single mutation | Guarantees atomicity — all statuses inserted or none |
| Denormalized field sync | Manual mutation chaining | Inline sync in update mutations | Convex mutations are atomic transactions; keep related updates together |
| Drag-and-drop kanban | Custom mouse event handlers | @dnd-kit library | Standard, accessible, handles keyboard navigation and edge cases |

**Key insight:** Convex's transaction model means that all database operations in a single mutation execute atomically. This makes inline seeding safer and simpler than calling separate mutations.

## Common Pitfalls

### Pitfall 1: Forgetting Idempotency Check
**What goes wrong:** Seeding statuses multiple times creates duplicates
**Why it happens:** Project creation might be retried due to optimistic concurrency control
**How to avoid:** Always check if statuses exist before inserting
**Warning signs:** Multiple "To Do" statuses for same workspace
**Prevention code:**
```typescript
// Add idempotency check at start of seeding logic
const existingStatus = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .first();

if (existingStatus) {
  // Statuses already seeded — skip insertion
  return; // or continue with rest of mutation
}
```

### Pitfall 2: Two-Way Sync Misunderstanding
**What goes wrong:** Implementing auto-reset of `completed` when moving OUT of "Done"
**Why it happens:** Intuitive expectation that sync should be bidirectional
**How to avoid:** Remember the user decision: "One-way automatic sync only"
**Warning signs:** `completed` field unexpectedly resetting to `false`
**Correct behavior:**
- Status changes TO "Done" (isCompleted=true) → `completed=true` ✅
- Status changes FROM "Done" → `completed` stays `true` unless user explicitly uncompletes ✅

### Pitfall 3: Missing Status in Task Creation
**What goes wrong:** Tasks created without a statusId throw errors or break UI
**Why it happens:** Optional statusId parameter without fallback to default
**How to avoid:** Always fetch and assign default status when statusId not provided
**Warning signs:** Tasks with undefined statusId, TypeScript errors on task.status
**Prevention pattern:**
```typescript
let statusId = args.statusId;
if (!statusId) {
  const defaultStatus = await ctx.db
    .query("taskStatuses")
    .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
    .filter((q) => q.eq(q.field("isDefault"), true))
    .first();

  if (!defaultStatus) throw new ConvexError("No default status found");
  statusId = defaultStatus._id;
}
```

### Pitfall 4: Workspace vs Project Scoping Confusion
**What goes wrong:** Seeding statuses per-project instead of per-workspace
**Why it happens:** User decision says "project creation time" but statuses are workspace-scoped
**How to avoid:** Seed once per workspace (first project creation), use workspace-scoped queries
**Warning signs:** Duplicate status sets for same workspace, statuses missing for workspace
**Correct approach:**
```typescript
// In projects.create:
// Use workspaceId, not projectId
const existingStatus = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .first();

if (!existingStatus) {
  // Seed with workspaceId
  await ctx.db.insert("taskStatuses", {
    workspaceId: workspaceId, // Not projectId!
    // ... rest of fields
  });
}
```

### Pitfall 5: Index Selection for Default Status Query
**What goes wrong:** Using filter() instead of withIndex() for performance
**Why it happens:** No index exists on `isDefault` field alone
**How to avoid:** Use `by_workspace` index + filter for secondary constraint
**Warning signs:** Slow queries, unnecessary full table scans
**Correct pattern (already in codebase):**
```typescript
// Use workspace index, then filter for isDefault
const defaultStatus = await ctx.db
  .query("taskStatuses")
  .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
  .filter((q) => q.eq(q.field("isDefault"), true))
  .first();
```

## Code Examples

Verified patterns from existing codebase:

### Status Sync in Task Updates
```typescript
// Source: /convex/tasks.ts lines 378-384
if (statusId !== undefined) {
  const newStatus = await ctx.db.get(statusId);
  if (!newStatus) throw new ConvexError("Status not found");

  patch.statusId = statusId;
  patch.completed = newStatus.isCompleted; // One-way sync
}
```

### Status Sync in Drag-and-Drop Position Updates
```typescript
// Source: /convex/tasks.ts lines 456-458
await ctx.db.patch(taskId, {
  statusId,
  position,
  completed: newStatus.isCompleted, // Maintain sync on column moves
});
```

### Fractional Indexing for Task Position
```typescript
// Source: /convex/tasks.ts lines 111-124
import { generateKeyBetween } from "fractional-indexing";

// Find last task in status column
const tasksInStatus = await ctx.db
  .query("tasks")
  .withIndex("by_project_status_position", (q) =>
    q.eq("projectId", args.projectId).eq("statusId", statusId)
  )
  .collect();

const lastTask = tasksInStatus.length > 0
  ? tasksInStatus.reduce((max, task) =>
      (task.position ?? '') > (max.position ?? '') ? task : max
    )
  : null;

position = generateKeyBetween(lastTask?.position ?? null, null);
```

### Existing Status Seeding Pattern
```typescript
// Source: /convex/taskStatuses.ts lines 5-47
export const seedDefaultStatuses = mutation({
  args: { workspaceId: v.id("workspaces") },
  returns: v.null(),
  handler: async (ctx, { workspaceId }) => {
    // Idempotency check
    const existingStatus = await ctx.db
      .query("taskStatuses")
      .withIndex("by_workspace", (q) => q.eq("workspaceId", workspaceId))
      .first();

    if (existingStatus) return null; // Already seeded

    // Insert 3 default statuses
    await ctx.db.insert("taskStatuses", {
      workspaceId,
      name: "To Do",
      color: "bg-gray-500",
      order: 0,
      isDefault: true,
      isCompleted: false,
    });

    await ctx.db.insert("taskStatuses", {
      workspaceId,
      name: "In Progress",
      color: "bg-blue-500",
      order: 1,
      isDefault: false,
      isCompleted: false,
    });

    await ctx.db.insert("taskStatuses", {
      workspaceId,
      name: "Done",
      color: "bg-green-500",
      order: 2,
      isDefault: false,
      isCompleted: true,
    });

    return null;
  },
});
```

### UI Pattern: Status Display in TaskRow
```typescript
// Source: /src/pages/App/Project/TaskRow.tsx lines 56-65
{/* Status Badge */}
{task.status && (
  <Badge variant="secondary" className="flex items-center gap-1">
    <span
      className={cn("w-1 h-1 rounded-full", task.status.color)}
      aria-hidden="true"
    />
    {task.status.name}
  </Badge>
)}
```

### UI Pattern: Status Selector in TaskProperties
```typescript
// Source: /src/pages/App/Project/TaskProperties.tsx lines 86-123
<Select value={task.statusId} onValueChange={onStatusChange}>
  <SelectTrigger>
    <SelectValue>
      {task.status && (
        <div className="flex items-center gap-2">
          <span className={cn("w-2 h-2 rounded-full", task.status.color)} />
          <span>{task.status.name}</span>
        </div>
      )}
    </SelectValue>
  </SelectTrigger>
  <SelectContent>
    {statuses.map((status) => (
      <SelectItem key={status._id} value={status._id}>
        <div className="flex items-center gap-2">
          <span className={cn("w-2 h-2 rounded-full", status.color)} />
          <span>{status.name}</span>
        </div>
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Boolean `completed` only | Status-based workflow with denormalized `completed` | Phase 2 (2026) | Enables kanban columns while preserving efficient filtering |
| Lazy status seeding | Eager seeding at project creation | This phase (03.1) | Guarantees statuses exist before first task |
| Manual position reindexing | Fractional indexing | Phase 2 (2026) | Infinite precision ordering without bulk updates |
| React Beautiful DND | @dnd-kit | Industry shift (2024) | Better accessibility, active maintenance, smaller bundle |

**Deprecated/outdated:**
- `react-beautiful-dnd`: No longer maintained, replaced by `@dnd-kit` or `@hello-pangea/dnd`
- Calling mutations from mutations: Never supported in Convex — use inline logic or actions with scheduler
- Global-only statuses: Current schema correctly scopes to workspace level

## Open Questions

1. **Should project creation fail if status seeding fails?**
   - What we know: Status seeding is currently idempotent and returns null if statuses exist
   - What's unclear: If seeding fails during project creation, should the entire transaction roll back?
   - Recommendation: Yes — statuses are required for tasks to work. If seeding fails, project creation should fail atomically.

2. **How should kanban board columns be ordered?**
   - What we know: Schema has `order` field, `by_workspace_order` index exists
   - What's unclear: Should kanban columns follow `order` field, or fixed "To Do / In Progress / Done" arrangement?
   - Recommendation: Use `order` field for future flexibility when custom statuses are added (Phase 03.2+)

3. **What happens if workspace has no default status?**
   - What we know: Code throws `ConvexError("No default status found for workspace")`
   - What's unclear: Could this happen in production after migration?
   - Recommendation: If migrating existing data, write a one-time migration to seed statuses for workspaces that lack them

## Sources

### Primary (HIGH confidence)
- Codebase: `/convex/schema.ts` - taskStatuses table definition with indexes
- Codebase: `/convex/tasks.ts` - Status sync logic in update and updatePosition mutations
- Codebase: `/convex/taskStatuses.ts` - Seeding pattern and queries
- Codebase: `/convex/projects.ts` - Project creation mutation structure
- Codebase: `/src/pages/App/Project/TaskProperties.tsx` - Status UI patterns
- Codebase: `CLAUDE.md` - Project conventions: "Mutations can't call other mutations — inline shared logic instead"
- [Convex Best Practices](https://docs.convex.dev/understanding/best-practices/) - Index usage, mutation patterns
- [Seeding Data for Preview Deployments](https://stack.convex.dev/seeding-data-for-preview-deployments) - Idempotent seeding patterns
- [Database Triggers](https://stack.convex.dev/triggers) - Denormalized field sync patterns
- [Convex Indexes](https://docs.convex.dev/database/reading-data/indexes/) - withIndex() vs filter() guidance

### Secondary (MEDIUM confidence)
- [fractional-indexing npm](https://www.npmjs.com/package/fractional-indexing) - generateKeyBetween API
- [Build a Kanban Board with dnd-kit](https://blog.logrocket.com/build-kanban-board-dnd-kit-react/) - React kanban patterns
- [Building a Drag-and-Drop Kanban Board with React and dnd-kit](https://radzion.com/blog/kanban/) - Column-based drag-drop architecture

### Tertiary (LOW confidence)
None — all findings verified with codebase or official docs

## Metadata

**Confidence breakdown:**
- Schema design: HIGH - Already fully implemented and deployed
- Seeding pattern: HIGH - Existing mutation demonstrates correct approach; just needs relocation
- Status sync logic: HIGH - Already implemented correctly in tasks.ts
- UI patterns: HIGH - Existing components show status display and selection
- Kanban board implementation: MEDIUM - Library research complete but no existing code (out of scope for this phase)

**Research date:** 2026-02-10
**Valid until:** 2026-03-12 (30 days) — Convex patterns are stable; schema already deployed
