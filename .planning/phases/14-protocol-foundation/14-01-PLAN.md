---
phase: 14-protocol-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/protocol/index.ts
  - shared/protocol/messages.ts
  - shared/protocol/errors.ts
  - shared/protocol/schemas.ts
  - shared/protocol/rooms.ts
  - partykit/server.ts
  - partykit/tsconfig.json
  - src/hooks/use-yjs-provider.ts
autonomous: true

must_haves:
  truths:
    - "PartyKit server and frontend import message types from a single shared module (no duplicate definitions)"
    - "All WebSocket protocol messages (auth, sync, errors, future persistence/degradation) have TypeScript types with JSDoc comments"
    - "Runtime validation with Zod catches malformed messages on both server and client"
    - "Compile-time type checking catches protocol mismatches (tsc on partykit/ and src/ both succeed)"
  artifacts:
    - path: "shared/protocol/messages.ts"
      provides: "All WebSocket message type definitions with JSDoc"
      contains: "ServerMessage"
    - path: "shared/protocol/errors.ts"
      provides: "Error code enum and error classification (recoverable vs terminal)"
      contains: "AUTH_EXPIRED"
    - path: "shared/protocol/schemas.ts"
      provides: "Zod schemas for runtime validation of all message types"
      contains: "serverMessageSchema"
    - path: "shared/protocol/rooms.ts"
      provides: "Room ID construction, resource type enum, connection URL builder"
      contains: "buildRoomId"
    - path: "shared/protocol/index.ts"
      provides: "Barrel export for all protocol types and schemas"
      contains: "export"
    - path: "partykit/server.ts"
      provides: "PartyKit server using shared protocol types for auth and error handling"
      contains: "import.*shared/protocol"
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "Frontend hook using shared protocol types for room IDs and error handling"
      contains: "import.*@shared/protocol"
  key_links:
    - from: "shared/protocol/messages.ts"
      to: "partykit/server.ts"
      via: "import of ErrorCode and message types"
      pattern: "from.*shared/protocol"
    - from: "shared/protocol/messages.ts"
      to: "src/hooks/use-yjs-provider.ts"
      via: "import of room utilities and error types"
      pattern: "from.*@shared/protocol"
    - from: "shared/protocol/schemas.ts"
      to: "shared/protocol/messages.ts"
      via: "Zod schemas derive from and validate message types"
      pattern: "z\\.object"
---

<objective>
Define a type-safe protocol contract between the PartyKit collaboration server and frontend clients.

Purpose: Formalize the currently implicit WebSocket communication into shared TypeScript types with Zod runtime validation. This eliminates duplicate type definitions, catches protocol mismatches at compile time, and provides a typed foundation for phases 15-17 (persistence sync, token refresh, graceful degradation).

Output: `shared/protocol/` module with message types, error codes, Zod schemas, and room utilities — imported by both PartyKit server and frontend code.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing collaboration infrastructure (what we're formalizing)
@partykit/server.ts
@src/hooks/use-yjs-provider.ts
@convex/collaboration.ts
@convex/http.ts

# Shared directory structure (where protocol types will live)
@shared/constants.ts
@shared/enums/roles.ts

# TypeScript configs (PartyKit needs path resolution for shared/)
@partykit/tsconfig.json
@tsconfig.json
@tsconfig.app.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared protocol type definitions, error codes, and Zod schemas</name>
  <files>
    shared/protocol/messages.ts
    shared/protocol/errors.ts
    shared/protocol/schemas.ts
    shared/protocol/rooms.ts
    shared/protocol/index.ts
  </files>
  <action>
Create `shared/protocol/` directory with five files:

**1. `shared/protocol/rooms.ts`** — Room ID construction and resource types:
- `ResourceType` enum: `"doc" | "diagram" | "task"` (matches existing usage in collaboration.ts and use-yjs-provider.ts)
- `buildRoomId(resourceType: ResourceType, resourceId: string): string` — returns `"${resourceType}-${resourceId}"` (centralizes the convention currently duplicated in collaboration.ts line 57 and use-yjs-provider.ts indirectly)
- `parseRoomId(roomId: string): { resourceType: ResourceType; resourceId: string }` — inverse of buildRoomId, throws on invalid format
- `buildPartyKitUrl(host: string, roomId: string, token: string): string` — constructs WebSocket connection URL with token param
- JSDoc comments on every export

**2. `shared/protocol/errors.ts`** — Error codes and classification:
- `ErrorCode` string union type with these codes:
  - Auth: `'AUTH_MISSING'`, `'AUTH_EXPIRED'`, `'AUTH_INVALID'`, `'AUTH_FORBIDDEN'`
  - Room: `'ROOM_NOT_FOUND'`, `'ROOM_FULL'`
  - Sync: `'SYNC_CONFLICT'`, `'SYNC_FAILED'`
  - Server: `'SERVER_CONFIG_ERROR'`, `'SERVER_INTERNAL_ERROR'`
  - Connection: `'CONNECTION_TIMEOUT'`, `'CONNECTION_CLOSED'`
  - Future (Phase 15-17): `'PERSIST_FAILED'`, `'PERSIST_STALE_SNAPSHOT'`, `'TOKEN_REFRESH_REQUIRED'`, `'SERVICE_UNAVAILABLE'`, `'DEGRADED_MODE'`
- `ErrorSeverity` type: `'recoverable' | 'terminal'`
- `ERROR_SEVERITY: Record<ErrorCode, ErrorSeverity>` mapping — auth/server errors are terminal, sync/connection/future errors are recoverable
- JSDoc on each error code explaining when it occurs and which side sends it

**3. `shared/protocol/messages.ts`** — All WebSocket message type definitions:

Define a discriminated union pattern using `type` field:

**Client-to-server messages (`ClientMessage`):**
- `{ type: 'auth'; token: string }` — Client sends auth token on connect (future use when moving away from URL params)
- `{ type: 'token_refresh'; token: string }` — Phase 16: Client sends refreshed token
- `{ type: 'sync_request' }` — Phase 15: Client requests full state sync from server

**Server-to-client messages (`ServerMessage`):**
- `{ type: 'auth_ok'; userId: string; userName: string }` — Server confirms auth success
- `{ type: 'auth_error'; code: ErrorCode; }` — Server rejects auth
- `{ type: 'error'; code: ErrorCode; }` — Generic server error
- `{ type: 'user_joined'; userId: string; userName: string; userColor: string }` — Awareness: user joined room
- `{ type: 'user_left'; userId: string }` — Awareness: user left room
- `{ type: 'sync_complete'; snapshotVersion: number }` — Phase 15: Server confirms persistence
- `{ type: 'permission_revoked'; reason: string }` — Phase 16: Server kicks user after permission change
- `{ type: 'service_status'; available: boolean; degradedReason?: string }` — Phase 17: Server reports service health

Add a `ProtocolVersion` const set to `1` and a `PROTOCOL_HEADER = 'x-ripple-protocol'` const for future version negotiation.

Every message type gets a JSDoc comment explaining: purpose, who sends it, and expected receiver behavior.

**4. `shared/protocol/schemas.ts`** — Zod runtime validation schemas:
- Import `z` from "zod" (already a project dependency at 3.25.76)
- Create Zod schemas mirroring every type in messages.ts and errors.ts:
  - `errorCodeSchema` — `z.enum([...all error codes])`
  - `clientMessageSchema` — `z.discriminatedUnion("type", [...])` for all ClientMessage variants
  - `serverMessageSchema` — `z.discriminatedUnion("type", [...])` for all ServerMessage variants
  - `roomIdSchema` — `z.string().regex(...)` validating room ID format
- Export `parseClientMessage(data: unknown): ClientMessage` — wraps `clientMessageSchema.parse`
- Export `parseServerMessage(data: unknown): ServerMessage` — wraps `serverMessageSchema.parse`
- Export `safeParseClientMessage(data: unknown)` — wraps `clientMessageSchema.safeParse`
- Export `safeParseServerMessage(data: unknown)` — wraps `serverMessageSchema.safeParse`

**5. `shared/protocol/index.ts`** — Barrel exports:
- Re-export everything from messages.ts, errors.ts, schemas.ts, rooms.ts
- This is the single import point: `import { ServerMessage, parseServerMessage, ErrorCode, buildRoomId } from "@shared/protocol"`

**Important conventions:**
- Use `as const` satisfies patterns where appropriate
- All types are pure TypeScript (no runtime code except Zod schemas and utility functions)
- Follow existing shared/ directory style (see shared/enums/roles.ts for reference)
  </action>
  <verify>
Run `npx tsc --noEmit -p tsconfig.app.json` — shared/protocol/ should compile with zero errors.
Run `npm run lint` — no new warnings.
Verify all message types have JSDoc comments: grep for `/** ` in shared/protocol/messages.ts should return at least 10 matches.
  </verify>
  <done>
shared/protocol/ module exists with 5 files. All message types, error codes, Zod schemas, and room utilities are defined with JSDoc comments. TypeScript compilation succeeds. The module is ready for import by both PartyKit server and frontend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate shared protocol types into PartyKit server and frontend hook</name>
  <files>
    partykit/server.ts
    partykit/tsconfig.json
    src/hooks/use-yjs-provider.ts
  </files>
  <action>
**1. Update `partykit/tsconfig.json`** to resolve shared/ imports:

Add paths configuration so the PartyKit server can import from `../../shared/protocol`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "..",
    "lib": ["ES2022"],
    "paths": {
      "@shared/*": ["../shared/*"]
    },
    "baseUrl": "."
  },
  "include": ["./**/*.ts", "../shared/**/*.ts"]
}
```

Note: PartyKit uses esbuild under the hood for bundling, which resolves these paths at build time. The tsconfig paths enable TypeScript type checking while PartyKit's bundler handles the actual resolution. If the paths alias doesn't work with PartyKit's bundler, fall back to relative imports (`../shared/protocol`) which will always work.

**2. Update `partykit/server.ts`** to use shared protocol types:

- Import `ErrorCode` and `ServerMessage` types from shared protocol (try `@shared/protocol` first, fall back to `../shared/protocol`)
- Import `parseRoomId` from shared protocol for room ID parsing (though current server receives room ID from PartyKit runtime, not from client)
- Replace hardcoded connection close code strings with `ErrorCode` constants:
  - `"Missing auth token"` → use `ErrorCode` 'AUTH_MISSING', close code 1008
  - `"Server configuration error"` → use `ErrorCode` 'SERVER_CONFIG_ERROR', close code 1011
  - `"Unauthorized"` → use `ErrorCode` 'AUTH_INVALID', close code 1008
  - `"Auth verification failed"` → use `ErrorCode` 'SERVER_INTERNAL_ERROR', close code 1011
- Add type annotation to the `userData` response from Convex verify endpoint
- Send typed `ServerMessage` JSON before closing on error (allows client to read error code before WebSocket closes):
  - Before `conn.close(1008, ...)`, send `conn.send(JSON.stringify({ type: 'auth_error', code: 'AUTH_MISSING' } satisfies ServerMessage))`
  - Before `conn.close(1011, ...)`, send `conn.send(JSON.stringify({ type: 'error', code: 'SERVER_CONFIG_ERROR' } satisfies ServerMessage))`
- Keep the existing y-partykit delegation intact — the auth gate pattern stays the same, we're just typing the error paths

**3. Update `src/hooks/use-yjs-provider.ts`:**

- Import `ResourceType` and `buildRoomId` from `@shared/protocol` (replaces local `ResourceType` type)
- Remove the local `type ResourceType = "doc" | "diagram" | "task"` line (now comes from shared protocol)
- Use `buildRoomId(resourceType, resourceId)` instead of letting getCollaborationToken construct the room ID. Note: currently `getCollaborationToken` returns `{ token, roomId }` where roomId is built server-side. The frontend should still use the server-returned roomId for connection (single source of truth), but import `ResourceType` from shared protocol for the function signature.
- Import `ErrorCode` type from `@shared/protocol` — add typed error handling in the catch block (currently just console.error). Parse the error and check if it matches known error codes, log accordingly. Don't change user-facing behavior yet (that's Phase 17).

**Key constraint:** Do NOT break the existing connection flow. The y-partykit provider handles Yjs sync messages internally. Our protocol types layer on top for custom messages (auth errors, future persistence/degradation signals). The Yjs sync wire protocol remains untouched.
  </action>
  <verify>
Run `npx tsc --noEmit -p partykit/tsconfig.json` — PartyKit server compiles with zero errors.
Run `npx tsc --noEmit -p tsconfig.app.json` — Frontend compiles with zero errors.
Run `npm run lint` — zero warnings.
Run `npm run build` — production build succeeds.
Grep for duplicate ResourceType definitions: `grep -r "type ResourceType" src/ shared/` should show only one definition in shared/protocol/rooms.ts (none in use-yjs-provider.ts).
Grep for shared protocol imports: `grep -r "shared/protocol" partykit/ src/` should show imports in both partykit/server.ts and src/hooks/use-yjs-provider.ts.
  </verify>
  <done>
PartyKit server imports error codes and message types from shared protocol module. Frontend hook imports ResourceType and room utilities from shared protocol. No duplicate type definitions exist. Both server and frontend compile cleanly against the same shared types. Existing collaboration functionality is unchanged (no behavioral regressions).
  </done>
</task>

</tasks>

<verification>
1. **Type safety**: `npx tsc --noEmit -p tsconfig.app.json` and `npx tsc --noEmit -p partykit/tsconfig.json` both pass
2. **Lint**: `npm run lint` passes with zero warnings
3. **Build**: `npm run build` succeeds
4. **Shared module**: `ls shared/protocol/` shows 5 files (index.ts, messages.ts, errors.ts, schemas.ts, rooms.ts)
5. **No duplicate types**: `grep -r "type ResourceType" src/ shared/` shows only shared/protocol/rooms.ts
6. **Both consumers import**: `grep -r "shared/protocol" partykit/ src/` shows both server and hook
7. **JSDoc coverage**: `grep -c "/\*\*" shared/protocol/messages.ts` >= 10
8. **Zod schemas**: `grep "z\\.discriminatedUnion" shared/protocol/schemas.ts` shows at least 2 matches
</verification>

<success_criteria>
- Shared TypeScript types exist for all current and planned PartyKit WebSocket messages
- Frontend and PartyKit server both import from `shared/protocol/` (single source of truth)
- Zod runtime validation schemas exist for all message types
- Compile-time type checking catches protocol mismatches on both sides
- Existing collaboration functionality works unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/14-protocol-foundation/14-01-SUMMARY.md`
</output>
