---
phase: 06.1-mention-people-in-task-comments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/App/Project/taskCommentSchema.ts
  - src/pages/App/Project/TaskComments.tsx
  - src/pages/App/Project/TaskDetailSheet.tsx
  - src/pages/App/Project/TaskDetailPage.tsx
  - src/pages/App/Project/task-comment.css
autonomous: true

must_haves:
  truths:
    - "User can type @ in a comment input and see a list of project members to select from"
    - "Selected @mention renders as bold @Name in the saved comment"
    - "Existing plain-text comments from Phase 6 still render correctly (backwards compatible)"
    - "User can edit a comment that contains @mentions and the mentions are preserved"
    - "Comment input clears after successful submission"
  artifacts:
    - path: "src/pages/App/Project/taskCommentSchema.ts"
      provides: "BlockNote schema with only userMention inline content type"
      contains: "taskCommentSchema"
    - path: "src/pages/App/Project/TaskComments.tsx"
      provides: "BlockNote-powered comment input, display, and edit with @mention autocomplete"
      min_lines: 100
    - path: "src/pages/App/Project/task-comment.css"
      provides: "Compact styling for comment BlockNote editors"
  key_links:
    - from: "src/pages/App/Project/TaskComments.tsx"
      to: "src/pages/App/Project/taskCommentSchema.ts"
      via: "import taskCommentSchema"
      pattern: "import.*taskCommentSchema.*from.*taskCommentSchema"
    - from: "src/pages/App/Project/TaskComments.tsx"
      to: "src/pages/App/Project/CustomInlineContent/UserMention.tsx"
      via: "taskCommentSchema reuses UserMention spec"
      pattern: "userMention"
    - from: "src/pages/App/Project/TaskDetailSheet.tsx"
      to: "src/pages/App/Project/TaskComments.tsx"
      via: "passes projectId prop for member autocomplete"
      pattern: "projectId.*TaskComments\\|TaskComments.*projectId"
    - from: "src/pages/App/Project/TaskDetailPage.tsx"
      to: "src/pages/App/Project/TaskComments.tsx"
      via: "passes projectId prop for member autocomplete"
      pattern: "projectId.*TaskComments\\|TaskComments.*projectId"
---

<objective>
Upgrade task comments from plain textarea to BlockNote rich text editor with @mention support for project members.

Purpose: Users can @mention project members in task comments, creating targeted communication within task discussions. Mentioned users are visually distinguished as bold @Name text, matching the existing task description @mention pattern.

Output: TaskComments component rewritten to use BlockNote with a minimal comment-specific schema (userMention only), backwards-compatible with existing plain-text comments from Phase 6.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-mention-people-in-task-comments/06.1-RESEARCH.md

# Existing patterns to reuse:
@src/pages/App/Project/taskDescriptionSchema.ts
@src/pages/App/Project/CustomInlineContent/UserMention.tsx
@src/pages/App/Project/TaskComments.tsx
@src/pages/App/Project/TaskDetailSheet.tsx
@src/pages/App/Project/TaskDetailPage.tsx
@convex/taskComments.ts
@src/pages/App/Project/task-description.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comment schema and upgrade TaskComments to BlockNote with @mentions</name>
  <files>
    src/pages/App/Project/taskCommentSchema.ts
    src/pages/App/Project/TaskComments.tsx
    src/pages/App/Project/task-comment.css
  </files>
  <action>
    **Step 1: Create `taskCommentSchema.ts`**

    Create a minimal BlockNote schema for comments. Import only `UserMention` from `CustomInlineContent/UserMention.tsx`. Do NOT include diagramEmbed, documentLink, or projectReference — comments only support @mentions.

    ```typescript
    import { BlockNoteSchema, defaultBlockSpecs, defaultInlineContentSpecs } from "@blocknote/core";
    import { UserMention } from "./CustomInlineContent/UserMention";

    export const taskCommentSchema = BlockNoteSchema.create({
      blockSpecs: { ...defaultBlockSpecs },
      inlineContentSpecs: { ...defaultInlineContentSpecs, userMention: UserMention },
    });
    ```

    **Step 2: Create `task-comment.css`**

    Create compact styling for comment editors. Comments should be visually lighter than the task description editor. Remove left padding from BlockNote editor inside comment containers. Use class `.task-comment-editor` to scope styles.

    ```css
    .task-comment-editor .bn-editor {
      padding-inline: 0px;
    }
    .task-comment-editor .bn-block-group {
      padding-inline: 0px;
    }
    ```

    **Step 3: Rewrite `TaskComments.tsx` to use BlockNote**

    Expand the component props to accept `projectId: Id<"projects">` in addition to existing `taskId` and `currentUserId`.

    Add a `useQuery(api.projectMembers.membersByProject, { projectId })` call to get project members for the @ autocomplete.

    **Comment Input (new comment):**
    - Replace the `<Textarea>` with a BlockNote editor using `useCreateBlockNote({ schema: taskCommentSchema })`.
    - Wrap the editor in a div with class `task-comment-editor border rounded-md p-2`.
    - Add `<SuggestionMenuController>` with `triggerCharacter="@"` that filters project members by name, limits to 10 results. Each item should have an Avatar icon (same pattern as TaskDetailSheet @ autocomplete). On item click, insert `{ type: "userMention", props: { userId: m.userId } }` followed by `" "`.
    - The submit handler should: `JSON.stringify(editor.document)` to get the body, call `createComment({ taskId, body })`, then clear the editor via `editor.replaceBlocks(editor.document, [{ type: "paragraph", content: "" }])`.
    - Add an `isEmpty` state to track whether the editor has content (check on `onChange` if the document contains only empty paragraphs). Use this to disable the Comment button.
    - Import `BlockNoteView` from `@blocknote/shadcn`, `SuggestionMenuController` and `useCreateBlockNote` from `@blocknote/react`, plus the BlockNote CSS imports (`@blocknote/core/fonts/inter.css`, `@blocknote/shadcn/style.css`).
    - Import and apply `task-comment.css`.
    - Use `useTheme` from `next-themes` for the `theme` prop on `BlockNoteView`.
    - For Ctrl+Enter submit: attach an `onKeyDown` handler on the wrapper div that captures `e.ctrlKey && e.key === "Enter"` and calls the submit handler.
    - The editor should have `sideMenu={false}` or equivalent to hide the block drag handle (comments are simple, no block reordering needed). Set `formattingToolbar={false}` is not needed - just keeping it minimal.

    **Comment Display (read-only):**
    - Create a `CommentBody` sub-component that takes `body: string` and renders the comment.
    - Implement a `parseCommentBody` helper function that does: `try { return JSON.parse(body); } catch { return [{ type: "paragraph", content: body }]; }` — this provides backwards compatibility with Phase 6 plain-text comments.
    - Use `useCreateBlockNote({ schema: taskCommentSchema, initialContent: parseCommentBody(body) })` for the display editor.
    - Render via `<BlockNoteView editor={displayEditor} editable={false} theme={...} />` wrapped in the `task-comment-editor` class div.
    - This is lightweight — read-only, no suggestion menus needed.

    **Comment Edit Mode:**
    - When user clicks "Edit", instead of showing a textarea, show a BlockNote editor initialized with the comment's parsed body.
    - Create an `EditCommentEditor` sub-component that takes `commentId`, `initialBody`, `onSave`, and `onCancel` props. It creates its own editor instance via `useCreateBlockNote({ schema: taskCommentSchema, initialContent: parseCommentBody(initialBody) })`.
    - On Save: `JSON.stringify(editor.document)` and call `onSave(commentId, body)`.
    - On Cancel: call `onCancel()`.
    - The edit editor should also have the `SuggestionMenuController` for @ autocomplete (users may want to add mentions when editing).
    - Wrap in same `task-comment-editor` class div with border.

    **Important details:**
    - Keep the existing Avatar, author name, timestamp display pattern unchanged.
    - Keep the existing Pencil edit icon and Trash2 delete icon pattern.
    - Keep the author-only check for edit/delete buttons (`comment.userId === currentUserId`).
    - The `handleDelete` function stays as-is (soft delete via `removeComment`).
    - Do NOT trim the body string server-side anymore for BlockNote content — the update mutation in `convex/taskComments.ts` currently does `.trim()` which would corrupt JSON. However, do NOT modify the backend in this task — the `.trim()` on a JSON string is actually harmless since JSON.stringify never produces leading/trailing whitespace. Leave the backend unchanged.
  </action>
  <verify>
    Run `npm run lint` and confirm zero errors and zero warnings. Check that `taskCommentSchema.ts` exists and exports `taskCommentSchema`. Check that `TaskComments.tsx` imports from `taskCommentSchema` and uses `BlockNoteView`, `SuggestionMenuController`, and `useCreateBlockNote`. Check that `task-comment.css` exists.
  </verify>
  <done>
    TaskComments component uses BlockNote for input, display, and editing. The @ trigger shows project member autocomplete. Comment body is stored as JSON string. Old plain-text comments are rendered via the parseCommentBody fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass projectId to TaskComments from both TaskDetailSheet and TaskDetailPage</name>
  <files>
    src/pages/App/Project/TaskDetailSheet.tsx
    src/pages/App/Project/TaskDetailPage.tsx
  </files>
  <action>
    **TaskDetailSheet.tsx:**
    - Find the `<TaskComments taskId={taskId} currentUserId={currentUser._id} />` line.
    - Add `projectId={projectId}` prop: `<TaskComments taskId={taskId} currentUserId={currentUser._id} projectId={projectId} />`.
    - The `projectId` is already available as a prop of `TaskDetailSheet` (it receives `projectId: Id<"projects">`), so no additional data fetching is needed.

    **TaskDetailPage.tsx:**
    - Find the `<TaskComments taskId={taskId} currentUserId={currentUser._id} />` line inside `TaskDetailPageContent`.
    - Add `projectId={projectId}` prop: `<TaskComments taskId={taskId} currentUserId={currentUser._id} projectId={projectId} />`.
    - The `projectId` is already available as a prop of `TaskDetailPageContent` (it receives `projectId: Id<"projects">`), so no additional data fetching is needed.

    Both changes are one-line prop additions. No other modifications to these files.
  </action>
  <verify>
    Run `npm run lint` and confirm zero errors and zero warnings. Grep for `projectId` in both files near the TaskComments usage to confirm the prop is passed.
  </verify>
  <done>
    Both TaskDetailSheet and TaskDetailPage pass `projectId` to TaskComments, enabling the @mention autocomplete to query project members.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero errors and zero warnings
2. `taskCommentSchema.ts` exists and exports a BlockNote schema with `userMention` inline content type (and no other custom types)
3. `TaskComments.tsx` uses `BlockNoteView` for input, read-only display, and edit mode
4. `TaskComments.tsx` has `SuggestionMenuController` with `triggerCharacter="@"` for both input and edit editors
5. `TaskComments.tsx` accepts `projectId` prop and queries `projectMembers.membersByProject`
6. Both `TaskDetailSheet.tsx` and `TaskDetailPage.tsx` pass `projectId` to `<TaskComments>`
7. Comment body is stored via `JSON.stringify(editor.document)` and parsed with backwards-compatible fallback for plain-text comments
8. `task-comment.css` exists with compact styling for comment editors
</verification>

<success_criteria>
- User can type @ in the comment input and see project member autocomplete dropdown
- Selecting a member inserts a bold @Name inline mention in the comment
- Submitting the comment stores it as JSON and displays the @mention correctly in read-only view
- Editing a comment preserves existing @mentions and allows adding new ones
- Old plain-text comments from Phase 6 render correctly without errors
- `npm run lint` passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-mention-people-in-task-comments/06.1-01-SUMMARY.md`
</output>
