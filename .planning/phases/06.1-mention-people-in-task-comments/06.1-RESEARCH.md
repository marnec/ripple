# Phase 6.1: Mention People in Task Comments - Research

**Researched:** 2026-02-06
**Domain:** BlockNote custom inline content, @mention autocomplete in rich text editors
**Confidence:** HIGH

## Summary

Phase 6.1 adds @mention functionality to task comments, which currently use plain textarea elements. The core challenge is upgrading the comment input and display from plain text to BlockNote rich text, while maintaining the same visual simplicity and reusing the existing UserMention inline content spec from task descriptions.

The good news: Ripple already has all the necessary patterns. Phase 5 implemented @mentions in task descriptions using BlockNote with custom inline content (`UserMention.tsx`). The task description schema already includes the `userMention` inline content type. The implementation path is straightforward: replace the textarea with a minimal BlockNote editor using a comment-specific schema (just userMention, no other inline content types), and reuse the existing `@` autocomplete pattern.

Key architectural decision: Comments need a **separate schema** from task descriptions. Task descriptions support four inline content types (diagrams, documents, users, projects), but comments should only support user mentions. This keeps the comment UI focused and prevents feature creep.

**Primary recommendation:** Create a minimal `taskCommentSchema.ts` with only the `userMention` inline content type. Replace the textarea in TaskComments with BlockNote editor. Reuse the existing UserMention component and @ autocomplete pattern from TaskDetailSheet. Store comment body as JSON (BlockNote document format) instead of plain string.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @blocknote/core | 0.46.2 | Block editor engine | Already in use, handles custom inline content |
| @blocknote/react | 0.46.2 | React components | Already in use, provides `createReactInlineContentSpec` and `SuggestionMenuController` |
| @blocknote/shadcn | 0.46.2 | Shadcn UI theme | Already in use, provides `BlockNoteView` component |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| convex/react | 1.31.7 | Real-time data sync | Already integrated, comment updates sync automatically |
| lucide-react | 0.563.0 | Icons for autocomplete | Avatar icon in @ autocomplete picker |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| BlockNote editor | Continue with textarea + regex parsing | Textarea is simpler but requires custom @mention parsing/rendering, BlockNote gives us proven patterns |
| Separate comment schema | Reuse taskDescriptionSchema | Task description schema has 4 inline types, comments only need 1 - separate schema is cleaner |
| Rich comment display | Keep plain text, only highlight @mentions | BlockNote provides consistent rendering, edit mode is seamless |

**Installation:**
```bash
# All dependencies already installed
```

## Architecture Patterns

### Current Comment Structure
```
TaskComments.tsx uses:
- Textarea for comment input (plain text)
- String storage in Convex (body: v.string())
- Plain text display with whitespace-pre-wrap

TaskDetailSheet uses:
- BlockNote with taskDescriptionSchema (4 inline content types)
- JSON storage (description field)
- SuggestionMenuController for # and @ triggers
```

### Pattern 1: Minimal BlockNote Schema for Comments
**What:** Separate schema with only user mentions, no other inline content
**When to use:** When you need rich text features but want to limit capabilities
**Example:**
```typescript
// Source: New pattern for this phase, inspired by taskDescriptionSchema.ts
import { BlockNoteSchema, defaultBlockSpecs, defaultInlineContentSpecs } from "@blocknote/core";
import { UserMention } from "./CustomInlineContent/UserMention";

export const taskCommentSchema = BlockNoteSchema.create({
  blockSpecs: {
    ...defaultBlockSpecs,
  },
  inlineContentSpecs: {
    ...defaultInlineContentSpecs,
    userMention: UserMention,
  },
});
```

### Pattern 2: Compact BlockNote Editor for Comments
**What:** Single-paragraph BlockNote editor optimized for comment use case
**When to use:** When you need inline content but want minimal visual footprint
**Example:**
```typescript
// Source: Adapted from TaskDetailSheet editor pattern
const editor = useCreateBlockNote({
  schema: taskCommentSchema,
  initialContent: [{ type: "paragraph", content: "" }]
});

// Compact styling - no border, minimal padding
<div className="comment-editor">
  <BlockNoteView
    editor={editor}
    theme={resolvedTheme === "dark" ? "dark" : "light"}
  >
    <SuggestionMenuController
      triggerCharacter={"@"}
      getItems={async (query) => {
        // Filter project members
      }}
    />
  </BlockNoteView>
</div>
```

### Pattern 3: JSON Storage for Rich Text Comments
**What:** Store BlockNote document as JSON string, same as task descriptions
**When to use:** When using BlockNote for user-generated content
**Example:**
```typescript
// Source: Existing tasks.update pattern
// Create comment
const body = JSON.stringify(editor.document);
await createComment({ taskId, body });

// Display comment
const blocks = JSON.parse(comment.body);
editor.replaceBlocks(editor.document, blocks);
```

### Anti-Patterns to Avoid
- **Reusing taskDescriptionSchema for comments:** Comments don't need diagram/document/project references - separate schema prevents confusion
- **Plain string with @username parsing:** Fragile, doesn't handle edited usernames or deleted users
- **Large editor UI for comments:** Comments should feel lightweight - use minimal BlockNote styling

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| @mention parsing from text | Custom regex to find `@username` | BlockNote userMention inline content | BlockNote handles cursor position, editing, deletion, rendering states |
| User autocomplete dropdown | Custom dropdown with keyboard nav | SuggestionMenuController | BlockNote provides keyboard nav, filtering, positioning |
| Rich text -> plain text export | Strip HTML tags manually | BlockNote's built-in HTML export | Handles nested content, special characters, accessibility |
| Mention click handling | Custom event delegation | BlockNote inline content render prop | Component-based, type-safe, integrated with editor |

**Key insight:** Custom @mention parsing is deceptively complex - you need to handle mid-word edits, backspace behavior, copy-paste, undo/redo. BlockNote solves all of these.

## Common Pitfalls

### Pitfall 1: Schema Mismatch Between Input and Display
**What goes wrong:** Using one schema for input editor but different schema for display causes render errors
**Why it happens:** Forgetting that both the comment input and comment display need the same schema
**How to avoid:** Create `taskCommentSchema` once, import it in both the input editor setup and the display editor setup
**Warning signs:** Console errors about unknown inline content types, @mentions not rendering in saved comments

### Pitfall 2: Storing Plain Text Instead of JSON
**What goes wrong:** Storing `editor.document` as string without JSON.stringify loses structure
**Why it happens:** Assuming BlockNote document is plain text like textarea value
**How to avoid:** Always use `JSON.stringify(editor.document)` for storage, `JSON.parse(body)` for loading
**Warning signs:** Comments lose formatting on reload, @mentions render as plain text

### Pitfall 3: Not Clearing Editor After Submit
**What goes wrong:** Comment input still shows previous text after submission
**Why it happens:** BlockNote editor is stateful, doesn't auto-clear like controlled inputs
**How to avoid:** After successful mutation, call `editor.replaceBlocks(editor.document, [{ type: "paragraph", content: "" }])`
**Warning signs:** User types comment, clicks submit, old text remains in input

### Pitfall 4: Loading State Not Handled in Display
**What goes wrong:** Attempting to parse `comment.body` before comment data loads causes crash
**Why it happens:** BlockNote requires synchronous content to initialize
**How to avoid:** Guard display editors with `if (comment === undefined) return <Skeleton />` before creating editor
**Warning signs:** "Cannot read property of undefined" errors when comments load

### Pitfall 5: Edit Mode Schema Mismatch
**What goes wrong:** Edit mode shows different inline content than display mode
**Why it happens:** Creating new editor with default schema instead of taskCommentSchema
**How to avoid:** Use same `taskCommentSchema` for both display and edit mode editors
**Warning signs:** @mentions disappear when entering edit mode, reappear after cancel

### Pitfall 6: Keyboard Shortcuts Conflict
**What goes wrong:** Ctrl+Enter doesn't submit, or submits multiple times
**Why it happens:** BlockNote captures some keyboard events, need to listen at BlockNoteView level
**How to avoid:** Use `onChange` callback to detect content, separate submit button for Ctrl+Enter
**Warning signs:** Ctrl+Enter creates line break instead of submitting, or both

## Code Examples

Verified patterns from official sources and existing codebase:

### Create Minimal Comment Schema
```typescript
// Source: Adapted from src/pages/App/Project/taskDescriptionSchema.ts
import { BlockNoteSchema, defaultBlockSpecs, defaultInlineContentSpecs } from "@blocknote/core";
import { UserMention } from "./CustomInlineContent/UserMention";

// Comments only support @mentions, not diagrams/documents/projects
export const taskCommentSchema = BlockNoteSchema.create({
  blockSpecs: {
    ...defaultBlockSpecs,
  },
  inlineContentSpecs: {
    ...defaultInlineContentSpecs,
    userMention: UserMention, // Reuse existing UserMention from task descriptions
  },
});
```

### Comment Input with BlockNote
```typescript
// Source: Adapted from TaskDetailSheet.tsx pattern
const editor = useCreateBlockNote({ schema: taskCommentSchema });

const handleSubmit = () => {
  const body = JSON.stringify(editor.document);
  void createComment({ taskId, body }).then(() => {
    // Clear editor after submit
    editor.replaceBlocks(editor.document, [{ type: "paragraph", content: "" }]);
  });
};

return (
  <div>
    <BlockNoteView
      editor={editor}
      theme={resolvedTheme === "dark" ? "dark" : "light"}
    >
      <SuggestionMenuController
        triggerCharacter={"@"}
        getItems={async (query) => {
          if (!members) return [];
          return members
            .filter(m => m.name?.toLowerCase().includes(query.toLowerCase()))
            .slice(0, 10)
            .map(m => ({
              title: m.name ?? "Unknown",
              onItemClick: () => {
                editor.insertInlineContent([
                  { type: "userMention", props: { userId: m.userId } },
                  " ",
                ]);
              },
            }));
        }}
      />
    </BlockNoteView>
    <Button onClick={handleSubmit}>Comment</Button>
  </div>
);
```

### Comment Display with BlockNote
```typescript
// Source: New pattern for read-only comment display
const CommentDisplay = ({ comment }: { comment: EnrichedComment }) => {
  const blocks = JSON.parse(comment.body);
  const editor = useCreateBlockNote({
    schema: taskCommentSchema,
    initialContent: blocks,
  });

  return (
    <BlockNoteView
      editor={editor}
      editable={false} // Read-only display
      theme={resolvedTheme === "dark" ? "dark" : "light"}
    />
  );
};
```

### Edit Mode with Pre-filled Content
```typescript
// Source: Adapted from task description edit pattern
const [editingCommentId, setEditingCommentId] = useState<Id<"taskComments"> | null>(null);
const editEditor = useCreateBlockNote({ schema: taskCommentSchema });

const handleEdit = (commentId: Id<"taskComments">, currentBody: string) => {
  setEditingCommentId(commentId);
  const blocks = JSON.parse(currentBody);
  editEditor.replaceBlocks(editEditor.document, blocks);
};

const handleSave = (commentId: Id<"taskComments">) => {
  const body = JSON.stringify(editEditor.document);
  void updateComment({ id: commentId, body });
};
```

## Migration Strategy

### Database Schema Change
**Current:** `taskComments.body: v.string()` stores plain text
**New:** `taskComments.body: v.string()` stores JSON string (BlockNote document)

**Migration needed?** NO - both are strings. Old comments (plain text) will need handled gracefully:
```typescript
// Safe parsing with fallback
const parseCommentBody = (body: string) => {
  try {
    return JSON.parse(body); // New format
  } catch {
    // Old format - plain text, wrap in paragraph
    return [{ type: "paragraph", content: body }];
  }
};
```

### Backwards Compatibility
If the migration needs to be seamless:
1. Phase 6 comments (plain text) remain readable
2. Phase 6.1 editor can initialize with either format
3. Once edited, old comments convert to JSON format
4. No data migration required

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Textarea with regex | BlockNote inline content | Phase 5 (task descriptions) | Full rich text support, type safety |
| String concatenation | JSON document storage | Phase 5 (task descriptions) | Structured data, easier to extend |
| Custom autocomplete | SuggestionMenuController | Phase 5 (task descriptions) | Better UX, keyboard nav built-in |

**Deprecated/outdated:**
- Plain textarea for user mentions: Too limited, manual parsing fragile
- Storing @username as plain text: Breaks when users change names

## Implementation Approach

### Option A: Separate Display/Edit Editors (RECOMMENDED)
**Pros:**
- Clean separation of concerns
- Read-only display is lightweight
- Edit mode has full editing capability
- Matches existing task description pattern

**Cons:**
- Two editor instances per comment
- Slightly more complex state management

### Option B: Single Editor Per Comment (NOT RECOMMENDED)
**Pros:**
- One editor instance
- Simpler state

**Cons:**
- All comments are always editable (confusing UX)
- Can't optimize read-only rendering
- Harder to implement author-only editing

**Decision:** Use Option A - separate display and edit editors, matching the task description pattern.

## Open Questions

None - all patterns are proven in existing codebase.

## Sources

### Primary (HIGH confidence)
- Existing codebase: `src/pages/App/Project/TaskDetailSheet.tsx` - BlockNote with SuggestionMenuController
- Existing codebase: `src/pages/App/Project/taskDescriptionSchema.ts` - Custom schema pattern
- Existing codebase: `src/pages/App/Project/CustomInlineContent/UserMention.tsx` - UserMention inline content spec
- Context7: `/typecellos/blocknote` - Custom inline content creation, SuggestionMenuController API
- Official docs: BlockNote custom inline content patterns

### Secondary (MEDIUM confidence)
- [BlockNote - Custom Inline Content](https://www.blocknotejs.org/docs/custom-schemas/custom-inline-content)
- [BlockNote - Manipulating Content](https://www.blocknotejs.org/docs/editor-api/manipulating-inline-content)

### Tertiary (LOW confidence)
None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use
- Architecture: HIGH - Exact patterns exist in codebase (Phase 5)
- Pitfalls: HIGH - Based on BlockNote common issues and existing implementation experience

**Research date:** 2026-02-06
**Valid until:** 30 days (stable libraries, proven patterns)
