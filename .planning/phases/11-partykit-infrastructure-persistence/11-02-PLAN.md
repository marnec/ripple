---
phase: 11-partykit-infrastructure-persistence
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - partykit/server.ts
  - convex/collaboration.ts
  - convex/http.ts
  - convex/schema.ts
  - src/hooks/use-yjs-provider.ts
  - src/pages/App/Document/DocumentEditor.tsx
  - src/pages/App/Document/CursorOverlay.tsx
  - src/hooks/use-cursor-tracking.ts
  - convex/cursorSessions.ts
autonomous: true

must_haves:
  truths:
    - "Frontend authenticates to PartyKit rooms using Convex user identity"
    - "PartyKit rejects connections without valid auth token (401)"
    - "PartyKit rejects connections to rooms user has no access to (403)"
    - "Room naming uses type prefixes: doc-{documentId}, diagram-{diagramId}"
    - "RTK cursor tracking code is fully removed (no cursorSessions table, no use-cursor-tracking hook)"
    - "Frontend useYjsProvider hook connects to PartyKit with auth token and proper cleanup"
  artifacts:
    - path: "convex/collaboration.ts"
      provides: "Convex action to generate auth token and internal queries for permission verification"
      exports: ["getCollaborationToken", "verifyAccess"]
    - path: "convex/http.ts"
      provides: "HTTP endpoint for PartyKit to verify tokens"
      contains: "collaboration/verify"
    - path: "partykit/server.ts"
      provides: "PartyKit server with onBeforeConnect auth gate"
      contains: "onBeforeConnect"
    - path: "src/hooks/use-yjs-provider.ts"
      provides: "React hook for Yjs provider with auth, cleanup, and connection state"
      min_lines: 30
  key_links:
    - from: "src/hooks/use-yjs-provider.ts"
      to: "convex/collaboration.ts"
      via: "useAction(api.collaboration.getCollaborationToken)"
      pattern: "getCollaborationToken"
    - from: "partykit/server.ts"
      to: "convex/http.ts"
      via: "fetch to CONVEX_SITE_URL/collaboration/verify in onBeforeConnect"
      pattern: "onBeforeConnect"
    - from: "convex/http.ts"
      to: "convex/collaboration.ts"
      via: "HTTP route calls internal verifyAccess function"
      pattern: "verifyAccess"
---

<objective>
Add authentication to PartyKit server, create frontend Yjs provider hook, and remove legacy RTK cursor tracking code.

Purpose: Complete INFRA-02 (auth integration) and clean up the deprecated RTK cursor system. After this plan, the frontend has a reusable `useYjsProvider` hook that Phase 12 (documents) and Phase 13 (diagrams) will use to connect to authenticated PartyKit rooms.

Output: Authenticated PartyKit connections, frontend Yjs provider hook, and clean codebase with no RTK cursor remnants.
</objective>

<execution_context>
@/home/lambda/.claude/get-shit-done/workflows/execute-plan.md
@/home/lambda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-partykit-infrastructure-persistence/11-CONTEXT.md
@.planning/phases/11-partykit-infrastructure-persistence/11-RESEARCH.md
@.planning/phases/11-partykit-infrastructure-persistence/11-01-SUMMARY.md
@convex/schema.ts
@convex/http.ts
@convex/documentMembers.ts
@convex/diagramMembers.ts
@src/pages/App/Document/DocumentEditor.tsx
@src/hooks/use-cursor-tracking.ts
@convex/cursorSessions.ts
@src/pages/App/Document/CursorOverlay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convex auth endpoint and PartyKit onBeforeConnect</name>
  <files>convex/collaboration.ts, convex/http.ts, partykit/server.ts</files>
  <action>
**Auth approach: Convex token passthrough** (per Claude's discretion, simpler than custom JWT, leverages existing auth).

The flow:
1. Frontend calls `api.collaboration.getCollaborationToken` Convex action (authenticated via existing Convex auth)
2. Action verifies document/diagram-level permissions, returns a short-lived token (the user's Convex auth token identifier)
3. Frontend passes token as query param when connecting to PartyKit
4. PartyKit `onBeforeConnect` calls Convex HTTP endpoint to verify token + room access
5. Convex HTTP endpoint validates the token and checks document/diagram membership

**Create `convex/collaboration.ts`:**

1. `getCollaborationToken` (public action):
   - Args: `{ resourceType: v.union(v.literal("doc"), v.literal("diagram")), resourceId: v.string() }`
   - Returns: `v.object({ token: v.string(), roomId: v.string() })`
   - Uses `getAuthUserId(ctx)` to verify authentication
   - For `"doc"`: call `ctx.runQuery` to check `documentMembers` table using `by_document_user` index (user must be a member)
   - For `"diagram"`: call `ctx.runQuery` to check `diagramMembers` table using `by_diagram_user` index (user must be a member)
   - Token: use `(await ctx.auth.getUserIdentity())?.tokenIdentifier` (Convex's built-in token, no custom JWT needed)
   - Return `{ token, roomId: \`${resourceType}-${resourceId}\` }`
   - Throw error if not authenticated or no access

2. `verifyAccessInternal` (internal query):
   - Args: `{ tokenIdentifier: v.string(), roomId: v.string() }`
   - Returns: `v.any()` (for enriched user data)
   - Parse roomId to extract type and resourceId: `const dashIdx = roomId.indexOf("-"); const roomType = roomId.substring(0, dashIdx); const resourceId = roomId.substring(dashIdx + 1);`
   - Look up user by tokenIdentifier in `users` table (query users, check user identity match via `auth.getUserIdentity` is not available in queries -- instead store the tokenIdentifier mapping)

   IMPORTANT: Since internal queries can't use `ctx.auth`, the HTTP endpoint should be an httpAction that CAN use `ctx.auth`. Restructure:

**Revised approach -- use Convex HTTP action directly:**

Create an HTTP endpoint at `/collaboration/verify` in `convex/http.ts`:
- Receives POST with JSON body `{ roomId: string }` and `Authorization: Bearer <token>` header
- The "token" is the Convex auth token (from `getUserIdentity().tokenIdentifier`)
- However, httpAction can't directly validate an arbitrary token identifier string as auth

**Simplest approach (recommended):** Use a signed token.

Actually, the simplest working approach:
1. In `getCollaborationToken` action: generate a random UUID as a one-time token, store it in a new `collaborationTokens` table with userId, roomId, and expiration (5 min TTL)
2. PartyKit `onBeforeConnect`: call Convex HTTP endpoint with this token
3. HTTP endpoint: look up token in `collaborationTokens` table, verify not expired, delete after use (one-time)
4. Return userId and userName to PartyKit

This avoids JWT complexity entirely. Tokens are one-time use, short-lived, stored in Convex.

**Implementation:**

A. Add to `convex/schema.ts` a new `collaborationTokens` table:
```typescript
collaborationTokens: defineTable({
  token: v.string(),
  userId: v.id("users"),
  roomId: v.string(),
  expiresAt: v.number(), // timestamp ms
})
  .index("by_token", ["token"]),
```

B. Create `convex/collaboration.ts`:
- `getCollaborationToken` (public action):
  - Verify auth with `getAuthUserId(ctx)`
  - Verify resource access (documentMembers or diagramMembers index lookup via `ctx.runQuery` to internal helpers)
  - Generate random token (use `crypto.randomUUID()` available in Convex actions runtime)
  - Store in `collaborationTokens` via `ctx.runMutation` to internal mutation (token, userId, roomId, expiresAt = Date.now() + 5 * 60 * 1000)
  - Return `{ token, roomId }`

- `checkDocumentAccess` (internal query): check documentMembers.by_document_user for userId
- `checkDiagramAccess` (internal query): check diagramMembers.by_diagram_user for userId
- `storeToken` (internal mutation): insert into collaborationTokens
- `consumeToken` (internal mutation): find by token index, verify not expired, delete, return userId + roomId. If expired or not found, return null.
- `getUserInfo` (internal query): get user by ID, return { userId, userName }

C. Update `convex/http.ts`:
- Add POST route `/collaboration/verify`
- httpAction handler: parse JSON body `{ roomId }`, extract `Authorization: Bearer <token>` header
- Call `ctx.runMutation(internal.collaboration.consumeToken, { token })` to validate and consume
- If null: return 401/403
- Call `ctx.runQuery(internal.collaboration.getUserInfo, { userId })`
- Return JSON `{ userId, userName }`

D. Update `partykit/server.ts`:
- Add static `onBeforeConnect` method to CollaborationServer
- Extract token from WebSocket URL query params: `new URL(request.url).searchParams.get("token")`
- Extract room ID from `lobby.id`
- If no token: return `new Response("Missing auth token", { status: 401 })`
- Call Convex HTTP endpoint: `fetch(\`${CONVEX_SITE_URL}/collaboration/verify\`, { method: "POST", headers: { "Content-Type": "application/json", "Authorization": \`Bearer ${token}\` }, body: JSON.stringify({ roomId }) })`
- `CONVEX_SITE_URL` comes from `lobby.env.CONVEX_SITE_URL` (defined in partykit.json)
- If response not ok: return `new Response("Unauthorized", { status: 403 })`
- Otherwise, allow connection (return void)
- Note: YPartyKitServer uses static onBeforeConnect. Check if extending YPartyKitServer supports static methods. If not, use the `onBeforeConnect` as a regular method and add auth check at the top of onConnect instead. Test which approach works.

**Important:** The `partykit.json` `define` field should map env vars. For dev, the CONVEX_SITE_URL needs to be available. Check if PartyKit reads from `.env.local` automatically, or if we need to set it in `partykit.json` define block. Research shows PartyKit reads `.env` files in dev mode. Add `CONVEX_SITE_URL` to the env that PartyKit can access -- for local dev, create or update a `.env` file with `CONVEX_SITE_URL=https://dutiful-pika-875.convex.site` (matching `.env.local`). Alternatively, PartyKit may read `.env.local`. Test and document which works.

For the `define` in `partykit.json`, use: `"CONVEX_SITE_URL": "env:CONVEX_SITE_URL"` -- this tells PartyKit to read from environment variables.
  </action>
  <verify>
1. `npm run lint` passes (no TypeScript errors in convex/ files)
2. Run `npx convex dev --until-success` to verify schema push succeeds with new collaborationTokens table
3. Check that `convex/http.ts` has the `/collaboration/verify` route
4. Check `partykit/server.ts` has onBeforeConnect with auth verification
  </verify>
  <done>
Convex collaboration action generates one-time tokens with document/diagram permission verification. HTTP endpoint validates tokens for PartyKit. PartyKit onBeforeConnect rejects unauthenticated/unauthorized connections. Schema includes collaborationTokens table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend useYjsProvider hook and RTK cursor cleanup</name>
  <files>src/hooks/use-yjs-provider.ts, src/pages/App/Document/DocumentEditor.tsx, src/pages/App/Document/CursorOverlay.tsx, src/hooks/use-cursor-tracking.ts, convex/cursorSessions.ts, convex/schema.ts</files>
  <action>
**Part A: Create `src/hooks/use-yjs-provider.ts`**

React hook that manages Yjs provider lifecycle with PartyKit authentication:

```typescript
import { useAction } from "convex/react";
import { useEffect, useMemo, useRef, useState } from "react";
import { YPartyKitProvider } from "y-partykit/provider";
import * as Y from "yjs";
import { api } from "../../convex/_generated/api";

type ResourceType = "doc" | "diagram";

export function useYjsProvider(opts: {
  resourceType: ResourceType;
  resourceId: string;
  enabled?: boolean;
}) {
  const { resourceType, resourceId, enabled = true } = opts;
  const getToken = useAction(api.collaboration.getCollaborationToken);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const providerRef = useRef<YPartyKitProvider | null>(null);
  const docRef = useRef<Y.Doc | null>(null);

  // Create stable Y.Doc per resourceId
  const yDoc = useMemo(() => {
    const doc = new Y.Doc();
    docRef.current = doc;
    return doc;
  }, [resourceId]);

  useEffect(() => {
    if (!enabled) {
      setIsLoading(false);
      return;
    }

    let cancelled = false;
    setIsLoading(true);

    const connect = async () => {
      try {
        const { token, roomId } = await getToken({ resourceType, resourceId });
        if (cancelled) return;

        const host = import.meta.env.VITE_PARTYKIT_HOST || "localhost:1999";

        const provider = new YPartyKitProvider(host, roomId, yDoc, {
          connect: true,
          params: { token },
        });

        providerRef.current = provider;

        provider.on("sync", (synced: boolean) => {
          if (!cancelled) {
            setIsConnected(synced);
            setIsLoading(false);
          }
        });

        provider.on("status", ({ status }: { status: string }) => {
          if (!cancelled) {
            setIsConnected(status === "connected");
          }
        });
      } catch (err) {
        console.error("Failed to connect to collaboration server:", err);
        if (!cancelled) setIsLoading(false);
      }
    };

    void connect();

    return () => {
      cancelled = true;
      // CRITICAL: destroy provider and doc to prevent memory leaks
      providerRef.current?.destroy();
      providerRef.current = null;
      // Do NOT destroy yDoc here if it's shared via useMemo
      // yDoc cleanup happens when resourceId changes (useMemo recreates)
    };
  }, [resourceType, resourceId, enabled, yDoc, getToken]);

  // Cleanup yDoc on unmount or resourceId change
  useEffect(() => {
    return () => {
      docRef.current?.destroy();
    };
  }, [resourceId]);

  return { yDoc, provider: providerRef.current, isConnected, isLoading };
}
```

Add `VITE_PARTYKIT_HOST` to `.env.local` (for dev: `VITE_PARTYKIT_HOST=localhost:1999`).

**Part B: Remove RTK cursor tracking**

Per locked decision: "RTK cursor cleanup: remove cursorSessions table/functions and use-cursor-tracking hook in this phase"

1. **Delete `src/hooks/use-cursor-tracking.ts`** entirely

2. **Delete `src/pages/App/Document/CursorOverlay.tsx`** entirely (the overlay component is tightly coupled to the RTK cursor system; Phase 12 will create a new cursor overlay using Yjs Awareness)

3. **Delete `convex/cursorSessions.ts`** entirely

4. **Update `convex/schema.ts`**: Remove the `cursorSessions` table definition (lines 230-235):
   ```typescript
   // DELETE THIS:
   cursorSessions: defineTable({
     documentId: v.id("documents"),
     cloudflareMeetingId: v.string(),
     active: v.boolean(),
   })
     .index("by_document_active", ["documentId", "active"]),
   ```

5. **Update `src/pages/App/Document/DocumentEditor.tsx`**:
   - Remove import of `useCursorTracking` from `../../../hooks/use-cursor-tracking`
   - Remove import of `CursorOverlay` from `./CursorOverlay`
   - Remove the `useCursorTracking` hook call: `const { cursors, onMouseMove, onMouseLeave } = useCursorTracking({...})`
   - Remove `onMouseMove` and `onMouseLeave` from the wrapper div props
   - Remove `<CursorOverlay cursors={cursors} />` from JSX
   - Keep all other functionality intact (BlockNote editor, presence, suggestion menus)
   - The document editor continues to work for editing, just without cursor overlay (Phase 12 adds Yjs-based cursors)

6. Check for any other imports of deleted files. Search for `use-cursor-tracking` and `CursorOverlay` and `cursorSessions` across the codebase and fix any remaining references.

**Note:** Do NOT remove the `@cloudflare/realtimekit-react` or `@cloudflare/realtimekit-react-ui` packages from package.json -- they are still used for video calls (`callSessions` table, not `cursorSessions`).
  </action>
  <verify>
1. `npm run lint` passes with zero warnings (no broken imports, no TypeScript errors)
2. Verify deleted files no longer exist: `ls src/hooks/use-cursor-tracking.ts convex/cursorSessions.ts src/pages/App/Document/CursorOverlay.tsx` should all fail
3. Verify no remaining references: `grep -r "use-cursor-tracking\|CursorOverlay\|cursorSessions" src/ convex/ --include="*.ts" --include="*.tsx"` returns nothing (excluding _generated)
4. `npm run build` succeeds
5. Verify `useYjsProvider` hook exists with proper types
  </verify>
  <done>
Frontend useYjsProvider hook created with auth token flow and proper cleanup. RTK cursor tracking fully removed (deleted use-cursor-tracking.ts, CursorOverlay.tsx, cursorSessions.ts, removed cursorSessions from schema). DocumentEditor still renders and edits documents (without cursor overlay, which Phase 12 will re-add with Yjs Awareness). No broken imports or TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero warnings
2. `npm run build` succeeds
3. `npm run dev` starts all 3 services (Vite + Convex + PartyKit)
4. PartyKit server on port 1999 with onBeforeConnect auth gate
5. Convex schema deployed with collaborationTokens table, without cursorSessions table
6. No references to use-cursor-tracking, CursorOverlay, or cursorSessions in src/ or convex/ (excluding _generated)
7. useYjsProvider hook available for Phase 12/13 consumption
</verification>

<success_criteria>
PartyKit server authenticates connections via Convex token passthrough. Frontend useYjsProvider hook handles the full lifecycle: token acquisition, PartyKit connection, Yjs sync, and cleanup. Legacy RTK cursor code is completely removed. The codebase compiles cleanly and the development workflow supports all three services.
</success_criteria>

<output>
After completion, create `.planning/phases/11-partykit-infrastructure-persistence/11-02-SUMMARY.md`
</output>
